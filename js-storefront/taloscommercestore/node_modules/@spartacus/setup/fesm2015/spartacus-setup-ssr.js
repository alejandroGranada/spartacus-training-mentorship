import { SERVER_REQUEST_URL, SERVER_REQUEST_ORIGIN } from '@spartacus/core';
import * as fs from 'fs';
import { readFileSync } from 'fs';
import { REQUEST } from '@nguniversal/express-engine/tokens';

var RenderingStrategy;
(function (RenderingStrategy) {
    RenderingStrategy[RenderingStrategy["ALWAYS_CSR"] = -1] = "ALWAYS_CSR";
    RenderingStrategy[RenderingStrategy["DEFAULT"] = 0] = "DEFAULT";
    RenderingStrategy[RenderingStrategy["ALWAYS_SSR"] = 1] = "ALWAYS_SSR";
})(RenderingStrategy || (RenderingStrategy = {}));

class RenderingCache {
    constructor(options) {
        this.options = options;
        this.renders = new Map();
    }
    setAsRendering(key) {
        this.renders.set(key, { rendering: true });
    }
    isRendering(key) {
        var _a;
        return !!((_a = this.renders.get(key)) === null || _a === void 0 ? void 0 : _a.rendering);
    }
    store(key, err, html) {
        var _a, _b;
        const entry = { err, html };
        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.ttl) {
            entry.time = Date.now();
        }
        if ((_b = this.options) === null || _b === void 0 ? void 0 : _b.cacheSize) {
            this.renders.delete(key);
            if (this.renders.size >= this.options.cacheSize) {
                this.renders.delete(this.renders.keys().next().value);
            }
        }
        this.renders.set(key, entry);
    }
    get(key) {
        return this.renders.get(key);
    }
    clear(key) {
        this.renders.delete(key);
    }
    isReady(key) {
        const entry = this.renders.get(key);
        const isRenderPresent = (entry === null || entry === void 0 ? void 0 : entry.html) || (entry === null || entry === void 0 ? void 0 : entry.err);
        return isRenderPresent && this.isFresh(key);
    }
    isFresh(key) {
        var _a, _b, _c, _d;
        if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.ttl)) {
            return true;
        }
        return Date.now() - ((_c = (_b = this.renders.get(key)) === null || _b === void 0 ? void 0 : _b.time) !== null && _c !== void 0 ? _c : 0) < ((_d = this.options) === null || _d === void 0 ? void 0 : _d.ttl);
    }
}

/* webpackIgnore: true */
/**
 * The rendered pages are kept in memory to be served on next request. If the `cache` is set to `false`, the
 * response is evicted as soon as the first successful response is successfully returned.
 */
class OptimizedSsrEngine {
    constructor(expressEngine, ssrOptions) {
        this.expressEngine = expressEngine;
        this.ssrOptions = ssrOptions;
        this.currentConcurrency = 0;
        this.renderingCache = new RenderingCache(this.ssrOptions);
        this.templateCache = new Map();
    }
    get engineInstance() {
        return this.renderResponse.bind(this);
    }
    /**
     * When SSR page can not be returned in time, we're returning index.html of
     * the CSR application.
     * The CSR application is returned with the "Cache-Control: no-store" response-header. This notifies external cache systems to not use the CSR application for the subsequent request.
     */
    fallbackToCsr(response, filePath, callback) {
        response.set('Cache-Control', 'no-store');
        callback(undefined, this.getDocument(filePath));
    }
    getRenderingKey(request) {
        var _a;
        return ((_a = this.ssrOptions) === null || _a === void 0 ? void 0 : _a.renderKeyResolver) ? this.ssrOptions.renderKeyResolver(request)
            : request.originalUrl;
    }
    getRenderingStrategy(request) {
        var _a;
        return ((_a = this.ssrOptions) === null || _a === void 0 ? void 0 : _a.renderingStrategyResolver) ? this.ssrOptions.renderingStrategyResolver(request)
            : RenderingStrategy.DEFAULT;
    }
    shouldRender(request) {
        var _a, _b;
        const concurrencyLimitExceed = ((_a = this.ssrOptions) === null || _a === void 0 ? void 0 : _a.concurrency) ? this.currentConcurrency >= this.ssrOptions.concurrency
            : false;
        const isRendering = this.renderingCache.isRendering(this.getRenderingKey(request));
        if (isRendering) {
            this.log(`CSR fallback: rendering in progress (${request.url})`);
        }
        else if (concurrencyLimitExceed) {
            this.log(`CSR fallback: Concurrency limit exceeded (${(_b = this.ssrOptions) === null || _b === void 0 ? void 0 : _b.concurrency})`);
        }
        return ((!isRendering &&
            !concurrencyLimitExceed &&
            this.getRenderingStrategy(request) !== RenderingStrategy.ALWAYS_CSR) ||
            this.getRenderingStrategy(request) === RenderingStrategy.ALWAYS_SSR);
    }
    shouldTimeout(request) {
        var _a;
        return (!!((_a = this.ssrOptions) === null || _a === void 0 ? void 0 : _a.timeout) ||
            this.getRenderingStrategy(request) === RenderingStrategy.ALWAYS_SSR);
    }
    getTimeout(request) {
        var _a, _b, _c, _d;
        return this.getRenderingStrategy(request) === RenderingStrategy.ALWAYS_SSR
            ? (_b = (_a = this.ssrOptions) === null || _a === void 0 ? void 0 : _a.forcedSsrTimeout) !== null && _b !== void 0 ? _b : 60000 : (_d = (_c = this.ssrOptions) === null || _c === void 0 ? void 0 : _c.timeout) !== null && _d !== void 0 ? _d : 0;
    }
    returnCachedRender(request, callback) {
        var _a;
        const key = this.getRenderingKey(request);
        if (this.renderingCache.isReady(key)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const cached = this.renderingCache.get(key);
            callback(cached.err, cached.html);
            if (!((_a = this.ssrOptions) === null || _a === void 0 ? void 0 : _a.cache)) {
                // we drop cached rendering if caching is disabled
                this.renderingCache.clear(key);
            }
            return true;
        }
        return false;
    }
    renderResponse(filePath, options, callback) {
        const request = options.req;
        const response = options.res || options.req.res;
        const renderingKey = this.getRenderingKey(request);
        if (!this.returnCachedRender(request, callback)) {
            if (this.shouldRender(request)) {
                this.currentConcurrency++;
                let waitingForRender;
                if (this.shouldTimeout(request)) {
                    // establish timeout for rendering
                    const timeout = this.getTimeout(request);
                    waitingForRender = setTimeout(() => {
                        waitingForRender = undefined;
                        this.fallbackToCsr(response, filePath, callback);
                        this.log(`SSR rendering exceeded timeout ${timeout}, fallbacking to CSR for ${request === null || request === void 0 ? void 0 : request.url}`, false);
                    }, timeout);
                }
                else {
                    this.fallbackToCsr(response, filePath, callback);
                }
                // start rendering
                this.renderingCache.setAsRendering(renderingKey);
                this.log(`Rendering started (${request === null || request === void 0 ? void 0 : request.url})`);
                this.expressEngine(filePath, options, (err, html) => {
                    var _a;
                    this.currentConcurrency--;
                    this.log(`Rendering completed (${request === null || request === void 0 ? void 0 : request.url})`);
                    if (waitingForRender) {
                        // if request is still waiting for render, return it
                        clearTimeout(waitingForRender);
                        callback(err, html);
                        // store the render only if caching is enabled
                        if ((_a = this.ssrOptions) === null || _a === void 0 ? void 0 : _a.cache) {
                            this.renderingCache.store(renderingKey, err, html);
                        }
                        else {
                            this.renderingCache.clear(renderingKey);
                        }
                    }
                    else {
                        // store the render for future use
                        this.renderingCache.store(renderingKey, err, html);
                    }
                });
            }
            else {
                // if there is already rendering in progress, return the fallback
                this.fallbackToCsr(response, filePath, callback);
            }
        }
        else {
            this.log(`Render from cache (${request === null || request === void 0 ? void 0 : request.url})`);
        }
    }
    log(message, debug = true) {
        var _a;
        if (!debug || ((_a = this.ssrOptions) === null || _a === void 0 ? void 0 : _a.debug)) {
            console.log(message);
        }
    }
    /** Retrieve the document from the cache or the filesystem */
    getDocument(filePath) {
        let doc = this.templateCache.get(filePath);
        if (!doc) {
            // fs.readFileSync could be missing in a browser, specifically
            // in a unit tests with { node: { fs: 'empty' } } webpack configuration
            doc = (fs === null || fs === void 0 ? void 0 : readFileSync) ? readFileSync(filePath, 'utf-8') : '';
            this.templateCache.set(filePath, doc);
        }
        return doc;
    }
}

/**
 * The wrapper over the standard ngExpressEngine, that provides tokens for Spartacus
 * @param ngExpressEngine
 */
class NgExpressEngineDecorator {
    /**
     * Returns the higher order ngExpressEngine with provided tokens for Spartacus
     *
     * @param ngExpressEngine
     */
    static get(ngExpressEngine, optimizationOptions) {
        const result = decorateExpressEngine(ngExpressEngine, optimizationOptions);
        return result;
    }
}
function decorateExpressEngine(ngExpressEngine, optimizationOptions = {
    concurrency: 20,
    timeout: 3000,
}) {
    return function (setupOptions) {
        var _a;
        const engineInstance = ngExpressEngine(Object.assign(Object.assign({}, setupOptions), { providers: [
                // add spartacus related providers
                ...getServerRequestProviders(),
                ...((_a = setupOptions.providers) !== null && _a !== void 0 ? _a : []),
            ] }));
        // apply optimization wrapper if optimization options were defined
        return optimizationOptions
            ? new OptimizedSsrEngine(engineInstance, optimizationOptions)
                .engineInstance
            : engineInstance;
    };
}
/**
 * Returns Spartacus providers to be passed to the Angular express engine (in SSR)
 *
 * @param options
 */
function getServerRequestProviders() {
    return [
        {
            provide: SERVER_REQUEST_URL,
            useFactory: getRequestUrl,
            deps: [REQUEST],
        },
        {
            provide: SERVER_REQUEST_ORIGIN,
            useFactory: getRequestOrigin,
            deps: [REQUEST],
        },
    ];
}
function getRequestUrl(req) {
    return getRequestOrigin(req) + req.originalUrl;
}
function getRequestOrigin(req) {
    // If express is resolving and trusting X-Forwarded-Host, we want to take it
    // into an account to properly generate request origin.
    const trustProxyFn = req.app.get('trust proxy fn');
    let forwardedHost = req.get('X-Forwarded-Host');
    if (forwardedHost && trustProxyFn(req.connection.remoteAddress, 0)) {
        if (forwardedHost.indexOf(',') !== -1) {
            // Note: X-Forwarded-Host is normally only ever a
            //       single value, but this is to be safe.
            forwardedHost = forwardedHost
                .substring(0, forwardedHost.indexOf(','))
                .trimRight();
        }
        return req.protocol + '://' + forwardedHost;
    }
    else {
        return req.protocol + '://' + req.get('host');
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { NgExpressEngineDecorator, OptimizedSsrEngine, RenderingCache, RenderingStrategy, getServerRequestProviders };
//# sourceMappingURL=spartacus-setup-ssr.js.map
