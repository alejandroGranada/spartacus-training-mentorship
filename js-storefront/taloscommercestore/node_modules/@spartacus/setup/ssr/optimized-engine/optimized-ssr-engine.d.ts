import { RenderingStrategy, SsrOptimizationOptions } from './ssr-optimization-options';
import { RenderingCache } from './rendering-cache';
import { NgExpressEngineInstance } from '../engine-decorator/ng-express-engine-decorator';
import { Request, Response } from 'express';
/**
 * The rendered pages are kept in memory to be served on next request. If the `cache` is set to `false`, the
 * response is evicted as soon as the first successful response is successfully returned.
 */
export declare class OptimizedSsrEngine {
    protected expressEngine: NgExpressEngineInstance;
    protected ssrOptions?: SsrOptimizationOptions | undefined;
    protected currentConcurrency: number;
    protected renderingCache: RenderingCache;
    private templateCache;
    get engineInstance(): NgExpressEngineInstance;
    constructor(expressEngine: NgExpressEngineInstance, ssrOptions?: SsrOptimizationOptions | undefined);
    /**
     * When SSR page can not be returned in time, we're returning index.html of
     * the CSR application.
     * The CSR application is returned with the "Cache-Control: no-store" response-header. This notifies external cache systems to not use the CSR application for the subsequent request.
     */
    protected fallbackToCsr(response: Response, filePath: string, callback: (err?: Error | null, html?: string) => void): void;
    protected getRenderingKey(request: Request): string;
    protected getRenderingStrategy(request: Request): RenderingStrategy;
    protected shouldRender(request: Request): boolean;
    protected shouldTimeout(request: Request): boolean;
    protected getTimeout(request: Request): number;
    protected returnCachedRender(request: Request, callback: (err?: Error | null, html?: string) => void): boolean;
    protected renderResponse(filePath: string, options: any, callback: (err?: Error | null, html?: string) => void): void;
    protected log(message: string, debug?: boolean): void;
    /** Retrieve the document from the cache or the filesystem */
    protected getDocument(filePath: string): string;
}
