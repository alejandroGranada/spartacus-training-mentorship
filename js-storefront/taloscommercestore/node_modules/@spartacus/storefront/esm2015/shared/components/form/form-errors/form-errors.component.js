import { ChangeDetectionStrategy, Component, HostBinding, Input, } from '@angular/core';
import { map, startWith } from 'rxjs/operators';
/**
 * This component renders form errors.
 */
export class FormErrorsComponent {
    constructor() {
        this.prefix = 'formErrors';
    }
    set control(control) {
        this._control = control;
        this.errors$ = control === null || control === void 0 ? void 0 : control.statusChanges.pipe(startWith({}), map(() => control.errors || {}), map((errors) => Object.entries(errors)
            .filter((error) => error[1])
            .map((error) => error[0])));
    }
    get control() {
        return this._control;
    }
    get invalid() {
        var _a;
        return (_a = this.control) === null || _a === void 0 ? void 0 : _a.invalid;
    }
    get dirty() {
        var _a;
        return (_a = this.control) === null || _a === void 0 ? void 0 : _a.dirty;
    }
    get touched() {
        var _a;
        return (_a = this.control) === null || _a === void 0 ? void 0 : _a.touched;
    }
}
FormErrorsComponent.decorators = [
    { type: Component, args: [{
                selector: 'cx-form-errors',
                template: "<p *ngFor=\"let errorName of errors$ | async\">\n  {{ prefix + '.' + errorName | cxTranslate: translationParams }}\n</p>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
FormErrorsComponent.propDecorators = {
    prefix: [{ type: Input }],
    translationParams: [{ type: Input }],
    control: [{ type: Input }],
    invalid: [{ type: HostBinding, args: ['class.control-invalid',] }],
    dirty: [{ type: HostBinding, args: ['class.control-dirty',] }],
    touched: [{ type: HostBinding, args: ['class.control-touched',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1lcnJvcnMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL1BhdHJ5ay9EZXNrdG9wL3NwYXJ0YWN1cy9wcm9qZWN0cy9zdG9yZWZyb250bGliL3NyYy8iLCJzb3VyY2VzIjpbInNoYXJlZC9jb21wb25lbnRzL2Zvcm0vZm9ybS1lcnJvcnMvZm9ybS1lcnJvcnMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEdBQ04sTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVoRDs7R0FFRztBQU1ILE1BQU0sT0FBTyxtQkFBbUI7SUFMaEM7UUFTVyxXQUFNLEdBQUcsWUFBWSxDQUFDO0lBaUNqQyxDQUFDO0lBNUJDLElBQ0ksT0FBTyxDQUFDLE9BQW9CO1FBQzlCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBRXhCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLGFBQWEsQ0FBQyxJQUFJLENBQ3hDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFDYixHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsRUFDL0IsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FDYixNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQzthQUNuQixNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMzQixHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUM1QixDQUNGLENBQUM7SUFDSixDQUFDO0lBRUQsSUFBSSxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxJQUEwQyxPQUFPOztRQUMvQyxhQUFPLElBQUksQ0FBQyxPQUFPLDBDQUFFLE9BQU8sQ0FBQztJQUMvQixDQUFDO0lBQ0QsSUFBd0MsS0FBSzs7UUFDM0MsYUFBTyxJQUFJLENBQUMsT0FBTywwQ0FBRSxLQUFLLENBQUM7SUFDN0IsQ0FBQztJQUNELElBQTBDLE9BQU87O1FBQy9DLGFBQU8sSUFBSSxDQUFDLE9BQU8sMENBQUUsT0FBTyxDQUFDO0lBQy9CLENBQUM7OztZQXpDRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsc0lBQTJDO2dCQUMzQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTthQUNoRDs7O3FCQUtFLEtBQUs7Z0NBRUwsS0FBSztzQkFHTCxLQUFLO3NCQW1CTCxXQUFXLFNBQUMsdUJBQXVCO29CQUduQyxXQUFXLFNBQUMscUJBQXFCO3NCQUdqQyxXQUFXLFNBQUMsdUJBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgSG9zdEJpbmRpbmcsXG4gIElucHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBzdGFydFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgcmVuZGVycyBmb3JtIGVycm9ycy5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY3gtZm9ybS1lcnJvcnMnLFxuICB0ZW1wbGF0ZVVybDogJy4vZm9ybS1lcnJvcnMuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgRm9ybUVycm9yc0NvbXBvbmVudCB7XG4gIF9jb250cm9sOiBGb3JtQ29udHJvbDtcbiAgZXJyb3JzJDogT2JzZXJ2YWJsZTxzdHJpbmdbXT47XG5cbiAgQElucHV0KCkgcHJlZml4ID0gJ2Zvcm1FcnJvcnMnO1xuXG4gIEBJbnB1dCgpXG4gIHRyYW5zbGF0aW9uUGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIEBJbnB1dCgpXG4gIHNldCBjb250cm9sKGNvbnRyb2w6IEZvcm1Db250cm9sKSB7XG4gICAgdGhpcy5fY29udHJvbCA9IGNvbnRyb2w7XG5cbiAgICB0aGlzLmVycm9ycyQgPSBjb250cm9sPy5zdGF0dXNDaGFuZ2VzLnBpcGUoXG4gICAgICBzdGFydFdpdGgoe30pLFxuICAgICAgbWFwKCgpID0+IGNvbnRyb2wuZXJyb3JzIHx8IHt9KSxcbiAgICAgIG1hcCgoZXJyb3JzKSA9PlxuICAgICAgICBPYmplY3QuZW50cmllcyhlcnJvcnMpXG4gICAgICAgICAgLmZpbHRlcigoZXJyb3IpID0+IGVycm9yWzFdKVxuICAgICAgICAgIC5tYXAoKGVycm9yKSA9PiBlcnJvclswXSlcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgZ2V0IGNvbnRyb2woKTogRm9ybUNvbnRyb2wge1xuICAgIHJldHVybiB0aGlzLl9jb250cm9sO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5jb250cm9sLWludmFsaWQnKSBnZXQgaW52YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sPy5pbnZhbGlkO1xuICB9XG4gIEBIb3N0QmluZGluZygnY2xhc3MuY29udHJvbC1kaXJ0eScpIGdldCBkaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sPy5kaXJ0eTtcbiAgfVxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmNvbnRyb2wtdG91Y2hlZCcpIGdldCB0b3VjaGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2w/LnRvdWNoZWQ7XG4gIH1cbn1cbiJdfQ==