import { Component, Input } from '@angular/core';
import { Router } from '@angular/router';
/**
 * This component navigates using [routerLink] attribute when input 'url' is a relative url. Otherwise (when it's absolute), [href] is used.
 */
export class GenericLinkComponent {
    constructor(router) {
        this.router = router;
        /**
         * Pattern matching string starting with `http://` or `https://`.
         */
        this.PROTOCOL_REGEX = /^https?:\/\//i;
        /**
         * Used to split url into 2 parts:
         * 1. the path
         * 2. query params + hash fragment
         */
        this.URL_SPLIT = /(^[^#?]*)(.*)/;
        /**
         * Parsed parts of the @Input `url`, when it's a local URL.
         * It should not be used when the `url` is external.
         * @see `url`
         */
        this.routeParts = {};
    }
    /**
     * Returns true when the @Input `url` is a string starting with `http://` or `https://`.
     */
    isExternalUrl() {
        return typeof this.url === 'string' && this.PROTOCOL_REGEX.test(this.url);
    }
    get rel() {
        return this.target === '_blank' ? 'noopener' : null;
    }
    ngOnChanges(changes) {
        if (changes['url']) {
            this.setUrlParts(changes['url'].currentValue);
        }
    }
    /**
     * The part with the path of the local url.
     */
    get routerUrl() {
        return this.routeParts.path;
    }
    /**
     * The part with the query params of the local url.
     */
    get queryParams() {
        return this.routeParts.queryParams;
    }
    /**
     * The part with the hash fragment of the local url.
     */
    get fragment() {
        return this.routeParts.fragment;
    }
    /**
     * Parses the given url and sets the property `urlParts` accordingly.
     */
    setUrlParts(url) {
        if (typeof url === 'string') {
            url = this.getAbsoluteUrl(url); // string links in CMS sometimes don't have the leading slash, so fix it here
            this.routeParts = this.splitUrl(url);
        }
        else {
            this.routeParts = { path: url };
        }
    }
    /**
     * Parses the given string into 3 parts:
     * - string path (wrapped in an array to be compatible with Angular syntax for the `routerLink`)
     * - query params (as an object)
     * - hash fragment (string)
     */
    splitUrl(url = '') {
        const { queryParams, fragment } = this.router.parseUrl(url);
        const [, path] = url.match(this.URL_SPLIT);
        // wrap path in an array, to have the Angular-like path format
        return { path: [path], queryParams, fragment };
    }
    /**
     * Prepends a leading slash to the given URL string, in case it doesn't have it.
     */
    getAbsoluteUrl(url) {
        return url.startsWith('/') ? url : '/' + url;
    }
}
GenericLinkComponent.decorators = [
    { type: Component, args: [{
                selector: 'cx-generic-link',
                template: "<!-- https://github.com/angular/angular/issues/24567 -->\n\n<ng-container *ngIf=\"isExternalUrl(); else isLocalUrl\">\n  <a\n    role=\"link\"\n    [href]=\"url\"\n    [attr.target]=\"target\"\n    [attr.rel]=\"rel\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-container>\n\n<ng-template #isLocalUrl>\n  <a\n    role=\"link\"\n    [routerLink]=\"routerUrl\"\n    [queryParams]=\"queryParams\"\n    [fragment]=\"fragment\"\n    [target]=\"target\"\n    [attr.id]=\"id\"\n    [attr.class]=\"class\"\n    [attr.style]=\"style\"\n    [attr.title]=\"title\"\n  >\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n  </a>\n</ng-template>\n\n<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n"
            },] }
];
GenericLinkComponent.ctorParameters = () => [
    { type: Router }
];
GenericLinkComponent.propDecorators = {
    url: [{ type: Input }],
    target: [{ type: Input }],
    id: [{ type: Input }],
    class: [{ type: Input }],
    style: [{ type: Input }],
    title: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJpYy1saW5rLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvc3RvcmVmcm9udGxpYi9zcmMvIiwic291cmNlcyI6WyJzaGFyZWQvY29tcG9uZW50cy9nZW5lcmljLWxpbmsvZ2VuZXJpYy1saW5rLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBNEIsTUFBTSxlQUFlLENBQUM7QUFDM0UsT0FBTyxFQUFVLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBY2pEOztHQUVHO0FBS0gsTUFBTSxPQUFPLG9CQUFvQjtJQUMvQixZQUFzQixNQUFjO1FBQWQsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUVwQzs7V0FFRztRQUNjLG1CQUFjLEdBQVcsZUFBZSxDQUFDO1FBRTFEOzs7O1dBSUc7UUFDYyxjQUFTLEdBQUcsZUFBZSxDQUFDO1FBRTdDOzs7O1dBSUc7UUFDSyxlQUFVLEdBQWUsRUFBRSxDQUFDO0lBbkJHLENBQUM7SUE0QnhDOztPQUVHO0lBQ0gsYUFBYTtRQUNYLE9BQU8sT0FBTyxJQUFJLENBQUMsR0FBRyxLQUFLLFFBQVEsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUVELElBQUksR0FBRztRQUNMLE9BQU8sSUFBSSxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ3RELENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDaEMsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDbEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDL0M7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUM7SUFDckMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxXQUFXLENBQUMsR0FBbUI7UUFDckMsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7WUFDM0IsR0FBRyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyw2RUFBNkU7WUFDN0csSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQWEsQ0FBQyxDQUFDO1NBQ2hEO2FBQU07WUFDTCxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDO1NBQ2pDO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssUUFBUSxDQUFDLE1BQWMsRUFBRTtRQUMvQixNQUFNLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzVELE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTNDLDhEQUE4RDtRQUM5RCxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxDQUFDO0lBQ2pELENBQUM7SUFFRDs7T0FFRztJQUNLLGNBQWMsQ0FBQyxHQUFXO1FBQ2hDLE9BQU8sR0FBRyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0lBQy9DLENBQUM7OztZQXRHRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0IsNjJCQUE0QzthQUM3Qzs7O1lBcEJnQixNQUFNOzs7a0JBMkNwQixLQUFLO3FCQUNMLEtBQUs7aUJBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGFyYW1zLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG4vLyBwcml2YXRlXG5pbnRlcmZhY2UgUm91dGVQYXJ0cyB7XG4gIC8qKiBQYXRoIGluIHRoZSBBbmd1bGFyLWxpa2UgYXJyYXkgZm9ybWF0ICovXG4gIHBhdGg/OiBzdHJpbmdbXTtcblxuICAvKiogUXVlcnkgcGFyYW1zICovXG4gIHF1ZXJ5UGFyYW1zPzogUGFyYW1zO1xuXG4gIC8qKiBIYXNoIGZyYWdtZW50ICovXG4gIGZyYWdtZW50Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IG5hdmlnYXRlcyB1c2luZyBbcm91dGVyTGlua10gYXR0cmlidXRlIHdoZW4gaW5wdXQgJ3VybCcgaXMgYSByZWxhdGl2ZSB1cmwuIE90aGVyd2lzZSAod2hlbiBpdCdzIGFic29sdXRlKSwgW2hyZWZdIGlzIHVzZWQuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2N4LWdlbmVyaWMtbGluaycsXG4gIHRlbXBsYXRlVXJsOiAnLi9nZW5lcmljLWxpbmsuY29tcG9uZW50Lmh0bWwnLFxufSlcbmV4cG9ydCBjbGFzcyBHZW5lcmljTGlua0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByb3V0ZXI6IFJvdXRlcikge31cblxuICAvKipcbiAgICogUGF0dGVybiBtYXRjaGluZyBzdHJpbmcgc3RhcnRpbmcgd2l0aCBgaHR0cDovL2Agb3IgYGh0dHBzOi8vYC5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgUFJPVE9DT0xfUkVHRVg6IFJlZ0V4cCA9IC9eaHR0cHM/OlxcL1xcLy9pO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNwbGl0IHVybCBpbnRvIDIgcGFydHM6XG4gICAqIDEuIHRoZSBwYXRoXG4gICAqIDIuIHF1ZXJ5IHBhcmFtcyArIGhhc2ggZnJhZ21lbnRcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgVVJMX1NQTElUID0gLyheW14jP10qKSguKikvO1xuXG4gIC8qKlxuICAgKiBQYXJzZWQgcGFydHMgb2YgdGhlIEBJbnB1dCBgdXJsYCwgd2hlbiBpdCdzIGEgbG9jYWwgVVJMLlxuICAgKiBJdCBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiB0aGUgYHVybGAgaXMgZXh0ZXJuYWwuXG4gICAqIEBzZWUgYHVybGBcbiAgICovXG4gIHByaXZhdGUgcm91dGVQYXJ0czogUm91dGVQYXJ0cyA9IHt9O1xuXG4gIEBJbnB1dCgpIHVybDogc3RyaW5nIHwgYW55W107XG4gIEBJbnB1dCgpIHRhcmdldDogc3RyaW5nO1xuICBASW5wdXQoKSBpZDogc3RyaW5nO1xuICBASW5wdXQoKSBjbGFzczogc3RyaW5nO1xuICBASW5wdXQoKSBzdHlsZTogc3RyaW5nO1xuICBASW5wdXQoKSB0aXRsZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgQElucHV0IGB1cmxgIGlzIGEgc3RyaW5nIHN0YXJ0aW5nIHdpdGggYGh0dHA6Ly9gIG9yIGBodHRwczovL2AuXG4gICAqL1xuICBpc0V4dGVybmFsVXJsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy51cmwgPT09ICdzdHJpbmcnICYmIHRoaXMuUFJPVE9DT0xfUkVHRVgudGVzdCh0aGlzLnVybCk7XG4gIH1cblxuICBnZXQgcmVsKCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldCA9PT0gJ19ibGFuaycgPyAnbm9vcGVuZXInIDogbnVsbDtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlc1sndXJsJ10pIHtcbiAgICAgIHRoaXMuc2V0VXJsUGFydHMoY2hhbmdlc1sndXJsJ10uY3VycmVudFZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHBhcnQgd2l0aCB0aGUgcGF0aCBvZiB0aGUgbG9jYWwgdXJsLlxuICAgKi9cbiAgZ2V0IHJvdXRlclVybCgpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMucm91dGVQYXJ0cy5wYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJ0IHdpdGggdGhlIHF1ZXJ5IHBhcmFtcyBvZiB0aGUgbG9jYWwgdXJsLlxuICAgKi9cbiAgZ2V0IHF1ZXJ5UGFyYW1zKCk6IFBhcmFtcyB7XG4gICAgcmV0dXJuIHRoaXMucm91dGVQYXJ0cy5xdWVyeVBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcGFydCB3aXRoIHRoZSBoYXNoIGZyYWdtZW50IG9mIHRoZSBsb2NhbCB1cmwuXG4gICAqL1xuICBnZXQgZnJhZ21lbnQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZVBhcnRzLmZyYWdtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJsIGFuZCBzZXRzIHRoZSBwcm9wZXJ0eSBgdXJsUGFydHNgIGFjY29yZGluZ2x5LlxuICAgKi9cbiAgcHJpdmF0ZSBzZXRVcmxQYXJ0cyh1cmw6IHN0cmluZyB8IGFueVtdKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1cmwgPSB0aGlzLmdldEFic29sdXRlVXJsKHVybCk7IC8vIHN0cmluZyBsaW5rcyBpbiBDTVMgc29tZXRpbWVzIGRvbid0IGhhdmUgdGhlIGxlYWRpbmcgc2xhc2gsIHNvIGZpeCBpdCBoZXJlXG4gICAgICB0aGlzLnJvdXRlUGFydHMgPSB0aGlzLnNwbGl0VXJsKHVybCBhcyBzdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvdXRlUGFydHMgPSB7IHBhdGg6IHVybCB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIHN0cmluZyBpbnRvIDMgcGFydHM6XG4gICAqIC0gc3RyaW5nIHBhdGggKHdyYXBwZWQgaW4gYW4gYXJyYXkgdG8gYmUgY29tcGF0aWJsZSB3aXRoIEFuZ3VsYXIgc3ludGF4IGZvciB0aGUgYHJvdXRlckxpbmtgKVxuICAgKiAtIHF1ZXJ5IHBhcmFtcyAoYXMgYW4gb2JqZWN0KVxuICAgKiAtIGhhc2ggZnJhZ21lbnQgKHN0cmluZylcbiAgICovXG4gIHByaXZhdGUgc3BsaXRVcmwodXJsOiBzdHJpbmcgPSAnJyk6IFJvdXRlUGFydHMge1xuICAgIGNvbnN0IHsgcXVlcnlQYXJhbXMsIGZyYWdtZW50IH0gPSB0aGlzLnJvdXRlci5wYXJzZVVybCh1cmwpO1xuICAgIGNvbnN0IFssIHBhdGhdID0gdXJsLm1hdGNoKHRoaXMuVVJMX1NQTElUKTtcblxuICAgIC8vIHdyYXAgcGF0aCBpbiBhbiBhcnJheSwgdG8gaGF2ZSB0aGUgQW5ndWxhci1saWtlIHBhdGggZm9ybWF0XG4gICAgcmV0dXJuIHsgcGF0aDogW3BhdGhdLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwZW5kcyBhIGxlYWRpbmcgc2xhc2ggdG8gdGhlIGdpdmVuIFVSTCBzdHJpbmcsIGluIGNhc2UgaXQgZG9lc24ndCBoYXZlIGl0LlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRBYnNvbHV0ZVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKCcvJykgPyB1cmwgOiAnLycgKyB1cmw7XG4gIH1cbn1cbiJdfQ==