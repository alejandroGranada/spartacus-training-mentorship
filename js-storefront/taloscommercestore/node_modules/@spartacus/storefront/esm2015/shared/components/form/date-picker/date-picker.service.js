import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * Service that provides the placeholder and input pattern for date pickers. This is
 * used in Spartacus to support browser that won't support the native html5 date picker
 * using `<input type="date">`.
 *
 * While the placeholder is configurable, you should be aware that the placeholder format
 * defaults to `yyyy-mm-dd` to align with Safaris limited support of ISO 8601.
 * Another consideration is the support of date formats in the backend. In case you change
 * this format, you might need to serialize the date to the supported date format in the
 * backend.
 *
 */
export class DatePickerService {
    get placeholder() {
        return 'yyyy-mm-dd';
    }
    /**
     * The default date pattern is based on the placeholder string;
     */
    get pattern() {
        return this.placeholder
            .replace('yyyy', '\\d{4}')
            .replace('mm', '\\d{1,2}')
            .replace('dd', '\\d{1,2}');
    }
    /**
     * Validates if the string based date value is a valid date.
     */
    isValidFormat(date, pattern) {
        const patternRegex = new RegExp(`^${pattern !== null && pattern !== void 0 ? pattern : this.pattern}$`);
        return patternRegex.test(date);
    }
    /**
     * Since Safari doesn't support proper date formats (ISO 8601), we need to do this
     * ourselves. We cannot rely on `new Date('2020-1-1')`. This will fail, only
     * `new Date('2020-01-01')` works.
     */
    getDate(value) {
        if (!value) {
            return;
        }
        const delimiter = this.placeholder
            .replace('yyyy', '')
            .replace('mm', '')
            .replace('dd', '')
            .substr(0, 1);
        const dateParts = value.split(delimiter);
        const placeholderParts = this.placeholder.split(delimiter);
        const y = placeholderParts.indexOf('yyyy');
        const m = placeholderParts.indexOf('mm');
        const d = placeholderParts.indexOf('dd');
        return new Date(Number(dateParts[y]), Number(dateParts[m]) - 1, Number(dateParts[d]));
    }
}
DatePickerService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DatePickerService_Factory() { return new DatePickerService(); }, token: DatePickerService, providedIn: "root" });
DatePickerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvc3RvcmVmcm9udGxpYi9zcmMvIiwic291cmNlcyI6WyJzaGFyZWQvY29tcG9uZW50cy9mb3JtL2RhdGUtcGlja2VyL2RhdGUtcGlja2VyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7QUFFM0M7Ozs7Ozs7Ozs7O0dBV0c7QUFJSCxNQUFNLE9BQU8saUJBQWlCO0lBQzVCLElBQUksV0FBVztRQUNiLE9BQU8sWUFBWSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDLFdBQVc7YUFDcEIsT0FBTyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUM7YUFDekIsT0FBTyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUM7YUFDekIsT0FBTyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxhQUFhLENBQUMsSUFBWSxFQUFFLE9BQWdCO1FBQzFDLE1BQU0sWUFBWSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksT0FBTyxhQUFQLE9BQU8sY0FBUCxPQUFPLEdBQUksSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDaEUsT0FBTyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsT0FBTyxDQUFDLEtBQWE7UUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLE9BQU87U0FDUjtRQUVELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXO2FBQy9CLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDO2FBQ25CLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDO2FBQ2pCLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDO2FBQ2pCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFaEIsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUV6QyxNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTNELE1BQU0sQ0FBQyxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMzQyxNQUFNLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekMsTUFBTSxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXpDLE9BQU8sSUFBSSxJQUFJLENBQ2IsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUNwQixNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUN4QixNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3JCLENBQUM7SUFDSixDQUFDOzs7O1lBdkRGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBTZXJ2aWNlIHRoYXQgcHJvdmlkZXMgdGhlIHBsYWNlaG9sZGVyIGFuZCBpbnB1dCBwYXR0ZXJuIGZvciBkYXRlIHBpY2tlcnMuIFRoaXMgaXNcbiAqIHVzZWQgaW4gU3BhcnRhY3VzIHRvIHN1cHBvcnQgYnJvd3NlciB0aGF0IHdvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBodG1sNSBkYXRlIHBpY2tlclxuICogdXNpbmcgYDxpbnB1dCB0eXBlPVwiZGF0ZVwiPmAuXG4gKlxuICogV2hpbGUgdGhlIHBsYWNlaG9sZGVyIGlzIGNvbmZpZ3VyYWJsZSwgeW91IHNob3VsZCBiZSBhd2FyZSB0aGF0IHRoZSBwbGFjZWhvbGRlciBmb3JtYXRcbiAqIGRlZmF1bHRzIHRvIGB5eXl5LW1tLWRkYCB0byBhbGlnbiB3aXRoIFNhZmFyaXMgbGltaXRlZCBzdXBwb3J0IG9mIElTTyA4NjAxLlxuICogQW5vdGhlciBjb25zaWRlcmF0aW9uIGlzIHRoZSBzdXBwb3J0IG9mIGRhdGUgZm9ybWF0cyBpbiB0aGUgYmFja2VuZC4gSW4gY2FzZSB5b3UgY2hhbmdlXG4gKiB0aGlzIGZvcm1hdCwgeW91IG1pZ2h0IG5lZWQgdG8gc2VyaWFsaXplIHRoZSBkYXRlIHRvIHRoZSBzdXBwb3J0ZWQgZGF0ZSBmb3JtYXQgaW4gdGhlXG4gKiBiYWNrZW5kLlxuICpcbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIERhdGVQaWNrZXJTZXJ2aWNlIHtcbiAgZ2V0IHBsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd5eXl5LW1tLWRkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBkYXRlIHBhdHRlcm4gaXMgYmFzZWQgb24gdGhlIHBsYWNlaG9sZGVyIHN0cmluZztcbiAgICovXG4gIGdldCBwYXR0ZXJuKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucGxhY2Vob2xkZXJcbiAgICAgIC5yZXBsYWNlKCd5eXl5JywgJ1xcXFxkezR9JylcbiAgICAgIC5yZXBsYWNlKCdtbScsICdcXFxcZHsxLDJ9JylcbiAgICAgIC5yZXBsYWNlKCdkZCcsICdcXFxcZHsxLDJ9Jyk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGlmIHRoZSBzdHJpbmcgYmFzZWQgZGF0ZSB2YWx1ZSBpcyBhIHZhbGlkIGRhdGUuXG4gICAqL1xuICBpc1ZhbGlkRm9ybWF0KGRhdGU6IHN0cmluZywgcGF0dGVybj86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHBhdHRlcm5SZWdleCA9IG5ldyBSZWdFeHAoYF4ke3BhdHRlcm4gPz8gdGhpcy5wYXR0ZXJufSRgKTtcbiAgICByZXR1cm4gcGF0dGVyblJlZ2V4LnRlc3QoZGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2luY2UgU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCBwcm9wZXIgZGF0ZSBmb3JtYXRzIChJU08gODYwMSksIHdlIG5lZWQgdG8gZG8gdGhpc1xuICAgKiBvdXJzZWx2ZXMuIFdlIGNhbm5vdCByZWx5IG9uIGBuZXcgRGF0ZSgnMjAyMC0xLTEnKWAuIFRoaXMgd2lsbCBmYWlsLCBvbmx5XG4gICAqIGBuZXcgRGF0ZSgnMjAyMC0wMS0wMScpYCB3b3Jrcy5cbiAgICovXG4gIGdldERhdGUodmFsdWU6IHN0cmluZyk6IERhdGUge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkZWxpbWl0ZXIgPSB0aGlzLnBsYWNlaG9sZGVyXG4gICAgICAucmVwbGFjZSgneXl5eScsICcnKVxuICAgICAgLnJlcGxhY2UoJ21tJywgJycpXG4gICAgICAucmVwbGFjZSgnZGQnLCAnJylcbiAgICAgIC5zdWJzdHIoMCwgMSk7XG5cbiAgICBjb25zdCBkYXRlUGFydHMgPSB2YWx1ZS5zcGxpdChkZWxpbWl0ZXIpO1xuXG4gICAgY29uc3QgcGxhY2Vob2xkZXJQYXJ0cyA9IHRoaXMucGxhY2Vob2xkZXIuc3BsaXQoZGVsaW1pdGVyKTtcblxuICAgIGNvbnN0IHkgPSBwbGFjZWhvbGRlclBhcnRzLmluZGV4T2YoJ3l5eXknKTtcbiAgICBjb25zdCBtID0gcGxhY2Vob2xkZXJQYXJ0cy5pbmRleE9mKCdtbScpO1xuICAgIGNvbnN0IGQgPSBwbGFjZWhvbGRlclBhcnRzLmluZGV4T2YoJ2RkJyk7XG5cbiAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICBOdW1iZXIoZGF0ZVBhcnRzW3ldKSxcbiAgICAgIE51bWJlcihkYXRlUGFydHNbbV0pIC0gMSxcbiAgICAgIE51bWJlcihkYXRlUGFydHNbZF0pXG4gICAgKTtcbiAgfVxufVxuIl19