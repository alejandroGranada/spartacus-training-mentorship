import { Inject, Injectable } from '@angular/core';
import { Config } from '@spartacus/core';
import { BreakpointService } from '../../../layout/breakpoint/breakpoint.service';
import { ImageLoadingStrategy, } from './media.model';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
import * as i2 from "../../../layout/breakpoint/breakpoint.service";
/**
 * Service which generates media URLs. It leverage the MediaContainer and MediaFormats so
 * that URLs and sizes are generated for the same media. This helps to improve performance
 * across difference devices and layouts.
 *
 * Media formats are optional, but highly recommended. The format will help the browser to
 * identify the right media for the right experience.
 *
 * The MediaService will generate absolute URLs in case relative URLs are provided for the Media.
 * The baseUrl is read from the `occConfig.backend.media.baseUrl` or
 * `occConfig.backend.occ.baseUrl`.
 */
export class MediaService {
    constructor(config, 
    /**
     * The BreakpointService is no longer used in version 2.0 as the different size formats are
     * driven by configuration only. There's however a change that this service will play a role
     * in the near future, which is why we keep the constructor as-is.
     *
     * @deprecated
     */
    breakpointService) {
        this.config = config;
        this.breakpointService = breakpointService;
    }
    /**
     * Returns a `Media` object with the main media (`src`) and various media (`src`)
     * for specific formats.
     */
    getMedia(mediaContainer, format, alt) {
        if (!mediaContainer) {
            return;
        }
        const mainMedia = mediaContainer.url
            ? mediaContainer
            : this.resolveMedia(mediaContainer, format);
        return {
            src: this.resolveAbsoluteUrl(mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.url),
            alt: alt || (mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.altText),
            srcset: this.resolveSrcSet(mediaContainer, format),
        };
    }
    /**
     * Reads the loading strategy from the `MediaConfig`.
     *
     * Defaults to `ImageLoadingStrategy.EAGER`.
     */
    get loadingStrategy() {
        var _a, _b;
        return ((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.imageLoadingStrategy) !== null && _b !== void 0 ? _b : ImageLoadingStrategy.EAGER);
    }
    /**
     * Creates the media formats in a logical sorted order. The map contains the
     * format key and the format size information. We do this only once for performance
     * benefits.
     */
    get sortedFormats() {
        var _a, _b;
        if (!this._sortedFormats && ((_a = this.config) === null || _a === void 0 ? void 0 : _a.mediaFormats)) {
            this._sortedFormats = Object.keys(this.config.mediaFormats)
                .map((key) => ({
                code: key,
                size: this.config.mediaFormats[key],
            }))
                .sort((a, b) => (a.size.width > b.size.width ? 1 : -1));
        }
        return (_b = this._sortedFormats) !== null && _b !== void 0 ? _b : [];
    }
    /**
     * Creates the media formats in a reversed sorted order.
     */
    get reversedFormats() {
        if (!this._reversedFormats) {
            this._reversedFormats = this.sortedFormats.slice().reverse();
        }
        return this._reversedFormats;
    }
    /**
     * Resolves the right media for the given format. The fo
     */
    resolveMedia(media, format) {
        return media[this.resolveFormat(media, format)];
    }
    /**
     * Validates the format against the given mediaContainer. If there is no format available,
     * or if the mediaContainer doesn't contain a media for the given media, the most optimal
     * format is resolved. If even that is not possible, the first format is returned.
     */
    resolveFormat(mediaContainer, format) {
        if (format && mediaContainer[format]) {
            return format;
        }
        return (this.resolveBestFormat(mediaContainer) || Object.keys(mediaContainer)[0]);
    }
    /**
     * Returns the media format code with the best size.
     */
    resolveBestFormat(media) {
        var _a;
        return (_a = this.reversedFormats.find((format) => media.hasOwnProperty(format.code))) === null || _a === void 0 ? void 0 : _a.code;
    }
    /**
     * Returns a set of media for the available media formats. Additionally, the configured media
     * format width is added to the srcset, so that browsers can select the appropriate media.
     *
     * The optional maxFormat indicates that only sources till a certain format should be added
     * to the srcset.
     */
    resolveSrcSet(media, maxFormat) {
        if (!media) {
            return undefined;
        }
        // Only create srcset images that are smaller than the given `maxFormat` (if any)
        let formats = this.sortedFormats;
        const max = formats.findIndex((f) => f.code === maxFormat);
        if (max > -1) {
            formats = formats.slice(0, max + 1);
        }
        const srcset = formats.reduce((set, format) => {
            if (!!media[format.code]) {
                if (set) {
                    set += ', ';
                }
                set += `${this.resolveAbsoluteUrl(media[format.code].url)} ${format.size.width}w`;
            }
            return set;
        }, '');
        return srcset === '' ? undefined : srcset;
    }
    /**
     * Resolves the absolute URL for the given url. In most cases, this URL represents
     * the relative URL on the backend. In that case, we prefix the url with the baseUrl.
     *
     * When we have receive an absolute URL, we return the URL as-is. An absolute URL might also
     * start with double slash, which is used to resolve media cross from http and https.
     */
    resolveAbsoluteUrl(url) {
        return !url || url.startsWith('http') || url.startsWith('//')
            ? url
            : this.getBaseUrl() + url;
    }
    /**
     * The base URL is either driven by a specific `backend.media.baseUrl`, or by the
     * `backend.occ.baseUrl`.
     *
     * The `backend.media.baseUrl` can be used to load media from a different location.
     *
     * In Commerce Cloud, a different location could mean a different "aspect".
     *
     * Defaults to empty string in case no config is provided.
     */
    getBaseUrl() {
        var _a, _b, _c, _d, _e, _f;
        return ((_f = (_c = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.media) === null || _b === void 0 ? void 0 : _b.baseUrl) !== null && _c !== void 0 ? _c : (_e = (_d = this.config.backend) === null || _d === void 0 ? void 0 : _d.occ) === null || _e === void 0 ? void 0 : _e.baseUrl) !== null && _f !== void 0 ? _f : '');
    }
}
MediaService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MediaService_Factory() { return new MediaService(i0.ɵɵinject(i1.Config), i0.ɵɵinject(i2.BreakpointService)); }, token: MediaService, providedIn: "root" });
MediaService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
MediaService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [Config,] }] },
    { type: BreakpointService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVkaWEuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvc3RvcmVmcm9udGxpYi9zcmMvIiwic291cmNlcyI6WyJzaGFyZWQvY29tcG9uZW50cy9tZWRpYS9tZWRpYS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxNQUFNLEVBQW9CLE1BQU0saUJBQWlCLENBQUM7QUFDM0QsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sK0NBQStDLENBQUM7QUFHbEYsT0FBTyxFQUNMLG9CQUFvQixHQUlyQixNQUFNLGVBQWUsQ0FBQzs7OztBQUV2Qjs7Ozs7Ozs7Ozs7R0FXRztBQUlILE1BQU0sT0FBTyxZQUFZO0lBUXZCLFlBQzRCLE1BQXdCO0lBQ2xEOzs7Ozs7T0FNRztJQUNPLGlCQUFvQztRQVJwQixXQUFNLEdBQU4sTUFBTSxDQUFrQjtRQVF4QyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO0lBQzdDLENBQUM7SUFFSjs7O09BR0c7SUFDSCxRQUFRLENBQ04sY0FBc0MsRUFDdEMsTUFBZSxFQUNmLEdBQVk7UUFFWixJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ25CLE9BQU87U0FDUjtRQUVELE1BQU0sU0FBUyxHQUFVLGNBQWMsQ0FBQyxHQUFHO1lBQ3pDLENBQUMsQ0FBQyxjQUFjO1lBQ2hCLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWdDLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFaEUsT0FBTztZQUNMLEdBQUcsRUFBRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFFLEdBQUcsQ0FBQztZQUM1QyxHQUFHLEVBQUUsR0FBRyxLQUFJLFNBQVMsYUFBVCxTQUFTLHVCQUFULFNBQVMsQ0FBRSxPQUFP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QUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7NENBVUksTUFBTSxTQUFDLE1BQU07WUFsQ1QsaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb25maWcsIEltYWdlLCBPY2NDb25maWcgfSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xuaW1wb3J0IHsgQnJlYWtwb2ludFNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9sYXlvdXQvYnJlYWtwb2ludC9icmVha3BvaW50LnNlcnZpY2UnO1xuaW1wb3J0IHsgU3RvcmVmcm9udENvbmZpZyB9IGZyb20gJy4uLy4uLy4uL3N0b3JlZnJvbnQtY29uZmlnJztcbmltcG9ydCB7IE1lZGlhQ29uZmlnIH0gZnJvbSAnLi9tZWRpYS5jb25maWcnO1xuaW1wb3J0IHtcbiAgSW1hZ2VMb2FkaW5nU3RyYXRlZ3ksXG4gIE1lZGlhLFxuICBNZWRpYUNvbnRhaW5lcixcbiAgTWVkaWFGb3JtYXRTaXplLFxufSBmcm9tICcuL21lZGlhLm1vZGVsJztcblxuLyoqXG4gKiBTZXJ2aWNlIHdoaWNoIGdlbmVyYXRlcyBtZWRpYSBVUkxzLiBJdCBsZXZlcmFnZSB0aGUgTWVkaWFDb250YWluZXIgYW5kIE1lZGlhRm9ybWF0cyBzb1xuICogdGhhdCBVUkxzIGFuZCBzaXplcyBhcmUgZ2VuZXJhdGVkIGZvciB0aGUgc2FtZSBtZWRpYS4gVGhpcyBoZWxwcyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG4gKiBhY3Jvc3MgZGlmZmVyZW5jZSBkZXZpY2VzIGFuZCBsYXlvdXRzLlxuICpcbiAqIE1lZGlhIGZvcm1hdHMgYXJlIG9wdGlvbmFsLCBidXQgaGlnaGx5IHJlY29tbWVuZGVkLiBUaGUgZm9ybWF0IHdpbGwgaGVscCB0aGUgYnJvd3NlciB0b1xuICogaWRlbnRpZnkgdGhlIHJpZ2h0IG1lZGlhIGZvciB0aGUgcmlnaHQgZXhwZXJpZW5jZS5cbiAqXG4gKiBUaGUgTWVkaWFTZXJ2aWNlIHdpbGwgZ2VuZXJhdGUgYWJzb2x1dGUgVVJMcyBpbiBjYXNlIHJlbGF0aXZlIFVSTHMgYXJlIHByb3ZpZGVkIGZvciB0aGUgTWVkaWEuXG4gKiBUaGUgYmFzZVVybCBpcyByZWFkIGZyb20gdGhlIGBvY2NDb25maWcuYmFja2VuZC5tZWRpYS5iYXNlVXJsYCBvclxuICogYG9jY0NvbmZpZy5iYWNrZW5kLm9jYy5iYXNlVXJsYC5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIE1lZGlhU2VydmljZSB7XG4gIC8qKlxuICAgKiBUaGUgbWVkaWEgZm9ybWF0cyBzb3J0ZWQgYnkgc2l6ZS4gVGhlIG1lZGlhIGZvcm1hdCByZXByZXNlbnRpbmcgdGhlIHNtYWxsZXN0XG4gICAqIHNpemUgaXMgc29ydGVkIG9uIHRvcC5cbiAgICovXG4gIHByaXZhdGUgX3NvcnRlZEZvcm1hdHM6IHsgY29kZTogc3RyaW5nOyBzaXplOiBNZWRpYUZvcm1hdFNpemUgfVtdO1xuICBwcml2YXRlIF9yZXZlcnNlZEZvcm1hdHM6IHsgY29kZTogc3RyaW5nOyBzaXplOiBNZWRpYUZvcm1hdFNpemUgfVtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoQ29uZmlnKSBwcm90ZWN0ZWQgY29uZmlnOiBTdG9yZWZyb250Q29uZmlnLFxuICAgIC8qKlxuICAgICAqIFRoZSBCcmVha3BvaW50U2VydmljZSBpcyBubyBsb25nZXIgdXNlZCBpbiB2ZXJzaW9uIDIuMCBhcyB0aGUgZGlmZmVyZW50IHNpemUgZm9ybWF0cyBhcmVcbiAgICAgKiBkcml2ZW4gYnkgY29uZmlndXJhdGlvbiBvbmx5LiBUaGVyZSdzIGhvd2V2ZXIgYSBjaGFuZ2UgdGhhdCB0aGlzIHNlcnZpY2Ugd2lsbCBwbGF5IGEgcm9sZVxuICAgICAqIGluIHRoZSBuZWFyIGZ1dHVyZSwgd2hpY2ggaXMgd2h5IHdlIGtlZXAgdGhlIGNvbnN0cnVjdG9yIGFzLWlzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYnJlYWtwb2ludFNlcnZpY2U6IEJyZWFrcG9pbnRTZXJ2aWNlXG4gICkge31cblxuICAvKipcbiAgICogUmV0dXJucyBhIGBNZWRpYWAgb2JqZWN0IHdpdGggdGhlIG1haW4gbWVkaWEgKGBzcmNgKSBhbmQgdmFyaW91cyBtZWRpYSAoYHNyY2ApXG4gICAqIGZvciBzcGVjaWZpYyBmb3JtYXRzLlxuICAgKi9cbiAgZ2V0TWVkaWEoXG4gICAgbWVkaWFDb250YWluZXI6IE1lZGlhQ29udGFpbmVyIHwgSW1hZ2UsXG4gICAgZm9ybWF0Pzogc3RyaW5nLFxuICAgIGFsdD86IHN0cmluZ1xuICApOiBNZWRpYSB7XG4gICAgaWYgKCFtZWRpYUNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1haW5NZWRpYTogSW1hZ2UgPSBtZWRpYUNvbnRhaW5lci51cmxcbiAgICAgID8gbWVkaWFDb250YWluZXJcbiAgICAgIDogdGhpcy5yZXNvbHZlTWVkaWEobWVkaWFDb250YWluZXIgYXMgTWVkaWFDb250YWluZXIsIGZvcm1hdCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3JjOiB0aGlzLnJlc29sdmVBYnNvbHV0ZVVybChtYWluTWVkaWE/LnVybCksXG4gICAgICBhbHQ6IGFsdCB8fCBtYWluTWVkaWE/LmFsdFRleHQsXG4gICAgICBzcmNzZXQ6IHRoaXMucmVzb2x2ZVNyY1NldChtZWRpYUNvbnRhaW5lciwgZm9ybWF0KSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBsb2FkaW5nIHN0cmF0ZWd5IGZyb20gdGhlIGBNZWRpYUNvbmZpZ2AuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGBJbWFnZUxvYWRpbmdTdHJhdGVneS5FQUdFUmAuXG4gICAqL1xuICBnZXQgbG9hZGluZ1N0cmF0ZWd5KCk6IEltYWdlTG9hZGluZ1N0cmF0ZWd5IHtcbiAgICByZXR1cm4gKFxuICAgICAgKHRoaXMuY29uZmlnIGFzIE1lZGlhQ29uZmlnKT8uaW1hZ2VMb2FkaW5nU3RyYXRlZ3kgPz9cbiAgICAgIEltYWdlTG9hZGluZ1N0cmF0ZWd5LkVBR0VSXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBtZWRpYSBmb3JtYXRzIGluIGEgbG9naWNhbCBzb3J0ZWQgb3JkZXIuIFRoZSBtYXAgY29udGFpbnMgdGhlXG4gICAqIGZvcm1hdCBrZXkgYW5kIHRoZSBmb3JtYXQgc2l6ZSBpbmZvcm1hdGlvbi4gV2UgZG8gdGhpcyBvbmx5IG9uY2UgZm9yIHBlcmZvcm1hbmNlXG4gICAqIGJlbmVmaXRzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBzb3J0ZWRGb3JtYXRzKCk6IHsgY29kZTogc3RyaW5nOyBzaXplOiBNZWRpYUZvcm1hdFNpemUgfVtdIHtcbiAgICBpZiAoIXRoaXMuX3NvcnRlZEZvcm1hdHMgJiYgKHRoaXMuY29uZmlnIGFzIE1lZGlhQ29uZmlnKT8ubWVkaWFGb3JtYXRzKSB7XG4gICAgICB0aGlzLl9zb3J0ZWRGb3JtYXRzID0gT2JqZWN0LmtleXMoXG4gICAgICAgICh0aGlzLmNvbmZpZyBhcyBNZWRpYUNvbmZpZykubWVkaWFGb3JtYXRzXG4gICAgICApXG4gICAgICAgIC5tYXAoKGtleSkgPT4gKHtcbiAgICAgICAgICBjb2RlOiBrZXksXG4gICAgICAgICAgc2l6ZTogKHRoaXMuY29uZmlnIGFzIE1lZGlhQ29uZmlnKS5tZWRpYUZvcm1hdHNba2V5XSxcbiAgICAgICAgfSkpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiAoYS5zaXplLndpZHRoID4gYi5zaXplLndpZHRoID8gMSA6IC0xKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zb3J0ZWRGb3JtYXRzID8/IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1lZGlhIGZvcm1hdHMgaW4gYSByZXZlcnNlZCBzb3J0ZWQgb3JkZXIuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0IHJldmVyc2VkRm9ybWF0cygpOiB7IGNvZGU6IHN0cmluZzsgc2l6ZTogTWVkaWFGb3JtYXRTaXplIH1bXSB7XG4gICAgaWYgKCF0aGlzLl9yZXZlcnNlZEZvcm1hdHMpIHtcbiAgICAgIHRoaXMuX3JldmVyc2VkRm9ybWF0cyA9IHRoaXMuc29ydGVkRm9ybWF0cy5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VkRm9ybWF0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgcmlnaHQgbWVkaWEgZm9yIHRoZSBnaXZlbiBmb3JtYXQuIFRoZSBmb1xuICAgKi9cbiAgcHJvdGVjdGVkIHJlc29sdmVNZWRpYShtZWRpYTogTWVkaWFDb250YWluZXIsIGZvcm1hdD86IHN0cmluZyk6IEltYWdlIHtcbiAgICByZXR1cm4gbWVkaWFbdGhpcy5yZXNvbHZlRm9ybWF0KG1lZGlhLCBmb3JtYXQpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGZvcm1hdCBhZ2FpbnN0IHRoZSBnaXZlbiBtZWRpYUNvbnRhaW5lci4gSWYgdGhlcmUgaXMgbm8gZm9ybWF0IGF2YWlsYWJsZSxcbiAgICogb3IgaWYgdGhlIG1lZGlhQ29udGFpbmVyIGRvZXNuJ3QgY29udGFpbiBhIG1lZGlhIGZvciB0aGUgZ2l2ZW4gbWVkaWEsIHRoZSBtb3N0IG9wdGltYWxcbiAgICogZm9ybWF0IGlzIHJlc29sdmVkLiBJZiBldmVuIHRoYXQgaXMgbm90IHBvc3NpYmxlLCB0aGUgZmlyc3QgZm9ybWF0IGlzIHJldHVybmVkLlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlc29sdmVGb3JtYXQoXG4gICAgbWVkaWFDb250YWluZXI6IE1lZGlhQ29udGFpbmVyLFxuICAgIGZvcm1hdD86IHN0cmluZ1xuICApOiBzdHJpbmcge1xuICAgIGlmIChmb3JtYXQgJiYgbWVkaWFDb250YWluZXJbZm9ybWF0XSkge1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVzb2x2ZUJlc3RGb3JtYXQobWVkaWFDb250YWluZXIpIHx8IE9iamVjdC5rZXlzKG1lZGlhQ29udGFpbmVyKVswXVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWVkaWEgZm9ybWF0IGNvZGUgd2l0aCB0aGUgYmVzdCBzaXplLlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlc29sdmVCZXN0Rm9ybWF0KG1lZGlhOiBNZWRpYUNvbnRhaW5lciB8IEltYWdlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZEZvcm1hdHMuZmluZCgoZm9ybWF0KSA9PlxuICAgICAgbWVkaWEuaGFzT3duUHJvcGVydHkoZm9ybWF0LmNvZGUpXG4gICAgKT8uY29kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2V0IG9mIG1lZGlhIGZvciB0aGUgYXZhaWxhYmxlIG1lZGlhIGZvcm1hdHMuIEFkZGl0aW9uYWxseSwgdGhlIGNvbmZpZ3VyZWQgbWVkaWFcbiAgICogZm9ybWF0IHdpZHRoIGlzIGFkZGVkIHRvIHRoZSBzcmNzZXQsIHNvIHRoYXQgYnJvd3NlcnMgY2FuIHNlbGVjdCB0aGUgYXBwcm9wcmlhdGUgbWVkaWEuXG4gICAqXG4gICAqIFRoZSBvcHRpb25hbCBtYXhGb3JtYXQgaW5kaWNhdGVzIHRoYXQgb25seSBzb3VyY2VzIHRpbGwgYSBjZXJ0YWluIGZvcm1hdCBzaG91bGQgYmUgYWRkZWRcbiAgICogdG8gdGhlIHNyY3NldC5cbiAgICovXG4gIHByb3RlY3RlZCByZXNvbHZlU3JjU2V0KFxuICAgIG1lZGlhOiBNZWRpYUNvbnRhaW5lciB8IEltYWdlLFxuICAgIG1heEZvcm1hdD86IHN0cmluZ1xuICApOiBzdHJpbmcge1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gT25seSBjcmVhdGUgc3Jjc2V0IGltYWdlcyB0aGF0IGFyZSBzbWFsbGVyIHRoYW4gdGhlIGdpdmVuIGBtYXhGb3JtYXRgIChpZiBhbnkpXG4gICAgbGV0IGZvcm1hdHMgPSB0aGlzLnNvcnRlZEZvcm1hdHM7XG4gICAgY29uc3QgbWF4OiBudW1iZXIgPSBmb3JtYXRzLmZpbmRJbmRleCgoZikgPT4gZi5jb2RlID09PSBtYXhGb3JtYXQpO1xuICAgIGlmIChtYXggPiAtMSkge1xuICAgICAgZm9ybWF0cyA9IGZvcm1hdHMuc2xpY2UoMCwgbWF4ICsgMSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3Jjc2V0ID0gZm9ybWF0cy5yZWR1Y2UoKHNldCwgZm9ybWF0KSA9PiB7XG4gICAgICBpZiAoISFtZWRpYVtmb3JtYXQuY29kZV0pIHtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgIHNldCArPSAnLCAnO1xuICAgICAgICB9XG4gICAgICAgIHNldCArPSBgJHt0aGlzLnJlc29sdmVBYnNvbHV0ZVVybChtZWRpYVtmb3JtYXQuY29kZV0udXJsKX0gJHtcbiAgICAgICAgICBmb3JtYXQuc2l6ZS53aWR0aFxuICAgICAgICB9d2A7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0O1xuICAgIH0sICcnKTtcblxuICAgIHJldHVybiBzcmNzZXQgPT09ICcnID8gdW5kZWZpbmVkIDogc3Jjc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBhYnNvbHV0ZSBVUkwgZm9yIHRoZSBnaXZlbiB1cmwuIEluIG1vc3QgY2FzZXMsIHRoaXMgVVJMIHJlcHJlc2VudHNcbiAgICogdGhlIHJlbGF0aXZlIFVSTCBvbiB0aGUgYmFja2VuZC4gSW4gdGhhdCBjYXNlLCB3ZSBwcmVmaXggdGhlIHVybCB3aXRoIHRoZSBiYXNlVXJsLlxuICAgKlxuICAgKiBXaGVuIHdlIGhhdmUgcmVjZWl2ZSBhbiBhYnNvbHV0ZSBVUkwsIHdlIHJldHVybiB0aGUgVVJMIGFzLWlzLiBBbiBhYnNvbHV0ZSBVUkwgbWlnaHQgYWxzb1xuICAgKiBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaCwgd2hpY2ggaXMgdXNlZCB0byByZXNvbHZlIG1lZGlhIGNyb3NzIGZyb20gaHR0cCBhbmQgaHR0cHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVzb2x2ZUFic29sdXRlVXJsKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gIXVybCB8fCB1cmwuc3RhcnRzV2l0aCgnaHR0cCcpIHx8IHVybC5zdGFydHNXaXRoKCcvLycpXG4gICAgICA/IHVybFxuICAgICAgOiB0aGlzLmdldEJhc2VVcmwoKSArIHVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBVUkwgaXMgZWl0aGVyIGRyaXZlbiBieSBhIHNwZWNpZmljIGBiYWNrZW5kLm1lZGlhLmJhc2VVcmxgLCBvciBieSB0aGVcbiAgICogYGJhY2tlbmQub2NjLmJhc2VVcmxgLlxuICAgKlxuICAgKiBUaGUgYGJhY2tlbmQubWVkaWEuYmFzZVVybGAgY2FuIGJlIHVzZWQgdG8gbG9hZCBtZWRpYSBmcm9tIGEgZGlmZmVyZW50IGxvY2F0aW9uLlxuICAgKlxuICAgKiBJbiBDb21tZXJjZSBDbG91ZCwgYSBkaWZmZXJlbnQgbG9jYXRpb24gY291bGQgbWVhbiBhIGRpZmZlcmVudCBcImFzcGVjdFwiLlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmcgaW4gY2FzZSBubyBjb25maWcgaXMgcHJvdmlkZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0QmFzZVVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAoXG4gICAgICAodGhpcy5jb25maWcgYXMgT2NjQ29uZmlnKS5iYWNrZW5kPy5tZWRpYT8uYmFzZVVybCA/P1xuICAgICAgKHRoaXMuY29uZmlnIGFzIE9jY0NvbmZpZykuYmFja2VuZD8ub2NjPy5iYXNlVXJsID8/XG4gICAgICAnJ1xuICAgICk7XG4gIH1cbn1cbiJdfQ==