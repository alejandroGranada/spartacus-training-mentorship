import { Injectable, isDevMode } from '@angular/core';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import { BreakpointService } from '../../../layout/breakpoint/breakpoint.service';
import { TableConfig, } from './config/table.config';
import * as i0 from "@angular/core";
import * as i1 from "../../../layout/breakpoint/breakpoint.service";
import * as i2 from "./config/table.config";
/**
 * Responsive table service.
 *
 * The `TableService` is used to build a `TableStructure` by configuration. The configuration
 * allows for breakpoint specific configuration, so that the table can differentiate for
 * various screen sizes.
 *
 * While there are some global options, the configuration is mainly driven by the table _type_.
 *
 * If there is no table configuration for the given type found, a table header structure
 * is generated based on the actual data (if available) or randomly by generating 5 random headers.
 */
export class TableService {
    constructor(breakpointService, config) {
        this.breakpointService = breakpointService;
        this.config = config;
    }
    /**
     * Builds the table structure.
     *
     * @param tableType The table type is used  to find the specific table configuration.
     * @param defaultStructure (optional) Default table structure that contains fallback options. More specific options are merged with the default structure.
     * @param data$ (optional) The actual data can be passed in to generate the table structure based on actual data.
     */
    buildStructure(tableType, defaultStructure) {
        if (this.hasTableConfig(tableType)) {
            return this.buildStructureFromConfig(tableType, defaultStructure);
        }
        else {
            return this.buildRandomStructure(tableType);
        }
    }
    /**
     * Returns the table structure by configuration. The configuration can be
     * breakpoint-driven, which means that an alternative header structure can
     * be created per screen size.
     *
     * The breakpoint is resolved by teh `BreakpointService`.
     */
    buildStructureFromConfig(type, defaultStructure) {
        return this.breakpointService.breakpoint$.pipe(map((breakpoint) => (Object.assign(Object.assign({}, this.getTableConfig(type, breakpoint, defaultStructure)), { type }))));
    }
    /**
     * Finds all applicable table configuration for the given type and breakpoint.
     * The default table configuration is merged with all relevant breakpoint
     * configurations.
     *
     * This allows to have some default configurations that apply to all screens, and
     * add configuration options for some screens.
     */
    getTableConfig(type, breakpoint, defaultStructure) {
        var _a, _b;
        if (!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[type])) {
            return null;
        }
        const relevant = this.findRelevantBreakpoints(breakpoint);
        const closestBreakpoint = [...relevant]
            .reverse()
            .find((br) => { var _a; return !!((_a = this.config.table[type][br]) === null || _a === void 0 ? void 0 : _a.cells); });
        const cells = ((_b = this.config.table[type][closestBreakpoint]) === null || _b === void 0 ? void 0 : _b.cells) ||
            this.config.table[type].cells || (defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.cells);
        // add all default table configurations
        let options = Object.assign(Object.assign({}, defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure.options), this.config.table[type].options);
        // We merge all table options for smaller breakpoints into the global
        // options, so we inherit options.
        relevant.forEach((br) => {
            var _a, _b, _c;
            options = Object.assign(Object.assign(Object.assign({}, options), (_a = defaultStructure === null || defaultStructure === void 0 ? void 0 : defaultStructure[br]) === null || _a === void 0 ? void 0 : _a.options), (_c = (_b = this.config.table[type]) === null || _b === void 0 ? void 0 : _b[br]) === null || _c === void 0 ? void 0 : _c.options);
        });
        return { cells, options };
    }
    /**
     * Generates the table structure by the help of the first data row.
     */
    buildStructureFromData(type, data$) {
        this.logWarning(`No table configuration found to render table with type "${type}". The table header for "${type}" is generated by the help of the first data item`);
        return data$.pipe(map((data) => {
            const cells = Object.keys(data === null || data === void 0 ? void 0 : data[0]).map((key) => key);
            return { type, cells };
        }));
    }
    /**
     * As a last resort, the table structure is randomly created. The random structure
     * contains 5 headers, so that some of the unknown data is visualized.
     */
    buildRandomStructure(type) {
        this.logWarning(`No data available for "${type}", a random structure is generated (with hidden table headers).`);
        return of({
            type,
            cells: ['unknown', 'unknown', 'unknown', 'unknown', 'unknown'],
        });
    }
    /**
     * Finds all the breakpoints can contribute to the table configuration, from small
     * to current.
     *
     * For example, if the current breakpoint is `MD`, this returns `[XS, SM, MD]`.
     */
    findRelevantBreakpoints(breakpoint) {
        const current = this.breakpointService.breakpoints.indexOf(breakpoint);
        return this.breakpointService.breakpoints.slice(0, current + 1);
    }
    /**
     * Indicates if the there is a configuration for the table available.
     */
    hasTableConfig(tableType) {
        var _a;
        return !!((_a = this.config.table) === null || _a === void 0 ? void 0 : _a[tableType]);
    }
    /**
     * Logs a message in the console to increase developer experience.
     *
     * The message is only logged in dev mode.
     */
    logWarning(message) {
        if (isDevMode()) {
            console.warn(message);
        }
    }
}
TableService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TableService_Factory() { return new TableService(i0.ɵɵinject(i1.BreakpointService), i0.ɵɵinject(i2.TableConfig)); }, token: TableService, providedIn: "root" });
TableService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
TableService.ctorParameters = () => [
    { type: BreakpointService },
    { type: TableConfig }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvc3RvcmVmcm9udGxpYi9zcmMvIiwic291cmNlcyI6WyJzaGFyZWQvY29tcG9uZW50cy90YWJsZS90YWJsZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLCtDQUErQyxDQUFDO0FBRWxGLE9BQU8sRUFFTCxXQUFXLEdBQ1osTUFBTSx1QkFBdUIsQ0FBQzs7OztBQUcvQjs7Ozs7Ozs7Ozs7R0FXRztBQUlILE1BQU0sT0FBTyxZQUFZO0lBQ3ZCLFlBQ1ksaUJBQW9DLEVBQ3BDLE1BQW1CO1FBRG5CLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFDcEMsV0FBTSxHQUFOLE1BQU0sQ0FBYTtJQUM1QixDQUFDO0lBRUo7Ozs7OztPQU1HO0lBQ0gsY0FBYyxDQUNaLFNBQWlCLEVBQ2pCLGdCQUErQztRQUUvQyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDbEMsT0FBTyxJQUFJLENBQUMsd0JBQXdCLENBQUMsU0FBUyxFQUFFLGdCQUFnQixDQUFDLENBQUM7U0FDbkU7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzdDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLHdCQUF3QixDQUNoQyxJQUFZLEVBQ1osZ0JBQStDO1FBRS9DLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQzVDLEdBQUcsQ0FB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QztJQUVEOzs7OztPQUtHO0lBQ08sdUJBQXVCLENBQUMsVUFBc0I7UUFDdEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdkUsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRDs7T0FFRztJQUNPLGNBQWMsQ0FBQyxTQUFpQjs7UUFDeEMsT0FBTyxDQUFDLFFBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLDBDQUFHLFNBQVMsRUFBQyxDQUFDO0lBQzFDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssVUFBVSxDQUFDLE9BQU87UUFDeEIsSUFBSSxTQUFTLEVBQUUsRUFBRTtZQUNmLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDdkI7SUFDSCxDQUFDOzs7O1lBdkpGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O1lBdEJRLGlCQUFpQjtZQUl4QixXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgaXNEZXZNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQnJlYWtwb2ludFNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9sYXlvdXQvYnJlYWtwb2ludC9icmVha3BvaW50LnNlcnZpY2UnO1xuaW1wb3J0IHsgQlJFQUtQT0lOVCB9IGZyb20gJy4uLy4uLy4uL2xheW91dC9jb25maWcvbGF5b3V0LWNvbmZpZyc7XG5pbXBvcnQge1xuICBSZXNwb25zaXZlVGFibGVDb25maWd1cmF0aW9uLFxuICBUYWJsZUNvbmZpZyxcbn0gZnJvbSAnLi9jb25maWcvdGFibGUuY29uZmlnJztcbmltcG9ydCB7IFRhYmxlU3RydWN0dXJlLCBUYWJsZVN0cnVjdHVyZUNvbmZpZ3VyYXRpb24gfSBmcm9tICcuL3RhYmxlLm1vZGVsJztcblxuLyoqXG4gKiBSZXNwb25zaXZlIHRhYmxlIHNlcnZpY2UuXG4gKlxuICogVGhlIGBUYWJsZVNlcnZpY2VgIGlzIHVzZWQgdG8gYnVpbGQgYSBgVGFibGVTdHJ1Y3R1cmVgIGJ5IGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uXG4gKiBhbGxvd3MgZm9yIGJyZWFrcG9pbnQgc3BlY2lmaWMgY29uZmlndXJhdGlvbiwgc28gdGhhdCB0aGUgdGFibGUgY2FuIGRpZmZlcmVudGlhdGUgZm9yXG4gKiB2YXJpb3VzIHNjcmVlbiBzaXplcy5cbiAqXG4gKiBXaGlsZSB0aGVyZSBhcmUgc29tZSBnbG9iYWwgb3B0aW9ucywgdGhlIGNvbmZpZ3VyYXRpb24gaXMgbWFpbmx5IGRyaXZlbiBieSB0aGUgdGFibGUgX3R5cGVfLlxuICpcbiAqIElmIHRoZXJlIGlzIG5vIHRhYmxlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBnaXZlbiB0eXBlIGZvdW5kLCBhIHRhYmxlIGhlYWRlciBzdHJ1Y3R1cmVcbiAqIGlzIGdlbmVyYXRlZCBiYXNlZCBvbiB0aGUgYWN0dWFsIGRhdGEgKGlmIGF2YWlsYWJsZSkgb3IgcmFuZG9tbHkgYnkgZ2VuZXJhdGluZyA1IHJhbmRvbSBoZWFkZXJzLlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgVGFibGVTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGJyZWFrcG9pbnRTZXJ2aWNlOiBCcmVha3BvaW50U2VydmljZSxcbiAgICBwcm90ZWN0ZWQgY29uZmlnOiBUYWJsZUNvbmZpZ1xuICApIHt9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgdGFibGUgc3RydWN0dXJlLlxuICAgKlxuICAgKiBAcGFyYW0gdGFibGVUeXBlIFRoZSB0YWJsZSB0eXBlIGlzIHVzZWQgIHRvIGZpbmQgdGhlIHNwZWNpZmljIHRhYmxlIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSBkZWZhdWx0U3RydWN0dXJlIChvcHRpb25hbCkgRGVmYXVsdCB0YWJsZSBzdHJ1Y3R1cmUgdGhhdCBjb250YWlucyBmYWxsYmFjayBvcHRpb25zLiBNb3JlIHNwZWNpZmljIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0IHN0cnVjdHVyZS5cbiAgICogQHBhcmFtIGRhdGEkIChvcHRpb25hbCkgVGhlIGFjdHVhbCBkYXRhIGNhbiBiZSBwYXNzZWQgaW4gdG8gZ2VuZXJhdGUgdGhlIHRhYmxlIHN0cnVjdHVyZSBiYXNlZCBvbiBhY3R1YWwgZGF0YS5cbiAgICovXG4gIGJ1aWxkU3RydWN0dXJlKFxuICAgIHRhYmxlVHlwZTogc3RyaW5nLFxuICAgIGRlZmF1bHRTdHJ1Y3R1cmU/OiBSZXNwb25zaXZlVGFibGVDb25maWd1cmF0aW9uXG4gICk6IE9ic2VydmFibGU8VGFibGVTdHJ1Y3R1cmU+IHtcbiAgICBpZiAodGhpcy5oYXNUYWJsZUNvbmZpZyh0YWJsZVR5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5idWlsZFN0cnVjdHVyZUZyb21Db25maWcodGFibGVUeXBlLCBkZWZhdWx0U3RydWN0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbGRSYW5kb21TdHJ1Y3R1cmUodGFibGVUeXBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFibGUgc3RydWN0dXJlIGJ5IGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIGNhbiBiZVxuICAgKiBicmVha3BvaW50LWRyaXZlbiwgd2hpY2ggbWVhbnMgdGhhdCBhbiBhbHRlcm5hdGl2ZSBoZWFkZXIgc3RydWN0dXJlIGNhblxuICAgKiBiZSBjcmVhdGVkIHBlciBzY3JlZW4gc2l6ZS5cbiAgICpcbiAgICogVGhlIGJyZWFrcG9pbnQgaXMgcmVzb2x2ZWQgYnkgdGVoIGBCcmVha3BvaW50U2VydmljZWAuXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRTdHJ1Y3R1cmVGcm9tQ29uZmlnKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBkZWZhdWx0U3RydWN0dXJlPzogUmVzcG9uc2l2ZVRhYmxlQ29uZmlndXJhdGlvblxuICApOiBPYnNlcnZhYmxlPFRhYmxlU3RydWN0dXJlPiB7XG4gICAgcmV0dXJuIHRoaXMuYnJlYWtwb2ludFNlcnZpY2UuYnJlYWtwb2ludCQucGlwZShcbiAgICAgIG1hcCgoYnJlYWtwb2ludCkgPT4gKHtcbiAgICAgICAgLi4udGhpcy5nZXRUYWJsZUNvbmZpZyh0eXBlLCBicmVha3BvaW50LCBkZWZhdWx0U3RydWN0dXJlKSxcbiAgICAgICAgdHlwZSxcbiAgICAgIH0pKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYWxsIGFwcGxpY2FibGUgdGFibGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIGJyZWFrcG9pbnQuXG4gICAqIFRoZSBkZWZhdWx0IHRhYmxlIGNvbmZpZ3VyYXRpb24gaXMgbWVyZ2VkIHdpdGggYWxsIHJlbGV2YW50IGJyZWFrcG9pbnRcbiAgICogY29uZmlndXJhdGlvbnMuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHRvIGhhdmUgc29tZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb25zIHRoYXQgYXBwbHkgdG8gYWxsIHNjcmVlbnMsIGFuZFxuICAgKiBhZGQgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBzb21lIHNjcmVlbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VGFibGVDb25maWcoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGJyZWFrcG9pbnQ6IEJSRUFLUE9JTlQsXG4gICAgZGVmYXVsdFN0cnVjdHVyZT86IFJlc3BvbnNpdmVUYWJsZUNvbmZpZ3VyYXRpb25cbiAgKTogVGFibGVTdHJ1Y3R1cmVDb25maWd1cmF0aW9uIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLnRhYmxlPy5bdHlwZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbGV2YW50ID0gdGhpcy5maW5kUmVsZXZhbnRCcmVha3BvaW50cyhicmVha3BvaW50KTtcblxuICAgIGNvbnN0IGNsb3Nlc3RCcmVha3BvaW50ID0gWy4uLnJlbGV2YW50XVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmZpbmQoKGJyKSA9PiAhIXRoaXMuY29uZmlnLnRhYmxlW3R5cGVdW2JyXT8uY2VsbHMpO1xuICAgIGNvbnN0IGNlbGxzID1cbiAgICAgIHRoaXMuY29uZmlnLnRhYmxlW3R5cGVdW2Nsb3Nlc3RCcmVha3BvaW50XT8uY2VsbHMgfHxcbiAgICAgIHRoaXMuY29uZmlnLnRhYmxlW3R5cGVdLmNlbGxzIHx8XG4gICAgICBkZWZhdWx0U3RydWN0dXJlPy5jZWxscztcblxuICAgIC8vIGFkZCBhbGwgZGVmYXVsdCB0YWJsZSBjb25maWd1cmF0aW9uc1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgLi4uZGVmYXVsdFN0cnVjdHVyZT8ub3B0aW9ucyxcbiAgICAgIC4uLnRoaXMuY29uZmlnLnRhYmxlW3R5cGVdLm9wdGlvbnMsXG4gICAgfTtcblxuICAgIC8vIFdlIG1lcmdlIGFsbCB0YWJsZSBvcHRpb25zIGZvciBzbWFsbGVyIGJyZWFrcG9pbnRzIGludG8gdGhlIGdsb2JhbFxuICAgIC8vIG9wdGlvbnMsIHNvIHdlIGluaGVyaXQgb3B0aW9ucy5cbiAgICByZWxldmFudC5mb3JFYWNoKChicikgPT4ge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4uZGVmYXVsdFN0cnVjdHVyZT8uW2JyXT8ub3B0aW9ucyxcbiAgICAgICAgLi4udGhpcy5jb25maWcudGFibGVbdHlwZV0/Llticl0/Lm9wdGlvbnMsXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgY2VsbHMsIG9wdGlvbnMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHRhYmxlIHN0cnVjdHVyZSBieSB0aGUgaGVscCBvZiB0aGUgZmlyc3QgZGF0YSByb3cuXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRTdHJ1Y3R1cmVGcm9tRGF0YShcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgZGF0YSQ6IE9ic2VydmFibGU8YW55PlxuICApOiBPYnNlcnZhYmxlPFRhYmxlU3RydWN0dXJlPiB7XG4gICAgdGhpcy5sb2dXYXJuaW5nKFxuICAgICAgYE5vIHRhYmxlIGNvbmZpZ3VyYXRpb24gZm91bmQgdG8gcmVuZGVyIHRhYmxlIHdpdGggdHlwZSBcIiR7dHlwZX1cIi4gVGhlIHRhYmxlIGhlYWRlciBmb3IgXCIke3R5cGV9XCIgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBoZWxwIG9mIHRoZSBmaXJzdCBkYXRhIGl0ZW1gXG4gICAgKTtcbiAgICByZXR1cm4gZGF0YSQucGlwZShcbiAgICAgIG1hcCgoZGF0YTogYW55W10pID0+IHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSBPYmplY3Qua2V5cyhkYXRhPy5bMF0pLm1hcCgoa2V5KSA9PiBrZXkpO1xuICAgICAgICByZXR1cm4geyB0eXBlLCBjZWxscyB9IGFzIFRhYmxlU3RydWN0dXJlO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzIGEgbGFzdCByZXNvcnQsIHRoZSB0YWJsZSBzdHJ1Y3R1cmUgaXMgcmFuZG9tbHkgY3JlYXRlZC4gVGhlIHJhbmRvbSBzdHJ1Y3R1cmVcbiAgICogY29udGFpbnMgNSBoZWFkZXJzLCBzbyB0aGF0IHNvbWUgb2YgdGhlIHVua25vd24gZGF0YSBpcyB2aXN1YWxpemVkLlxuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkUmFuZG9tU3RydWN0dXJlKHR5cGU6IHN0cmluZyk6IE9ic2VydmFibGU8VGFibGVTdHJ1Y3R1cmU+IHtcbiAgICB0aGlzLmxvZ1dhcm5pbmcoXG4gICAgICBgTm8gZGF0YSBhdmFpbGFibGUgZm9yIFwiJHt0eXBlfVwiLCBhIHJhbmRvbSBzdHJ1Y3R1cmUgaXMgZ2VuZXJhdGVkICh3aXRoIGhpZGRlbiB0YWJsZSBoZWFkZXJzKS5gXG4gICAgKTtcbiAgICByZXR1cm4gb2Yoe1xuICAgICAgdHlwZSxcbiAgICAgIGNlbGxzOiBbJ3Vua25vd24nLCAndW5rbm93bicsICd1bmtub3duJywgJ3Vua25vd24nLCAndW5rbm93biddLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCB0aGUgYnJlYWtwb2ludHMgY2FuIGNvbnRyaWJ1dGUgdG8gdGhlIHRhYmxlIGNvbmZpZ3VyYXRpb24sIGZyb20gc21hbGxcbiAgICogdG8gY3VycmVudC5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgaXMgYE1EYCwgdGhpcyByZXR1cm5zIGBbWFMsIFNNLCBNRF1gLlxuICAgKi9cbiAgcHJvdGVjdGVkIGZpbmRSZWxldmFudEJyZWFrcG9pbnRzKGJyZWFrcG9pbnQ6IEJSRUFLUE9JTlQpOiBCUkVBS1BPSU5UW10ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmJyZWFrcG9pbnRTZXJ2aWNlLmJyZWFrcG9pbnRzLmluZGV4T2YoYnJlYWtwb2ludCk7XG4gICAgcmV0dXJuIHRoaXMuYnJlYWtwb2ludFNlcnZpY2UuYnJlYWtwb2ludHMuc2xpY2UoMCwgY3VycmVudCArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgdGhlcmUgaXMgYSBjb25maWd1cmF0aW9uIGZvciB0aGUgdGFibGUgYXZhaWxhYmxlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGhhc1RhYmxlQ29uZmlnKHRhYmxlVHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5jb25maWcudGFibGU/Llt0YWJsZVR5cGVdO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgYSBtZXNzYWdlIGluIHRoZSBjb25zb2xlIHRvIGluY3JlYXNlIGRldmVsb3BlciBleHBlcmllbmNlLlxuICAgKlxuICAgKiBUaGUgbWVzc2FnZSBpcyBvbmx5IGxvZ2dlZCBpbiBkZXYgbW9kZS5cbiAgICovXG4gIHByaXZhdGUgbG9nV2FybmluZyhtZXNzYWdlKSB7XG4gICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG4iXX0=