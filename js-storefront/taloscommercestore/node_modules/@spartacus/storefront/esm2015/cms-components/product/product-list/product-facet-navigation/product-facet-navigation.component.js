import { ChangeDetectionStrategy, Component, ViewChild, } from '@angular/core';
import { asapScheduler, BehaviorSubject, interval, of } from 'rxjs';
import { delayWhen, observeOn, switchMap } from 'rxjs/operators';
import { ICON_TYPE } from '../../../../cms-components/misc/icon/icon.model';
import { BreakpointService } from '../../../../layout/breakpoint/breakpoint.service';
export class ProductFacetNavigationComponent {
    constructor(breakpointService) {
        this.breakpointService = breakpointService;
        this.iconTypes = ICON_TYPE;
        /**
         * We delay the removal of DOM so that animations can finish playing before the
         * DOM is removed. Removing the DOM, as hidding is not enough to stop elements
         * to be focused.
         */
        this.CLOSE_DELAY = 300;
        this.open$ = new BehaviorSubject(false);
        /**
         * Emits the open state that indicates whether the facet list should be rendered.
         * This is either done instantly, or after the user triggers this by using the trigger
         * button. This driven by the visiibility of the trigger, so that the CSS drives
         * the behaviour. This can differ per breakpoint.
         *
         * There's a configurable delay for the closed state, so that the DOM is not removed
         * before some CSS animations are done.
         */
        this.isOpen$ = this.breakpointService.breakpoint$.pipe(
        // deffer emitting a new value to the next micro-task to ensure that the `hasTrigger`
        // method represents the actual UI state.
        observeOn(asapScheduler), switchMap(() => (this.hasTrigger ? this.open$ : of(true))), delayWhen((launched) => interval(launched ? 0 : this.CLOSE_DELAY)));
        /**
         * Emits the active state that indicates whether the facet list is activated. Activation
         * is related to the css, so that a animation or transition can visualize opening/closing
         * the list (i.e. dialog).
         */
        this.isActive$ = this.open$.pipe(
        // deffer emitting a new value to the next micro-task to ensure the active class is
        //  applied after the DOM is created
        observeOn(asapScheduler));
    }
    launch() {
        this.open$.next(true);
    }
    close() {
        this.open$.next(false);
        this.trigger.nativeElement.focus();
    }
    /**
     * Indicates that the facet navigation should be open explicitely by a trigger.
     * This is fully controlled by CSS, where the trigger button can be hidden
     * (display:none) for certain screen sizes.
     */
    get hasTrigger() {
        return this.trigger.nativeElement.offsetParent !== null;
    }
}
ProductFacetNavigationComponent.decorators = [
    { type: Component, args: [{
                selector: 'cx-product-facet-navigation',
                template: "<button\n  #trigger\n  class=\"btn btn-action btn-block dialog-trigger\"\n  (click)=\"launch()\"\n>\n  <cx-icon [type]=\"iconTypes.FILTER\"></cx-icon>\n  {{ 'productList.filterBy.label' | cxTranslate }}\n</button>\n\n<cx-active-facets></cx-active-facets>\n\n<cx-facet-list\n  *ngIf=\"isOpen$ | async\"\n  [isDialog]=\"hasTrigger\"\n  (closeList)=\"close()\"\n  [class.active]=\"isActive$ | async\"\n  [class.dialog]=\"hasTrigger\"\n></cx-facet-list>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
ProductFacetNavigationComponent.ctorParameters = () => [
    { type: BreakpointService }
];
ProductFacetNavigationComponent.propDecorators = {
    trigger: [{ type: ViewChild, args: ['trigger',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZHVjdC1mYWNldC1uYXZpZ2F0aW9uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvc3RvcmVmcm9udGxpYi9zcmMvIiwic291cmNlcyI6WyJjbXMtY29tcG9uZW50cy9wcm9kdWN0L3Byb2R1Y3QtbGlzdC9wcm9kdWN0LWZhY2V0LW5hdmlnYXRpb24vcHJvZHVjdC1mYWNldC1uYXZpZ2F0aW9uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFFVCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNoRixPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNqRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0saURBQWlELENBQUM7QUFDNUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sa0RBQWtELENBQUM7QUFPckYsTUFBTSxPQUFPLCtCQUErQjtJQWdEMUMsWUFBc0IsaUJBQW9DO1FBQXBDLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUEvQzFELGNBQVMsR0FBRyxTQUFTLENBQUM7UUFFdEI7Ozs7V0FJRztRQUNPLGdCQUFXLEdBQUcsR0FBRyxDQUFDO1FBVWxCLFVBQUssR0FBRyxJQUFJLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU3Qzs7Ozs7Ozs7V0FRRztRQUNILFlBQU8sR0FBd0IsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxJQUFJO1FBQ3BFLHFGQUFxRjtRQUNyRix5Q0FBeUM7UUFDekMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxFQUN4QixTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUMxRCxTQUFTLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQ25FLENBQUM7UUFFRjs7OztXQUlHO1FBQ0gsY0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSTtRQUN6QixtRkFBbUY7UUFDbkYsb0NBQW9DO1FBQ3BDLFNBQVMsQ0FBQyxhQUFhLENBQUMsQ0FDekIsQ0FBQztJQUUyRCxDQUFDO0lBRTlELE1BQU07UUFDSixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQsS0FBSztRQUNILElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBSSxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxZQUFZLEtBQUssSUFBSSxDQUFDO0lBQzFELENBQUM7OztZQXZFRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLDZCQUE2QjtnQkFDdkMsK2NBQXdEO2dCQUN4RCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTthQUNoRDs7O1lBTlEsaUJBQWlCOzs7c0JBdUJ2QixTQUFTLFNBQUMsU0FBUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhc2FwU2NoZWR1bGVyLCBCZWhhdmlvclN1YmplY3QsIGludGVydmFsLCBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGVsYXlXaGVuLCBvYnNlcnZlT24sIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElDT05fVFlQRSB9IGZyb20gJy4uLy4uLy4uLy4uL2Ntcy1jb21wb25lbnRzL21pc2MvaWNvbi9pY29uLm1vZGVsJztcbmltcG9ydCB7IEJyZWFrcG9pbnRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGF5b3V0L2JyZWFrcG9pbnQvYnJlYWtwb2ludC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY3gtcHJvZHVjdC1mYWNldC1uYXZpZ2F0aW9uJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3Byb2R1Y3QtZmFjZXQtbmF2aWdhdGlvbi5jb21wb25lbnQuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBQcm9kdWN0RmFjZXROYXZpZ2F0aW9uQ29tcG9uZW50IHtcbiAgaWNvblR5cGVzID0gSUNPTl9UWVBFO1xuXG4gIC8qKlxuICAgKiBXZSBkZWxheSB0aGUgcmVtb3ZhbCBvZiBET00gc28gdGhhdCBhbmltYXRpb25zIGNhbiBmaW5pc2ggcGxheWluZyBiZWZvcmUgdGhlXG4gICAqIERPTSBpcyByZW1vdmVkLiBSZW1vdmluZyB0aGUgRE9NLCBhcyBoaWRkaW5nIGlzIG5vdCBlbm91Z2ggdG8gc3RvcCBlbGVtZW50c1xuICAgKiB0byBiZSBmb2N1c2VkLlxuICAgKi9cbiAgcHJvdGVjdGVkIENMT1NFX0RFTEFZID0gMzAwO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG9wZW4gdGhlIGZhY2V0IG5hdmlnYXRpb24gaW4gYSBkaWFsb2cuIFRoZSB1c2FnZSBvZiB0aGUgZGlhbG9nIGRlcGVuZHNcbiAgICogb24gdGhlIGF2YWlsYWJpbGl0eSBvZiB0aGUgdHJpZ2dlciBlbGVtZW50LCB3aGljaCBpcyBkcml2ZW4gYnkgQ1NTLlxuICAgKlxuICAgKiBUaGUgcmVmZXJlbmNlIGlzIGFsc28gdXNlZCB0byByZWZvY3VzIHRoZSB0cmlnZ2VyIGFmdGVyIHRoZSBkaWFsb2cgaXMgY2xvc2VkLlxuICAgKi9cbiAgQFZpZXdDaGlsZCgndHJpZ2dlcicpIHRyaWdnZXI6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gIHByb3RlY3RlZCBvcGVuJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgb3BlbiBzdGF0ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBmYWNldCBsaXN0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICogVGhpcyBpcyBlaXRoZXIgZG9uZSBpbnN0YW50bHksIG9yIGFmdGVyIHRoZSB1c2VyIHRyaWdnZXJzIHRoaXMgYnkgdXNpbmcgdGhlIHRyaWdnZXJcbiAgICogYnV0dG9uLiBUaGlzIGRyaXZlbiBieSB0aGUgdmlzaWliaWxpdHkgb2YgdGhlIHRyaWdnZXIsIHNvIHRoYXQgdGhlIENTUyBkcml2ZXNcbiAgICogdGhlIGJlaGF2aW91ci4gVGhpcyBjYW4gZGlmZmVyIHBlciBicmVha3BvaW50LlxuICAgKlxuICAgKiBUaGVyZSdzIGEgY29uZmlndXJhYmxlIGRlbGF5IGZvciB0aGUgY2xvc2VkIHN0YXRlLCBzbyB0aGF0IHRoZSBET00gaXMgbm90IHJlbW92ZWRcbiAgICogYmVmb3JlIHNvbWUgQ1NTIGFuaW1hdGlvbnMgYXJlIGRvbmUuXG4gICAqL1xuICBpc09wZW4kOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5icmVha3BvaW50U2VydmljZS5icmVha3BvaW50JC5waXBlKFxuICAgIC8vIGRlZmZlciBlbWl0dGluZyBhIG5ldyB2YWx1ZSB0byB0aGUgbmV4dCBtaWNyby10YXNrIHRvIGVuc3VyZSB0aGF0IHRoZSBgaGFzVHJpZ2dlcmBcbiAgICAvLyBtZXRob2QgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFVJIHN0YXRlLlxuICAgIG9ic2VydmVPbihhc2FwU2NoZWR1bGVyKSxcbiAgICBzd2l0Y2hNYXAoKCkgPT4gKHRoaXMuaGFzVHJpZ2dlciA/IHRoaXMub3BlbiQgOiBvZih0cnVlKSkpLFxuICAgIGRlbGF5V2hlbigobGF1bmNoZWQpID0+IGludGVydmFsKGxhdW5jaGVkID8gMCA6IHRoaXMuQ0xPU0VfREVMQVkpKVxuICApO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB0aGUgYWN0aXZlIHN0YXRlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGZhY2V0IGxpc3QgaXMgYWN0aXZhdGVkLiBBY3RpdmF0aW9uXG4gICAqIGlzIHJlbGF0ZWQgdG8gdGhlIGNzcywgc28gdGhhdCBhIGFuaW1hdGlvbiBvciB0cmFuc2l0aW9uIGNhbiB2aXN1YWxpemUgb3BlbmluZy9jbG9zaW5nXG4gICAqIHRoZSBsaXN0IChpLmUuIGRpYWxvZykuXG4gICAqL1xuICBpc0FjdGl2ZSQgPSB0aGlzLm9wZW4kLnBpcGUoXG4gICAgLy8gZGVmZmVyIGVtaXR0aW5nIGEgbmV3IHZhbHVlIHRvIHRoZSBuZXh0IG1pY3JvLXRhc2sgdG8gZW5zdXJlIHRoZSBhY3RpdmUgY2xhc3MgaXNcbiAgICAvLyAgYXBwbGllZCBhZnRlciB0aGUgRE9NIGlzIGNyZWF0ZWRcbiAgICBvYnNlcnZlT24oYXNhcFNjaGVkdWxlcilcbiAgKTtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgYnJlYWtwb2ludFNlcnZpY2U6IEJyZWFrcG9pbnRTZXJ2aWNlKSB7fVxuXG4gIGxhdW5jaCgpIHtcbiAgICB0aGlzLm9wZW4kLm5leHQodHJ1ZSk7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLm9wZW4kLm5leHQoZmFsc2UpO1xuICAgIHRoaXMudHJpZ2dlci5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGZhY2V0IG5hdmlnYXRpb24gc2hvdWxkIGJlIG9wZW4gZXhwbGljaXRlbHkgYnkgYSB0cmlnZ2VyLlxuICAgKiBUaGlzIGlzIGZ1bGx5IGNvbnRyb2xsZWQgYnkgQ1NTLCB3aGVyZSB0aGUgdHJpZ2dlciBidXR0b24gY2FuIGJlIGhpZGRlblxuICAgKiAoZGlzcGxheTpub25lKSBmb3IgY2VydGFpbiBzY3JlZW4gc2l6ZXMuXG4gICAqL1xuICBnZXQgaGFzVHJpZ2dlcigpIHtcbiAgICByZXR1cm4gdGhpcy50cmlnZ2VyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0UGFyZW50ICE9PSBudWxsO1xuICB9XG59XG4iXX0=