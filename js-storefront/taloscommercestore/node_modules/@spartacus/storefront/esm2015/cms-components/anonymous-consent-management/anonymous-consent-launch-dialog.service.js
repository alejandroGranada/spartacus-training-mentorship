import { Injectable } from '@angular/core';
import { combineLatest } from 'rxjs';
import { filter, map, tap } from 'rxjs/operators';
import { LaunchDialogService, } from '../../layout/launch-dialog/index';
import * as i0 from "@angular/core";
import * as i1 from "../../layout/launch-dialog/services/launch-dialog.service";
// TODO(#12167): deprecations cleanup
/**
 * @deprecated since 3.3 - use `LaunchDialogService` instead
 */
export class AnonymousConsentLaunchDialogService {
    constructor(launchDialogService) {
        this.launchDialogService = launchDialogService;
    }
    /**
     * @deprecated since 3.3 - use `LaunchDialogService.openDialog` with LAUNCH_CALLER.ANONYMOUS_CONSENT instead
     */
    openDialog(openElement, vcr) {
        const component = this.launchDialogService.launch("ANONYMOUS_CONSENT" /* ANONYMOUS_CONSENT */, vcr);
        if (component) {
            return combineLatest([
                component,
                this.launchDialogService.dialogClose,
            ]).pipe(filter(([, close]) => close && close !== undefined), tap(([comp]) => {
                openElement === null || openElement === void 0 ? void 0 : openElement.nativeElement.focus();
                this.launchDialogService.clear("ANONYMOUS_CONSENT" /* ANONYMOUS_CONSENT */);
                comp.destroy();
            }), map(([comp]) => comp));
        }
    }
}
AnonymousConsentLaunchDialogService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AnonymousConsentLaunchDialogService_Factory() { return new AnonymousConsentLaunchDialogService(i0.ɵɵinject(i1.LaunchDialogService)); }, token: AnonymousConsentLaunchDialogService, providedIn: "root" });
AnonymousConsentLaunchDialogService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
AnonymousConsentLaunchDialogService.ctorParameters = () => [
    { type: LaunchDialogService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5vbnltb3VzLWNvbnNlbnQtbGF1bmNoLWRpYWxvZy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL1BhdHJ5ay9EZXNrdG9wL3NwYXJ0YWN1cy9wcm9qZWN0cy9zdG9yZWZyb250bGliL3NyYy8iLCJzb3VyY2VzIjpbImNtcy1jb21wb25lbnRzL2Fub255bW91cy1jb25zZW50LW1hbmFnZW1lbnQvYW5vbnltb3VzLWNvbnNlbnQtbGF1bmNoLWRpYWxvZy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBYyxVQUFVLEVBQW9CLE1BQU0sZUFBZSxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxhQUFhLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDakQsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUNMLG1CQUFtQixHQUVwQixNQUFNLGtDQUFrQyxDQUFDOzs7QUFFMUMscUNBQXFDO0FBQ3JDOztHQUVHO0FBRUgsTUFBTSxPQUFPLG1DQUFtQztJQUM5QyxZQUFzQixtQkFBd0M7UUFBeEMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtJQUFHLENBQUM7SUFFbEU7O09BRUc7SUFDSCxVQUFVLENBQ1IsV0FBd0IsRUFDeEIsR0FBc0I7UUFFdEIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sOENBRS9DLEdBQUcsQ0FDSixDQUFDO1FBRUYsSUFBSSxTQUFTLEVBQUU7WUFDYixPQUFPLGFBQWEsQ0FBQztnQkFDbkIsU0FBUztnQkFDVCxJQUFJLENBQUMsbUJBQW1CLENBQUMsV0FBVzthQUNyQyxDQUFDLENBQUMsSUFBSSxDQUNMLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxJQUFJLEtBQUssS0FBSyxTQUFTLENBQUMsRUFDbkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFO2dCQUNiLFdBQVcsYUFBWCxXQUFXLHVCQUFYLFdBQVcsQ0FBRSxhQUFhLENBQUMsS0FBSyxHQUFHO2dCQUNuQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyw2Q0FBaUMsQ0FBQztnQkFDaEUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2pCLENBQUMsQ0FBQyxFQUNGLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUN0QixDQUFDO1NBQ0g7SUFDSCxDQUFDOzs7O1lBOUJGLFVBQVUsU0FBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7OztZQVJoQyxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3RhYmxlLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgTGF1bmNoRGlhbG9nU2VydmljZSxcbiAgTEFVTkNIX0NBTExFUixcbn0gZnJvbSAnLi4vLi4vbGF5b3V0L2xhdW5jaC1kaWFsb2cvaW5kZXgnO1xuXG4vLyBUT0RPKCMxMjE2Nyk6IGRlcHJlY2F0aW9ucyBjbGVhbnVwXG4vKipcbiAqIEBkZXByZWNhdGVkIHNpbmNlIDMuMyAtIHVzZSBgTGF1bmNoRGlhbG9nU2VydmljZWAgaW5zdGVhZFxuICovXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEFub255bW91c0NvbnNlbnRMYXVuY2hEaWFsb2dTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGxhdW5jaERpYWxvZ1NlcnZpY2U6IExhdW5jaERpYWxvZ1NlcnZpY2UpIHt9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIDMuMyAtIHVzZSBgTGF1bmNoRGlhbG9nU2VydmljZS5vcGVuRGlhbG9nYCB3aXRoIExBVU5DSF9DQUxMRVIuQU5PTllNT1VTX0NPTlNFTlQgaW5zdGVhZFxuICAgKi9cbiAgb3BlbkRpYWxvZyhcbiAgICBvcGVuRWxlbWVudD86IEVsZW1lbnRSZWYsXG4gICAgdmNyPzogVmlld0NvbnRhaW5lclJlZlxuICApOiBPYnNlcnZhYmxlPGFueT4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMubGF1bmNoRGlhbG9nU2VydmljZS5sYXVuY2goXG4gICAgICBMQVVOQ0hfQ0FMTEVSLkFOT05ZTU9VU19DT05TRU5ULFxuICAgICAgdmNyXG4gICAgKTtcblxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KFtcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICB0aGlzLmxhdW5jaERpYWxvZ1NlcnZpY2UuZGlhbG9nQ2xvc2UsXG4gICAgICBdKS5waXBlKFxuICAgICAgICBmaWx0ZXIoKFssIGNsb3NlXSkgPT4gY2xvc2UgJiYgY2xvc2UgIT09IHVuZGVmaW5lZCksXG4gICAgICAgIHRhcCgoW2NvbXBdKSA9PiB7XG4gICAgICAgICAgb3BlbkVsZW1lbnQ/Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB0aGlzLmxhdW5jaERpYWxvZ1NlcnZpY2UuY2xlYXIoTEFVTkNIX0NBTExFUi5BTk9OWU1PVVNfQ09OU0VOVCk7XG4gICAgICAgICAgY29tcC5kZXN0cm95KCk7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoKFtjb21wXSkgPT4gY29tcClcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXX0=