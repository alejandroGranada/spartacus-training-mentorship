import { Injectable } from '@angular/core';
import { RoutingService, UserReplenishmentOrderService, } from '@spartacus/core';
import { distinctUntilChanged, map, shareReplay, switchMap, tap, } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
export class ReplenishmentOrderDetailsService {
    constructor(routingService, userReplenishmentOrderService) {
        this.routingService = routingService;
        this.userReplenishmentOrderService = userReplenishmentOrderService;
        this.replenishmentOrderCode$ = this.routingService.getRouterState().pipe(map((routingData) => routingData.state.params.replenishmentOrderCode), distinctUntilChanged());
        this.replenishmentOrderLoad$ = this.replenishmentOrderCode$.pipe(tap((replenishmentOrderCode) => {
            if (Boolean(replenishmentOrderCode)) {
                this.userReplenishmentOrderService.loadReplenishmentOrderDetails(replenishmentOrderCode);
            }
            else {
                this.userReplenishmentOrderService.clearReplenishmentOrderDetails();
            }
        }), shareReplay({ bufferSize: 1, refCount: true }));
    }
    getOrderDetails() {
        return this.replenishmentOrderLoad$.pipe(switchMap((_) => this.userReplenishmentOrderService.getReplenishmentOrderDetails()));
    }
}
ReplenishmentOrderDetailsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ReplenishmentOrderDetailsService_Factory() { return new ReplenishmentOrderDetailsService(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.UserReplenishmentOrderService)); }, token: ReplenishmentOrderDetailsService, providedIn: "root" });
ReplenishmentOrderDetailsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
ReplenishmentOrderDetailsService.ctorParameters = () => [
    { type: RoutingService },
    { type: UserReplenishmentOrderService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVwbGVuaXNobWVudC1vcmRlci1kZXRhaWxzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiQzovVXNlcnMvUGF0cnlrL0Rlc2t0b3Avc3BhcnRhY3VzL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc3JjLyIsInNvdXJjZXMiOlsiY21zLWNvbXBvbmVudHMvbXlhY2NvdW50L29yZGVyL3JlcGxlbmlzaG1lbnQtb3JkZXItZGV0YWlscy9yZXBsZW5pc2htZW50LW9yZGVyLWRldGFpbHMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFFTCxjQUFjLEVBQ2QsNkJBQTZCLEdBQzlCLE1BQU0saUJBQWlCLENBQUM7QUFFekIsT0FBTyxFQUNMLG9CQUFvQixFQUNwQixHQUFHLEVBQ0gsV0FBVyxFQUNYLFNBQVMsRUFDVCxHQUFHLEdBQ0osTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBS3hCLE1BQU0sT0FBTyxnQ0FBZ0M7SUFtQjNDLFlBQ1ksY0FBOEIsRUFDOUIsNkJBQTREO1FBRDVELG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5QixrQ0FBNkIsR0FBN0IsNkJBQTZCLENBQStCO1FBcEI5RCw0QkFBdUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsRUFBRSxDQUFDLElBQUksQ0FDM0UsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxFQUNyRSxvQkFBb0IsRUFBRSxDQUN2QixDQUFDO1FBRVEsNEJBQXVCLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FDbkUsR0FBRyxDQUFDLENBQUMsc0JBQThCLEVBQUUsRUFBRTtZQUNyQyxJQUFJLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFO2dCQUNuQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsNkJBQTZCLENBQzlELHNCQUFzQixDQUN2QixDQUFDO2FBQ0g7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLDZCQUE2QixDQUFDLDhCQUE4QixFQUFFLENBQUM7YUFDckU7UUFDSCxDQUFDLENBQUMsRUFDRixXQUFXLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUMvQyxDQUFDO0lBS0MsQ0FBQztJQUVKLGVBQWU7UUFDYixPQUFPLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQ3RDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQ2QsSUFBSSxDQUFDLDZCQUE2QixDQUFDLDRCQUE0QixFQUFFLENBQ2xFLENBQ0YsQ0FBQztJQUNKLENBQUM7Ozs7WUFqQ0YsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUFkQyxjQUFjO1lBQ2QsNkJBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgUmVwbGVuaXNobWVudE9yZGVyLFxuICBSb3V0aW5nU2VydmljZSxcbiAgVXNlclJlcGxlbmlzaG1lbnRPcmRlclNlcnZpY2UsXG59IGZyb20gJ0BzcGFydGFjdXMvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgbWFwLFxuICBzaGFyZVJlcGxheSxcbiAgc3dpdGNoTWFwLFxuICB0YXAsXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIFJlcGxlbmlzaG1lbnRPcmRlckRldGFpbHNTZXJ2aWNlIHtcbiAgcHJvdGVjdGVkIHJlcGxlbmlzaG1lbnRPcmRlckNvZGUkID0gdGhpcy5yb3V0aW5nU2VydmljZS5nZXRSb3V0ZXJTdGF0ZSgpLnBpcGUoXG4gICAgbWFwKChyb3V0aW5nRGF0YSkgPT4gcm91dGluZ0RhdGEuc3RhdGUucGFyYW1zLnJlcGxlbmlzaG1lbnRPcmRlckNvZGUpLFxuICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgKTtcblxuICBwcm90ZWN0ZWQgcmVwbGVuaXNobWVudE9yZGVyTG9hZCQgPSB0aGlzLnJlcGxlbmlzaG1lbnRPcmRlckNvZGUkLnBpcGUoXG4gICAgdGFwKChyZXBsZW5pc2htZW50T3JkZXJDb2RlOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmIChCb29sZWFuKHJlcGxlbmlzaG1lbnRPcmRlckNvZGUpKSB7XG4gICAgICAgIHRoaXMudXNlclJlcGxlbmlzaG1lbnRPcmRlclNlcnZpY2UubG9hZFJlcGxlbmlzaG1lbnRPcmRlckRldGFpbHMoXG4gICAgICAgICAgcmVwbGVuaXNobWVudE9yZGVyQ29kZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51c2VyUmVwbGVuaXNobWVudE9yZGVyU2VydmljZS5jbGVhclJlcGxlbmlzaG1lbnRPcmRlckRldGFpbHMoKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pXG4gICk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHJvdXRpbmdTZXJ2aWNlOiBSb3V0aW5nU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgdXNlclJlcGxlbmlzaG1lbnRPcmRlclNlcnZpY2U6IFVzZXJSZXBsZW5pc2htZW50T3JkZXJTZXJ2aWNlXG4gICkge31cblxuICBnZXRPcmRlckRldGFpbHMoKTogT2JzZXJ2YWJsZTxSZXBsZW5pc2htZW50T3JkZXI+IHtcbiAgICByZXR1cm4gdGhpcy5yZXBsZW5pc2htZW50T3JkZXJMb2FkJC5waXBlKFxuICAgICAgc3dpdGNoTWFwKChfKSA9PlxuICAgICAgICB0aGlzLnVzZXJSZXBsZW5pc2htZW50T3JkZXJTZXJ2aWNlLmdldFJlcGxlbmlzaG1lbnRPcmRlckRldGFpbHMoKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn1cbiJdfQ==