import { Injectable } from '@angular/core';
import { ofType } from '@ngrx/effects';
import { ROUTER_NAVIGATED } from '@ngrx/router-store';
import { ActionsSubject } from '@ngrx/store';
import { createFrom, EventService, } from '@spartacus/core';
import { map } from 'rxjs/operators';
import { NavigationEvent } from './navigation.event';
import * as i0 from "@angular/core";
import * as i1 from "@ngrx/store";
import * as i2 from "@spartacus/core";
/**
 * A builder for the NavigationEvent
 */
export class NavigationEventBuilder {
    constructor(actions, eventService) {
        this.actions = actions;
        this.eventService = eventService;
        this.register();
    }
    /**
     * Registers events
     */
    register() {
        this.eventService.register(NavigationEvent, this.buildNavigationEvent());
    }
    /**
     * Builds the navigation events
     */
    buildNavigationEvent() {
        return this.getNavigatedEvent().pipe(map((state) => createFrom(NavigationEvent, {
            context: state.context,
            semanticRoute: state.semanticRoute,
            url: state.url,
            params: state.params,
        })));
    }
    getNavigatedEvent() {
        return this.actions.pipe(ofType(ROUTER_NAVIGATED), map((event) => event.payload.routerState));
    }
}
NavigationEventBuilder.ɵprov = i0.ɵɵdefineInjectable({ factory: function NavigationEventBuilder_Factory() { return new NavigationEventBuilder(i0.ɵɵinject(i1.ActionsSubject), i0.ɵɵinject(i2.EventService)); }, token: NavigationEventBuilder, providedIn: "root" });
NavigationEventBuilder.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
NavigationEventBuilder.ctorParameters = () => [
    { type: ActionsSubject },
    { type: EventService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi1ldmVudC5idWlsZGVyLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL1BhdHJ5ay9EZXNrdG9wL3NwYXJ0YWN1cy9wcm9qZWN0cy9zdG9yZWZyb250bGliL3NyYy8iLCJzb3VyY2VzIjpbImV2ZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb24tZXZlbnQuYnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkMsT0FBTyxFQUF5QixnQkFBZ0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzdFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDN0MsT0FBTyxFQUVMLFVBQVUsRUFDVixZQUFZLEdBQ2IsTUFBTSxpQkFBaUIsQ0FBQztBQUV6QixPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG9CQUFvQixDQUFDOzs7O0FBRXJEOztHQUVHO0FBSUgsTUFBTSxPQUFPLHNCQUFzQjtJQUNqQyxZQUNZLE9BQXVCLEVBQ3ZCLFlBQTBCO1FBRDFCLFlBQU8sR0FBUCxPQUFPLENBQWdCO1FBQ3ZCLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBRXBDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNsQixDQUFDO0lBRUQ7O09BRUc7SUFDTyxRQUFRO1FBQ2hCLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO0lBQzNFLENBQUM7SUFFRDs7T0FFRztJQUNPLG9CQUFvQjtRQUM1QixPQUFPLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLElBQUksQ0FDbEMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDWixVQUFVLENBQUMsZUFBZSxFQUFFO1lBQzFCLE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTztZQUN0QixhQUFhLEVBQUUsS0FBSyxDQUFDLGFBQWE7WUFDbEMsR0FBRyxFQUFFLEtBQUssQ0FBQyxHQUFHO1lBQ2QsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNO1NBQ3JCLENBQUMsQ0FDSCxDQUNGLENBQUM7SUFDSixDQUFDO0lBRU8saUJBQWlCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQ3RCLE1BQU0sQ0FDSixnQkFBZ0IsQ0FDakIsRUFDRCxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQzFDLENBQUM7SUFDSixDQUFDOzs7O1lBekNGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O1lBZlEsY0FBYztZQUlyQixZQUFZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgb2ZUeXBlIH0gZnJvbSAnQG5ncngvZWZmZWN0cyc7XG5pbXBvcnQgeyBSb3V0ZXJOYXZpZ2F0ZWRBY3Rpb24sIFJPVVRFUl9OQVZJR0FURUQgfSBmcm9tICdAbmdyeC9yb3V0ZXItc3RvcmUnO1xuaW1wb3J0IHsgQWN0aW9uc1N1YmplY3QgfSBmcm9tICdAbmdyeC9zdG9yZSc7XG5pbXBvcnQge1xuICBBY3RpdmF0ZWRSb3V0ZXJTdGF0ZVNuYXBzaG90LFxuICBjcmVhdGVGcm9tLFxuICBFdmVudFNlcnZpY2UsXG59IGZyb20gJ0BzcGFydGFjdXMvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uRXZlbnQgfSBmcm9tICcuL25hdmlnYXRpb24uZXZlbnQnO1xuXG4vKipcbiAqIEEgYnVpbGRlciBmb3IgdGhlIE5hdmlnYXRpb25FdmVudFxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbkV2ZW50QnVpbGRlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBhY3Rpb25zOiBBY3Rpb25zU3ViamVjdCxcbiAgICBwcm90ZWN0ZWQgZXZlbnRTZXJ2aWNlOiBFdmVudFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5yZWdpc3RlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBldmVudHNcbiAgICovXG4gIHByb3RlY3RlZCByZWdpc3RlcigpOiB2b2lkIHtcbiAgICB0aGlzLmV2ZW50U2VydmljZS5yZWdpc3RlcihOYXZpZ2F0aW9uRXZlbnQsIHRoaXMuYnVpbGROYXZpZ2F0aW9uRXZlbnQoKSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBuYXZpZ2F0aW9uIGV2ZW50c1xuICAgKi9cbiAgcHJvdGVjdGVkIGJ1aWxkTmF2aWdhdGlvbkV2ZW50KCk6IE9ic2VydmFibGU8TmF2aWdhdGlvbkV2ZW50PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF2aWdhdGVkRXZlbnQoKS5waXBlKFxuICAgICAgbWFwKChzdGF0ZSkgPT5cbiAgICAgICAgY3JlYXRlRnJvbShOYXZpZ2F0aW9uRXZlbnQsIHtcbiAgICAgICAgICBjb250ZXh0OiBzdGF0ZS5jb250ZXh0LFxuICAgICAgICAgIHNlbWFudGljUm91dGU6IHN0YXRlLnNlbWFudGljUm91dGUsXG4gICAgICAgICAgdXJsOiBzdGF0ZS51cmwsXG4gICAgICAgICAgcGFyYW1zOiBzdGF0ZS5wYXJhbXMsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TmF2aWdhdGVkRXZlbnQoKTogT2JzZXJ2YWJsZTxBY3RpdmF0ZWRSb3V0ZXJTdGF0ZVNuYXBzaG90PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgb2ZUeXBlPFJvdXRlck5hdmlnYXRlZEFjdGlvbjxBY3RpdmF0ZWRSb3V0ZXJTdGF0ZVNuYXBzaG90Pj4oXG4gICAgICAgIFJPVVRFUl9OQVZJR0FURURcbiAgICAgICksXG4gICAgICBtYXAoKGV2ZW50KSA9PiBldmVudC5wYXlsb2FkLnJvdXRlclN0YXRlKVxuICAgICk7XG4gIH1cbn1cbiJdfQ==