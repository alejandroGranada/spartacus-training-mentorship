import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
export class SelectFocusUtility {
    constructor() {
        /**
         * Query selectors used to query focusable child elements of the host element.
         * The selectors are supplemented with `:not([disabled])` and `:not([hidden])`.
         */
        this.focusableSelectors = [
            'a[href]',
            'button',
            '[tabindex]',
            'input',
            'select',
            'textarea',
        ];
        // like to leave out the following as we don't use it, and make this list exensible.
        //   `[contentEditable=true]`, // very unlikely to suport as we're not a business tool
        //   `iframe`, // we really don't like iframes...
        //   `area[href]`, // very debatable!
        this.focusableSelectorSuffix = ':not([disabled]):not([hidden])';
    }
    query(host, selector) {
        if (!selector || selector === '') {
            return [];
        }
        return Array.from(host.querySelectorAll(selector));
    }
    findFirstFocusable(host, config = { autofocus: true }) {
        const selector = typeof (config === null || config === void 0 ? void 0 : config.autofocus) === 'string' ? config.autofocus : '[autofocus]';
        // fallback to first focusable
        return (this.query(host, selector).find((el) => !this.isHidden(el)) ||
            this.findFocusable(host).find((el) => Boolean(el)));
    }
    /**
     * returns all focusable child elements of the host element. The element selectors
     * are build from the `focusableSelectors`.
     *
     * @param host the `HTMLElement` used to query focusable elements
     * @param locked indicates whether inactive (`tabindex="-1"`) focusable elements should be returned
     * @param invisible indicates whether hidden focusable elements should be returned
     */
    findFocusable(host, locked = false, invisible = false) {
        let suffix = this.focusableSelectorSuffix;
        if (!locked) {
            suffix += `:not([tabindex='-1'])`;
        }
        const selector = this.focusableSelectors
            .map((s) => (s += suffix))
            .join(',');
        return this.query(host, selector).filter((el) => !invisible ? !this.isHidden(el) : Boolean(el));
    }
    /**
     * Indicates whether the element is hidden by CSS. There are various CSS rules and
     * HTML structures which can lead to an hidden or invisible element. An `offsetParent`
     * of null indicates that the element or any of it's decendants is hidden (`display:none`).
     *
     * Oother techniques use the visibility (`visibility: hidden`), opacity (`opacity`) or
     * phyisical location on the element itself or any of it's anchestor elements. Those
     * technique require to work with the _computed styles_, which will cause a performance
     * downgrade. We don't do this in the standard implementaton.
     */
    isHidden(el) {
        return el.offsetParent === null;
    }
}
SelectFocusUtility.ɵprov = i0.ɵɵdefineInjectable({ factory: function SelectFocusUtility_Factory() { return new SelectFocusUtility(); }, token: SelectFocusUtility, providedIn: "root" });
SelectFocusUtility.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LWZvY3VzLnV0aWwuanMiLCJzb3VyY2VSb290IjoiQzovVXNlcnMvUGF0cnlrL0Rlc2t0b3Avc3BhcnRhY3VzL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc3JjLyIsInNvdXJjZXMiOlsibGF5b3V0L2ExMXkva2V5Ym9hcmQtZm9jdXMvc2VydmljZXMvc2VsZWN0LWZvY3VzLnV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7QUFNM0MsTUFBTSxPQUFPLGtCQUFrQjtJQUgvQjtRQUlFOzs7V0FHRztRQUNPLHVCQUFrQixHQUFhO1lBQ3ZDLFNBQVM7WUFDVCxRQUFRO1lBQ1IsWUFBWTtZQUNaLE9BQU87WUFDUCxRQUFRO1lBQ1IsVUFBVTtTQUNYLENBQUM7UUFFRixvRkFBb0Y7UUFDcEYsc0ZBQXNGO1FBQ3RGLGlEQUFpRDtRQUNqRCxxQ0FBcUM7UUFFM0IsNEJBQXVCLEdBQUcsZ0NBQWdDLENBQUM7S0E4RHRFO0lBNURDLEtBQUssQ0FBQyxJQUFpQixFQUFFLFFBQWdCO1FBQ3ZDLElBQUksQ0FBQyxRQUFRLElBQUksUUFBUSxLQUFLLEVBQUUsRUFBRTtZQUNoQyxPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUNmLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQTRCLENBQzNELENBQUM7SUFDSixDQUFDO0lBRUQsa0JBQWtCLENBQ2hCLElBQWlCLEVBQ2pCLFNBQTBCLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRTtRQUU3QyxNQUFNLFFBQVEsR0FDWixRQUFPLE1BQU0sYUFBTixNQUFNLHVCQUFOLE1BQU0sQ0FBRSxTQUFTLENBQUEsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztRQUMzRSw4QkFBOEI7UUFDOUIsT0FBTyxDQUNMLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzNELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FDbkQsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsYUFBYSxDQUNYLElBQWlCLEVBQ2pCLE1BQU0sR0FBRyxLQUFLLEVBQ2QsU0FBUyxHQUFHLEtBQUs7UUFFakIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDO1FBQzFDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxNQUFNLElBQUksdUJBQXVCLENBQUM7U0FDbkM7UUFDRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsa0JBQWtCO2FBQ3JDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUM7YUFDekIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUM5QyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQzlDLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ08sUUFBUSxDQUFDLEVBQWU7UUFDaEMsT0FBTyxFQUFFLENBQUMsWUFBWSxLQUFLLElBQUksQ0FBQztJQUNsQyxDQUFDOzs7O1lBbkZGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEF1dG9Gb2N1c0NvbmZpZyB9IGZyb20gJy4uL2tleWJvYXJkLWZvY3VzLm1vZGVsJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIFNlbGVjdEZvY3VzVXRpbGl0eSB7XG4gIC8qKlxuICAgKiBRdWVyeSBzZWxlY3RvcnMgdXNlZCB0byBxdWVyeSBmb2N1c2FibGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIGhvc3QgZWxlbWVudC5cbiAgICogVGhlIHNlbGVjdG9ycyBhcmUgc3VwcGxlbWVudGVkIHdpdGggYDpub3QoW2Rpc2FibGVkXSlgIGFuZCBgOm5vdChbaGlkZGVuXSlgLlxuICAgKi9cbiAgcHJvdGVjdGVkIGZvY3VzYWJsZVNlbGVjdG9yczogc3RyaW5nW10gPSBbXG4gICAgJ2FbaHJlZl0nLFxuICAgICdidXR0b24nLFxuICAgICdbdGFiaW5kZXhdJyxcbiAgICAnaW5wdXQnLFxuICAgICdzZWxlY3QnLFxuICAgICd0ZXh0YXJlYScsXG4gIF07XG5cbiAgLy8gbGlrZSB0byBsZWF2ZSBvdXQgdGhlIGZvbGxvd2luZyBhcyB3ZSBkb24ndCB1c2UgaXQsIGFuZCBtYWtlIHRoaXMgbGlzdCBleGVuc2libGUuXG4gIC8vICAgYFtjb250ZW50RWRpdGFibGU9dHJ1ZV1gLCAvLyB2ZXJ5IHVubGlrZWx5IHRvIHN1cG9ydCBhcyB3ZSdyZSBub3QgYSBidXNpbmVzcyB0b29sXG4gIC8vICAgYGlmcmFtZWAsIC8vIHdlIHJlYWxseSBkb24ndCBsaWtlIGlmcmFtZXMuLi5cbiAgLy8gICBgYXJlYVtocmVmXWAsIC8vIHZlcnkgZGViYXRhYmxlIVxuXG4gIHByb3RlY3RlZCBmb2N1c2FibGVTZWxlY3RvclN1ZmZpeCA9ICc6bm90KFtkaXNhYmxlZF0pOm5vdChbaGlkZGVuXSknO1xuXG4gIHF1ZXJ5KGhvc3Q6IEhUTUxFbGVtZW50LCBzZWxlY3Rvcjogc3RyaW5nKTogSFRNTEVsZW1lbnRbXSB7XG4gICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJycpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oXG4gICAgICBob3N0LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpIGFzIE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+XG4gICAgKTtcbiAgfVxuXG4gIGZpbmRGaXJzdEZvY3VzYWJsZShcbiAgICBob3N0OiBIVE1MRWxlbWVudCxcbiAgICBjb25maWc6IEF1dG9Gb2N1c0NvbmZpZyA9IHsgYXV0b2ZvY3VzOiB0cnVlIH1cbiAgKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IHNlbGVjdG9yID1cbiAgICAgIHR5cGVvZiBjb25maWc/LmF1dG9mb2N1cyA9PT0gJ3N0cmluZycgPyBjb25maWcuYXV0b2ZvY3VzIDogJ1thdXRvZm9jdXNdJztcbiAgICAvLyBmYWxsYmFjayB0byBmaXJzdCBmb2N1c2FibGVcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5xdWVyeShob3N0LCBzZWxlY3RvcikuZmluZCgoZWwpID0+ICF0aGlzLmlzSGlkZGVuKGVsKSkgfHxcbiAgICAgIHRoaXMuZmluZEZvY3VzYWJsZShob3N0KS5maW5kKChlbCkgPT4gQm9vbGVhbihlbCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGFsbCBmb2N1c2FibGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIGhvc3QgZWxlbWVudC4gVGhlIGVsZW1lbnQgc2VsZWN0b3JzXG4gICAqIGFyZSBidWlsZCBmcm9tIHRoZSBgZm9jdXNhYmxlU2VsZWN0b3JzYC5cbiAgICpcbiAgICogQHBhcmFtIGhvc3QgdGhlIGBIVE1MRWxlbWVudGAgdXNlZCB0byBxdWVyeSBmb2N1c2FibGUgZWxlbWVudHNcbiAgICogQHBhcmFtIGxvY2tlZCBpbmRpY2F0ZXMgd2hldGhlciBpbmFjdGl2ZSAoYHRhYmluZGV4PVwiLTFcImApIGZvY3VzYWJsZSBlbGVtZW50cyBzaG91bGQgYmUgcmV0dXJuZWRcbiAgICogQHBhcmFtIGludmlzaWJsZSBpbmRpY2F0ZXMgd2hldGhlciBoaWRkZW4gZm9jdXNhYmxlIGVsZW1lbnRzIHNob3VsZCBiZSByZXR1cm5lZFxuICAgKi9cbiAgZmluZEZvY3VzYWJsZShcbiAgICBob3N0OiBIVE1MRWxlbWVudCxcbiAgICBsb2NrZWQgPSBmYWxzZSxcbiAgICBpbnZpc2libGUgPSBmYWxzZVxuICApOiBIVE1MRWxlbWVudFtdIHtcbiAgICBsZXQgc3VmZml4ID0gdGhpcy5mb2N1c2FibGVTZWxlY3RvclN1ZmZpeDtcbiAgICBpZiAoIWxvY2tlZCkge1xuICAgICAgc3VmZml4ICs9IGA6bm90KFt0YWJpbmRleD0nLTEnXSlgO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuZm9jdXNhYmxlU2VsZWN0b3JzXG4gICAgICAubWFwKChzKSA9PiAocyArPSBzdWZmaXgpKVxuICAgICAgLmpvaW4oJywnKTtcbiAgICByZXR1cm4gdGhpcy5xdWVyeShob3N0LCBzZWxlY3RvcikuZmlsdGVyKChlbCkgPT5cbiAgICAgICFpbnZpc2libGUgPyAhdGhpcy5pc0hpZGRlbihlbCkgOiBCb29sZWFuKGVsKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgaGlkZGVuIGJ5IENTUy4gVGhlcmUgYXJlIHZhcmlvdXMgQ1NTIHJ1bGVzIGFuZFxuICAgKiBIVE1MIHN0cnVjdHVyZXMgd2hpY2ggY2FuIGxlYWQgdG8gYW4gaGlkZGVuIG9yIGludmlzaWJsZSBlbGVtZW50LiBBbiBgb2Zmc2V0UGFyZW50YFxuICAgKiBvZiBudWxsIGluZGljYXRlcyB0aGF0IHRoZSBlbGVtZW50IG9yIGFueSBvZiBpdCdzIGRlY2VuZGFudHMgaXMgaGlkZGVuIChgZGlzcGxheTpub25lYCkuXG4gICAqXG4gICAqIE9vdGhlciB0ZWNobmlxdWVzIHVzZSB0aGUgdmlzaWJpbGl0eSAoYHZpc2liaWxpdHk6IGhpZGRlbmApLCBvcGFjaXR5IChgb3BhY2l0eWApIG9yXG4gICAqIHBoeWlzaWNhbCBsb2NhdGlvbiBvbiB0aGUgZWxlbWVudCBpdHNlbGYgb3IgYW55IG9mIGl0J3MgYW5jaGVzdG9yIGVsZW1lbnRzLiBUaG9zZVxuICAgKiB0ZWNobmlxdWUgcmVxdWlyZSB0byB3b3JrIHdpdGggdGhlIF9jb21wdXRlZCBzdHlsZXNfLCB3aGljaCB3aWxsIGNhdXNlIGEgcGVyZm9ybWFuY2VcbiAgICogZG93bmdyYWRlLiBXZSBkb24ndCBkbyB0aGlzIGluIHRoZSBzdGFuZGFyZCBpbXBsZW1lbnRhdG9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIGlzSGlkZGVuKGVsOiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBlbC5vZmZzZXRQYXJlbnQgPT09IG51bGw7XG4gIH1cbn1cbiJdfQ==