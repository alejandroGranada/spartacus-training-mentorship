import { Inject, Injectable, isDevMode, } from '@angular/core';
import { resolveApplicable } from '@spartacus/core';
import { BehaviorSubject, combineLatest } from 'rxjs';
import { LayoutConfig } from '../../config/layout-config';
import { LaunchRenderStrategy } from './launch-render.strategy';
import { filter, map, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./launch-render.strategy";
import * as i2 from "../../config/layout-config";
export class LaunchDialogService {
    constructor(renderStrategies, layoutConfig) {
        this.renderStrategies = renderStrategies;
        this.layoutConfig = layoutConfig;
        this._dialogClose = new BehaviorSubject(undefined);
        this._dataSubject = new BehaviorSubject(undefined);
        this.renderStrategies = this.renderStrategies || [];
    }
    get data$() {
        return this._dataSubject.asObservable();
    }
    /**
     * Open the dialog
     *
     * @param caller LAUNCH_CALLER
     * @param openElement button's Element ref
     * @param vcr View Container Ref of the container for inline rendering
     * @param data optional data which could be passed to dialog
     */
    openDialog(caller, openElement, vcr, data) {
        const component = this.launch(caller, vcr, data);
        if (component) {
            return combineLatest([component, this.dialogClose]).pipe(filter(([, close]) => close !== undefined), tap(([comp]) => {
                openElement === null || openElement === void 0 ? void 0 : openElement.nativeElement.focus();
                this.clear(caller);
                comp.destroy();
            }), map(([comp]) => comp));
        }
    }
    /**
     * Render the element based on the strategy from the launch configuration
     *
     * @param caller LAUNCH_CALLER
     * @param vcr View Container Ref of the container for inline rendering
     */
    launch(caller, vcr, data) {
        const config = this.findConfiguration(caller);
        if (config) {
            const renderer = this.getStrategy(config);
            // Render if the strategy exists
            if (renderer) {
                this._dialogClose.next(undefined);
                this._dataSubject.next(data);
                return renderer.render(config, caller, vcr);
            }
        }
        else if (isDevMode()) {
            console.warn('No configuration provided for caller ' + caller);
        }
    }
    /**
     * Util method to remove element from rendered elements list
     *
     * @param caller LAUNCH_CALLER
     */
    clear(caller) {
        const config = this.findConfiguration(caller);
        const renderer = this.getStrategy(config);
        // Render if the strategy exists
        if (renderer) {
            renderer.remove(caller, config);
        }
    }
    get dialogClose() {
        return this._dialogClose.asObservable();
    }
    closeDialog(reason) {
        this._dialogClose.next(reason);
    }
    /**
     * Returns the configuration for the caller
     *
     * @param caller LAUNCH_CALLER
     */
    findConfiguration(caller) {
        var _a;
        if ((_a = this.layoutConfig) === null || _a === void 0 ? void 0 : _a.launch) {
            return this.layoutConfig.launch[caller];
        }
        return undefined;
    }
    /**
     * Returns the render strategy based on the configuration
     *
     * @param config Configuration for launch
     */
    getStrategy(config) {
        return resolveApplicable(this.renderStrategies, [config]);
    }
}
LaunchDialogService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LaunchDialogService_Factory() { return new LaunchDialogService(i0.ɵɵinject(i1.LaunchRenderStrategy), i0.ɵɵinject(i2.LayoutConfig)); }, token: LaunchDialogService, providedIn: "root" });
LaunchDialogService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
LaunchDialogService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [LaunchRenderStrategy,] }] },
    { type: LayoutConfig }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF1bmNoLWRpYWxvZy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL1BhdHJ5ay9EZXNrdG9wL3NwYXJ0YWN1cy9wcm9qZWN0cy9zdG9yZWZyb250bGliL3NyYy8iLCJzb3VyY2VzIjpbImxheW91dC9sYXVuY2gtZGlhbG9nL3NlcnZpY2VzL2xhdW5jaC1kaWFsb2cuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBR0wsTUFBTSxFQUNOLFVBQVUsRUFDVixTQUFTLEdBRVYsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDbEUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBRTFELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBR2xELE1BQU0sT0FBTyxtQkFBbUI7SUFROUIsWUFFWSxnQkFBd0MsRUFDeEMsWUFBMEI7UUFEMUIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUF3QjtRQUN4QyxpQkFBWSxHQUFaLFlBQVksQ0FBYztRQVY5QixpQkFBWSxHQUFHLElBQUksZUFBZSxDQUFTLFNBQVMsQ0FBQyxDQUFDO1FBQ3RELGlCQUFZLEdBQUcsSUFBSSxlQUFlLENBQU0sU0FBUyxDQUFDLENBQUM7UUFXekQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxFQUFFLENBQUM7SUFDdEQsQ0FBQztJQVZELElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUMxQyxDQUFDO0lBVUQ7Ozs7Ozs7T0FPRztJQUNILFVBQVUsQ0FDUixNQUE4QixFQUM5QixXQUF3QixFQUN4QixHQUFzQixFQUN0QixJQUFVO1FBRVYsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRWpELElBQUksU0FBUyxFQUFFO1lBQ2IsT0FBTyxhQUFhLENBQUMsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUN0RCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUMsRUFDMUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFO2dCQUNiLFdBQVcsYUFBWCxXQUFXLHVCQUFYLFdBQVcsQ0FBRSxhQUFhLENBQUMsS0FBSyxHQUFHO2dCQUNuQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUNuQixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDakIsQ0FBQyxDQUFDLEVBQ0YsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQ3RCLENBQUM7U0FDSDtJQUNILENBQUM7SUFDRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FDSixNQUE4QixFQUM5QixHQUFzQixFQUN0QixJQUFVO1FBRVYsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzlDLElBQUksTUFBTSxFQUFFO1lBQ1YsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUUxQyxnQ0FBZ0M7WUFDaEMsSUFBSSxRQUFRLEVBQUU7Z0JBQ1osSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ2xDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUU3QixPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQzthQUM3QztTQUNGO2FBQU0sSUFBSSxTQUFTLEVBQUUsRUFBRTtZQUN0QixPQUFPLENBQUMsSUFBSSxDQUFDLHVDQUF1QyxHQUFHLE1BQU0sQ0FBQyxDQUFDO1NBQ2hFO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsTUFBOEI7UUFDbEMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzlDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFMUMsZ0NBQWdDO1FBQ2hDLElBQUksUUFBUSxFQUFFO1lBQ1osUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDakM7SUFDSCxDQUFDO0lBRUQsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQzFDLENBQUM7SUFFRCxXQUFXLENBQUMsTUFBYztRQUN4QixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLGlCQUFpQixDQUFDLE1BQThCOztRQUN4RCxVQUFJLElBQUksQ0FBQyxZQUFZLDBDQUFFLE1BQU0sRUFBRTtZQUM3QixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3pDO1FBQ0QsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxXQUFXLENBQUMsTUFBcUI7UUFDekMsT0FBTyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzVELENBQUM7Ozs7WUFsSEYsVUFBVSxTQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7O3dDQVU3QixNQUFNLFNBQUMsb0JBQW9CO1lBZnZCLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnRSZWYsXG4gIEVsZW1lbnRSZWYsXG4gIEluamVjdCxcbiAgSW5qZWN0YWJsZSxcbiAgaXNEZXZNb2RlLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHJlc29sdmVBcHBsaWNhYmxlIH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgY29tYmluZUxhdGVzdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTGF5b3V0Q29uZmlnIH0gZnJvbSAnLi4vLi4vY29uZmlnL2xheW91dC1jb25maWcnO1xuaW1wb3J0IHsgTGF1bmNoT3B0aW9ucywgTEFVTkNIX0NBTExFUiB9IGZyb20gJy4uL2NvbmZpZy9sYXVuY2gtY29uZmlnJztcbmltcG9ydCB7IExhdW5jaFJlbmRlclN0cmF0ZWd5IH0gZnJvbSAnLi9sYXVuY2gtcmVuZGVyLnN0cmF0ZWd5JztcbmltcG9ydCB7IGZpbHRlciwgbWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgTGF1bmNoRGlhbG9nU2VydmljZSB7XG4gIHByaXZhdGUgX2RpYWxvZ0Nsb3NlID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+KHVuZGVmaW5lZCk7XG4gIHByaXZhdGUgX2RhdGFTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxhbnk+KHVuZGVmaW5lZCk7XG5cbiAgZ2V0IGRhdGEkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChMYXVuY2hSZW5kZXJTdHJhdGVneSlcbiAgICBwcm90ZWN0ZWQgcmVuZGVyU3RyYXRlZ2llczogTGF1bmNoUmVuZGVyU3RyYXRlZ3lbXSxcbiAgICBwcm90ZWN0ZWQgbGF5b3V0Q29uZmlnOiBMYXlvdXRDb25maWdcbiAgKSB7XG4gICAgdGhpcy5yZW5kZXJTdHJhdGVnaWVzID0gdGhpcy5yZW5kZXJTdHJhdGVnaWVzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIGRpYWxvZ1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGVyIExBVU5DSF9DQUxMRVJcbiAgICogQHBhcmFtIG9wZW5FbGVtZW50IGJ1dHRvbidzIEVsZW1lbnQgcmVmXG4gICAqIEBwYXJhbSB2Y3IgVmlldyBDb250YWluZXIgUmVmIG9mIHRoZSBjb250YWluZXIgZm9yIGlubGluZSByZW5kZXJpbmdcbiAgICogQHBhcmFtIGRhdGEgb3B0aW9uYWwgZGF0YSB3aGljaCBjb3VsZCBiZSBwYXNzZWQgdG8gZGlhbG9nXG4gICAqL1xuICBvcGVuRGlhbG9nKFxuICAgIGNhbGxlcjogTEFVTkNIX0NBTExFUiB8IHN0cmluZyxcbiAgICBvcGVuRWxlbWVudD86IEVsZW1lbnRSZWYsXG4gICAgdmNyPzogVmlld0NvbnRhaW5lclJlZixcbiAgICBkYXRhPzogYW55XG4gICk6IE9ic2VydmFibGU8YW55PiB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5sYXVuY2goY2FsbGVyLCB2Y3IsIGRhdGEpO1xuXG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoW2NvbXBvbmVudCwgdGhpcy5kaWFsb2dDbG9zZV0pLnBpcGUoXG4gICAgICAgIGZpbHRlcigoWywgY2xvc2VdKSA9PiBjbG9zZSAhPT0gdW5kZWZpbmVkKSxcbiAgICAgICAgdGFwKChbY29tcF0pID0+IHtcbiAgICAgICAgICBvcGVuRWxlbWVudD8ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIHRoaXMuY2xlYXIoY2FsbGVyKTtcbiAgICAgICAgICBjb21wLmRlc3Ryb3koKTtcbiAgICAgICAgfSksXG4gICAgICAgIG1hcCgoW2NvbXBdKSA9PiBjb21wKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgZWxlbWVudCBiYXNlZCBvbiB0aGUgc3RyYXRlZ3kgZnJvbSB0aGUgbGF1bmNoIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHBhcmFtIGNhbGxlciBMQVVOQ0hfQ0FMTEVSXG4gICAqIEBwYXJhbSB2Y3IgVmlldyBDb250YWluZXIgUmVmIG9mIHRoZSBjb250YWluZXIgZm9yIGlubGluZSByZW5kZXJpbmdcbiAgICovXG4gIGxhdW5jaChcbiAgICBjYWxsZXI6IExBVU5DSF9DQUxMRVIgfCBzdHJpbmcsXG4gICAgdmNyPzogVmlld0NvbnRhaW5lclJlZixcbiAgICBkYXRhPzogYW55XG4gICk6IHZvaWQgfCBPYnNlcnZhYmxlPENvbXBvbmVudFJlZjxhbnk+PiB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5maW5kQ29uZmlndXJhdGlvbihjYWxsZXIpO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5nZXRTdHJhdGVneShjb25maWcpO1xuXG4gICAgICAvLyBSZW5kZXIgaWYgdGhlIHN0cmF0ZWd5IGV4aXN0c1xuICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX2RpYWxvZ0Nsb3NlLm5leHQodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fZGF0YVN1YmplY3QubmV4dChkYXRhKTtcblxuICAgICAgICByZXR1cm4gcmVuZGVyZXIucmVuZGVyKGNvbmZpZywgY2FsbGVyLCB2Y3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gY29uZmlndXJhdGlvbiBwcm92aWRlZCBmb3IgY2FsbGVyICcgKyBjYWxsZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsIG1ldGhvZCB0byByZW1vdmUgZWxlbWVudCBmcm9tIHJlbmRlcmVkIGVsZW1lbnRzIGxpc3RcbiAgICpcbiAgICogQHBhcmFtIGNhbGxlciBMQVVOQ0hfQ0FMTEVSXG4gICAqL1xuICBjbGVhcihjYWxsZXI6IExBVU5DSF9DQUxMRVIgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmZpbmRDb25maWd1cmF0aW9uKGNhbGxlcik7XG4gICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmdldFN0cmF0ZWd5KGNvbmZpZyk7XG5cbiAgICAvLyBSZW5kZXIgaWYgdGhlIHN0cmF0ZWd5IGV4aXN0c1xuICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIucmVtb3ZlKGNhbGxlciwgY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBnZXQgZGlhbG9nQ2xvc2UoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fZGlhbG9nQ2xvc2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBjbG9zZURpYWxvZyhyZWFzb246IHN0cmluZykge1xuICAgIHRoaXMuX2RpYWxvZ0Nsb3NlLm5leHQocmVhc29uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgY2FsbGVyXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsZXIgTEFVTkNIX0NBTExFUlxuICAgKi9cbiAgcHJvdGVjdGVkIGZpbmRDb25maWd1cmF0aW9uKGNhbGxlcjogTEFVTkNIX0NBTExFUiB8IHN0cmluZyk6IExhdW5jaE9wdGlvbnMge1xuICAgIGlmICh0aGlzLmxheW91dENvbmZpZz8ubGF1bmNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXRDb25maWcubGF1bmNoW2NhbGxlcl07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVuZGVyIHN0cmF0ZWd5IGJhc2VkIG9uIHRoZSBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBmb3IgbGF1bmNoXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0U3RyYXRlZ3koY29uZmlnOiBMYXVuY2hPcHRpb25zKTogTGF1bmNoUmVuZGVyU3RyYXRlZ3kge1xuICAgIHJldHVybiByZXNvbHZlQXBwbGljYWJsZSh0aGlzLnJlbmRlclN0cmF0ZWdpZXMsIFtjb25maWddKTtcbiAgfVxufVxuIl19