import { Injectable, } from '@angular/core';
import { from } from 'rxjs';
import { DefaultComponentHandler } from './default-component.handler';
import { switchMap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./default-component.handler";
/**
 * Lazy component handler used for launching lazy loaded cms components implemented
 * as native Angular components.
 */
export class LazyComponentHandler {
    constructor(defaultHandler) {
        this.defaultHandler = defaultHandler;
    }
    /**
     * We want to mach dynamic import signature () => import('')
     */
    hasMatch(componentMapping) {
        return (typeof componentMapping.component === 'function' &&
            this.isNotClass(componentMapping.component));
    }
    isNotClass(symbol) {
        const signature = symbol.toString().substr(0, 20).replace(' ', '');
        return signature.startsWith('function()') || signature.startsWith('()=>');
    }
    getPriority() {
        return -10 /* LOW */;
    }
    launcher(componentMapping, viewContainerRef, elementInjector, module) {
        return from(componentMapping.component()).pipe(switchMap((component) => this.defaultHandler.launcher(Object.assign(Object.assign({}, componentMapping), { component }), viewContainerRef, elementInjector, module)));
    }
}
LazyComponentHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function LazyComponentHandler_Factory() { return new LazyComponentHandler(i0.ɵɵinject(i1.DefaultComponentHandler)); }, token: LazyComponentHandler, providedIn: "root" });
LazyComponentHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
LazyComponentHandler.ctorParameters = () => [
    { type: DefaultComponentHandler }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF6eS1jb21wb25lbnQuaGFuZGxlci5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvc3RvcmVmcm9udGxpYi9zcmMvIiwic291cmNlcyI6WyJjbXMtc3RydWN0dXJlL3BhZ2UvY29tcG9uZW50L2hhbmRsZXJzL2xhenktY29tcG9uZW50LmhhbmRsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUdMLFVBQVUsR0FJWCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsSUFBSSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBRzNDOzs7R0FHRztBQUlILE1BQU0sT0FBTyxvQkFBb0I7SUFDL0IsWUFBc0IsY0FBdUM7UUFBdkMsbUJBQWMsR0FBZCxjQUFjLENBQXlCO0lBQUcsQ0FBQztJQUVqRTs7T0FFRztJQUNILFFBQVEsQ0FBQyxnQkFBcUM7UUFDNUMsT0FBTyxDQUNMLE9BQU8sZ0JBQWdCLENBQUMsU0FBUyxLQUFLLFVBQVU7WUFDaEQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FDNUMsQ0FBQztJQUNKLENBQUM7SUFFTyxVQUFVLENBQUMsTUFBVztRQUM1QixNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ25FLE9BQU8sU0FBUyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsSUFBSSxTQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzVFLENBQUM7SUFFRCxXQUFXO1FBQ1QscUJBQW9CO0lBQ3RCLENBQUM7SUFFRCxRQUFRLENBQ04sZ0JBQXFDLEVBQ3JDLGdCQUFrQyxFQUNsQyxlQUEwQixFQUMxQixNQUF5QjtRQUV6QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDNUMsU0FBUyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FDdEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLGlDQUNyQixnQkFBZ0IsS0FBRSxTQUFTLEtBQ2hDLGdCQUFnQixFQUNoQixlQUFlLEVBQ2YsTUFBTSxDQUNQLENBQ0YsQ0FDRixDQUFDO0lBQ0osQ0FBQzs7OztZQXpDRixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7OztZQVZRLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudFJlZixcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0YWJsZSxcbiAgSW5qZWN0b3IsXG4gIE5nTW9kdWxlUmVmLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENtc0NvbXBvbmVudE1hcHBpbmcsIFByaW9yaXR5IH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcbmltcG9ydCB7IGZyb20sIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IERlZmF1bHRDb21wb25lbnRIYW5kbGVyIH0gZnJvbSAnLi9kZWZhdWx0LWNvbXBvbmVudC5oYW5kbGVyJztcbmltcG9ydCB7IHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENvbXBvbmVudEhhbmRsZXIgfSBmcm9tICcuL2NvbXBvbmVudC1oYW5kbGVyJztcblxuLyoqXG4gKiBMYXp5IGNvbXBvbmVudCBoYW5kbGVyIHVzZWQgZm9yIGxhdW5jaGluZyBsYXp5IGxvYWRlZCBjbXMgY29tcG9uZW50cyBpbXBsZW1lbnRlZFxuICogYXMgbmF0aXZlIEFuZ3VsYXIgY29tcG9uZW50cy5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIExhenlDb21wb25lbnRIYW5kbGVyIGltcGxlbWVudHMgQ29tcG9uZW50SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkZWZhdWx0SGFuZGxlcjogRGVmYXVsdENvbXBvbmVudEhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFdlIHdhbnQgdG8gbWFjaCBkeW5hbWljIGltcG9ydCBzaWduYXR1cmUgKCkgPT4gaW1wb3J0KCcnKVxuICAgKi9cbiAgaGFzTWF0Y2goY29tcG9uZW50TWFwcGluZzogQ21zQ29tcG9uZW50TWFwcGluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgY29tcG9uZW50TWFwcGluZy5jb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHRoaXMuaXNOb3RDbGFzcyhjb21wb25lbnRNYXBwaW5nLmNvbXBvbmVudClcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBpc05vdENsYXNzKHN5bWJvbDogYW55KTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc3ltYm9sLnRvU3RyaW5nKCkuc3Vic3RyKDAsIDIwKS5yZXBsYWNlKCcgJywgJycpO1xuICAgIHJldHVybiBzaWduYXR1cmUuc3RhcnRzV2l0aCgnZnVuY3Rpb24oKScpIHx8IHNpZ25hdHVyZS5zdGFydHNXaXRoKCcoKT0+Jyk7XG4gIH1cblxuICBnZXRQcmlvcml0eSgpOiBQcmlvcml0eSB7XG4gICAgcmV0dXJuIFByaW9yaXR5LkxPVztcbiAgfVxuXG4gIGxhdW5jaGVyKFxuICAgIGNvbXBvbmVudE1hcHBpbmc6IENtc0NvbXBvbmVudE1hcHBpbmcsXG4gICAgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBlbGVtZW50SW5qZWN0b3I/OiBJbmplY3RvcixcbiAgICBtb2R1bGU/OiBOZ01vZHVsZVJlZjxhbnk+XG4gICk6IE9ic2VydmFibGU8eyBlbGVtZW50UmVmOiBFbGVtZW50UmVmOyBjb21wb25lbnRSZWY/OiBDb21wb25lbnRSZWY8YW55PiB9PiB7XG4gICAgcmV0dXJuIGZyb20oY29tcG9uZW50TWFwcGluZy5jb21wb25lbnQoKSkucGlwZShcbiAgICAgIHN3aXRjaE1hcCgoY29tcG9uZW50KSA9PlxuICAgICAgICB0aGlzLmRlZmF1bHRIYW5kbGVyLmxhdW5jaGVyKFxuICAgICAgICAgIHsgLi4uY29tcG9uZW50TWFwcGluZywgY29tcG9uZW50IH0sXG4gICAgICAgICAgdmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICBlbGVtZW50SW5qZWN0b3IsXG4gICAgICAgICAgbW9kdWxlXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59XG4iXX0=