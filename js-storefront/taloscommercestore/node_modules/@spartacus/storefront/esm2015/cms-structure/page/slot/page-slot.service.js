import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { DeferLoadingStrategy } from '@spartacus/core';
import { CmsComponentsService } from '../../services/cms-components.service';
import * as i0 from "@angular/core";
import * as i1 from "../../services/cms-components.service";
import * as i2 from "@angular/common";
export class PageSlotService {
    constructor(cmsComponentsService, platformId, document) {
        this.cmsComponentsService = cmsComponentsService;
        this.platformId = platformId;
        this.document = document;
        this.resolvePrerenderedSlots();
    }
    /**
     * Finds all slots visible in the SSR pre-rendered DOM
     */
    resolvePrerenderedSlots() {
        if (isPlatformBrowser(this.platformId)) {
            this.prerenderedSlots = Array.from(this.document.querySelectorAll('cx-page-slot'))
                .filter((el) => el.getBoundingClientRect().top <
                this.document.documentElement.clientHeight)
                .map((el) => el.getAttribute('position'));
        }
    }
    /**
     * Indicates if certain slot should be rendered instantly.
     *
     * It's especially useful when transitioning from SSR to CSR application,
     * where we don't want to apply deferring logic to slots that are visible
     * to avoid unnecessary flickering.
     */
    shouldNotDefer(slot) {
        var _a;
        if ((_a = this.prerenderedSlots) === null || _a === void 0 ? void 0 : _a.includes(slot)) {
            this.prerenderedSlots.splice(this.prerenderedSlots.indexOf(slot), 1);
            return true;
        }
        return false;
    }
    /**
     * Returns the defer options for the given component. If the wrapping
     * page slot is prerendered, we would ignore the defer options altogether.
     */
    getComponentDeferOptions(slot, componentType) {
        if (this.shouldNotDefer(slot)) {
            return { deferLoading: DeferLoadingStrategy.INSTANT };
        }
        const deferLoading = this.cmsComponentsService.getDeferLoadingStrategy(componentType);
        return { deferLoading };
    }
}
PageSlotService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PageSlotService_Factory() { return new PageSlotService(i0.ɵɵinject(i1.CmsComponentsService), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i2.DOCUMENT)); }, token: PageSlotService, providedIn: "root" });
PageSlotService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PageSlotService.ctorParameters = () => [
    { type: CmsComponentsService },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnZS1zbG90LnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiQzovVXNlcnMvUGF0cnlrL0Rlc2t0b3Avc3BhcnRhY3VzL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc3JjLyIsInNvdXJjZXMiOlsiY21zLXN0cnVjdHVyZS9wYWdlL3Nsb3QvcGFnZS1zbG90LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxRQUFRLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUU5RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQzs7OztBQUs3RSxNQUFNLE9BQU8sZUFBZTtJQUcxQixZQUNZLG9CQUEwQyxFQUNyQixVQUFlLEVBQ2xCLFFBQVE7UUFGMUIseUJBQW9CLEdBQXBCLG9CQUFvQixDQUFzQjtRQUNyQixlQUFVLEdBQVYsVUFBVSxDQUFLO1FBQ2xCLGFBQVEsR0FBUixRQUFRLENBQUE7UUFFcEMsSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUM7SUFDakMsQ0FBQztJQUVEOztPQUVHO0lBQ08sdUJBQXVCO1FBQy9CLElBQUksaUJBQWlCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3RDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUNoQyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxDQUMvQztpQkFDRSxNQUFNLENBQ0wsQ0FBQyxFQUFXLEVBQUUsRUFBRSxDQUNkLEVBQUUsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUc7Z0JBQzlCLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FDN0M7aUJBQ0EsR0FBRyxDQUFDLENBQUMsRUFBVyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7U0FDdEQ7SUFDSCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsY0FBYyxDQUFDLElBQVk7O1FBQ3pCLFVBQUksSUFBSSxDQUFDLGdCQUFnQiwwQ0FBRSxRQUFRLENBQUMsSUFBSSxHQUFHO1lBQ3pDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNyRSxPQUFPLElBQUksQ0FBQztTQUNiO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsd0JBQXdCLENBQ3RCLElBQVksRUFDWixhQUFxQjtRQUVyQixJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDN0IsT0FBTyxFQUFFLFlBQVksRUFBRSxvQkFBb0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUN2RDtRQUNELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyx1QkFBdUIsQ0FDcEUsYUFBYSxDQUNkLENBQUM7UUFDRixPQUFPLEVBQUUsWUFBWSxFQUFFLENBQUM7SUFDMUIsQ0FBQzs7OztZQTdERixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7OztZQUpRLG9CQUFvQjs0Q0FVeEIsTUFBTSxTQUFDLFdBQVc7NENBQ2xCLE1BQU0sU0FBQyxRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBQTEFURk9STV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRE9DVU1FTlQsIGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEludGVyc2VjdGlvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9sYXlvdXQvbG9hZGluZy9pbnRlcnNlY3Rpb24ubW9kZWwnO1xuaW1wb3J0IHsgRGVmZXJMb2FkaW5nU3RyYXRlZ3kgfSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xuaW1wb3J0IHsgQ21zQ29tcG9uZW50c1NlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jbXMtY29tcG9uZW50cy5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VTbG90U2VydmljZSB7XG4gIHByb3RlY3RlZCBwcmVyZW5kZXJlZFNsb3RzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgY21zQ29tcG9uZW50c1NlcnZpY2U6IENtc0NvbXBvbmVudHNTZXJ2aWNlLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByb3RlY3RlZCBwbGF0Zm9ybUlkOiBhbnksXG4gICAgQEluamVjdChET0NVTUVOVCkgcHJvdGVjdGVkIGRvY3VtZW50XG4gICkge1xuICAgIHRoaXMucmVzb2x2ZVByZXJlbmRlcmVkU2xvdHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgc2xvdHMgdmlzaWJsZSBpbiB0aGUgU1NSIHByZS1yZW5kZXJlZCBET01cbiAgICovXG4gIHByb3RlY3RlZCByZXNvbHZlUHJlcmVuZGVyZWRTbG90cygpOiB2b2lkIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgdGhpcy5wcmVyZW5kZXJlZFNsb3RzID0gQXJyYXkuZnJvbShcbiAgICAgICAgdGhpcy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdjeC1wYWdlLXNsb3QnKVxuICAgICAgKVxuICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgIChlbDogRWxlbWVudCkgPT5cbiAgICAgICAgICAgIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA8XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgKVxuICAgICAgICAubWFwKChlbDogRWxlbWVudCkgPT4gZWwuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIGNlcnRhaW4gc2xvdCBzaG91bGQgYmUgcmVuZGVyZWQgaW5zdGFudGx5LlxuICAgKlxuICAgKiBJdCdzIGVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gdHJhbnNpdGlvbmluZyBmcm9tIFNTUiB0byBDU1IgYXBwbGljYXRpb24sXG4gICAqIHdoZXJlIHdlIGRvbid0IHdhbnQgdG8gYXBwbHkgZGVmZXJyaW5nIGxvZ2ljIHRvIHNsb3RzIHRoYXQgYXJlIHZpc2libGVcbiAgICogdG8gYXZvaWQgdW5uZWNlc3NhcnkgZmxpY2tlcmluZy5cbiAgICovXG4gIHNob3VsZE5vdERlZmVyKHNsb3Q6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnByZXJlbmRlcmVkU2xvdHM/LmluY2x1ZGVzKHNsb3QpKSB7XG4gICAgICB0aGlzLnByZXJlbmRlcmVkU2xvdHMuc3BsaWNlKHRoaXMucHJlcmVuZGVyZWRTbG90cy5pbmRleE9mKHNsb3QpLCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVmZXIgb3B0aW9ucyBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudC4gSWYgdGhlIHdyYXBwaW5nXG4gICAqIHBhZ2Ugc2xvdCBpcyBwcmVyZW5kZXJlZCwgd2Ugd291bGQgaWdub3JlIHRoZSBkZWZlciBvcHRpb25zIGFsdG9nZXRoZXIuXG4gICAqL1xuICBnZXRDb21wb25lbnREZWZlck9wdGlvbnMoXG4gICAgc2xvdDogc3RyaW5nLFxuICAgIGNvbXBvbmVudFR5cGU6IHN0cmluZ1xuICApOiBJbnRlcnNlY3Rpb25PcHRpb25zIHtcbiAgICBpZiAodGhpcy5zaG91bGROb3REZWZlcihzbG90KSkge1xuICAgICAgcmV0dXJuIHsgZGVmZXJMb2FkaW5nOiBEZWZlckxvYWRpbmdTdHJhdGVneS5JTlNUQU5UIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmVyTG9hZGluZyA9IHRoaXMuY21zQ29tcG9uZW50c1NlcnZpY2UuZ2V0RGVmZXJMb2FkaW5nU3RyYXRlZ3koXG4gICAgICBjb21wb25lbnRUeXBlXG4gICAgKTtcbiAgICByZXR1cm4geyBkZWZlckxvYWRpbmcgfTtcbiAgfVxufVxuIl19