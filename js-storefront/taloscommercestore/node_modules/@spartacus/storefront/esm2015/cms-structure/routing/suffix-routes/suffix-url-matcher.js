import { isDevMode } from '@angular/core';
/**
 * Matches the pattern '[ ** / ] marker / :paramName'
 *
 * @param marker phrase that indicates the start of the match
 * @param paramName name of the parameter present after the marker
 * @param precedingParamName name of the parameter for every preceding url segment
 *        i.e. `param` will result in `param0`, `param1`, ...
 */
export function getSuffixUrlMatcher({ marker, paramName, precedingParamName, }) {
    precedingParamName = precedingParamName || 'param';
    const matcher = function suffixUrlMatcher(segments) {
        const markerIndex = findLastIndex(segments, ({ path }) => path === marker);
        const isMarkerLastSegment = markerIndex === segments.length - 1;
        if (markerIndex === -1 || isMarkerLastSegment) {
            return null;
        }
        const paramIndex = markerIndex + 1;
        const posParams = {
            [paramName]: segments[paramIndex],
        };
        for (let i = 0; i < markerIndex; i++) {
            posParams[`${precedingParamName}${i}`] = segments[i];
        }
        return { consumed: segments.slice(0, paramIndex + 1), posParams };
    };
    if (isDevMode()) {
        matcher['_suffixRouteConfig'] = { marker, paramName, precedingParamName }; // property added for easier debugging of routes
    }
    return matcher;
}
function findLastIndex(elements, predicate) {
    for (let index = elements.length - 1; index >= 0; index--) {
        if (predicate(elements[index])) {
            return index;
        }
    }
    return -1;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3VmZml4LXVybC1tYXRjaGVyLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL1BhdHJ5ay9EZXNrdG9wL3NwYXJ0YWN1cy9wcm9qZWN0cy9zdG9yZWZyb250bGliL3NyYy8iLCJzb3VyY2VzIjpbImNtcy1zdHJ1Y3R1cmUvcm91dGluZy9zdWZmaXgtcm91dGVzL3N1ZmZpeC11cmwtbWF0Y2hlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzFDOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsRUFDbEMsTUFBTSxFQUNOLFNBQVMsRUFDVCxrQkFBa0IsR0FLbkI7SUFDQyxrQkFBa0IsR0FBRyxrQkFBa0IsSUFBSSxPQUFPLENBQUM7SUFDbkQsTUFBTSxPQUFPLEdBQUcsU0FBUyxnQkFBZ0IsQ0FDdkMsUUFBc0I7UUFFdEIsTUFBTSxXQUFXLEdBQUcsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsQ0FBQztRQUMzRSxNQUFNLG1CQUFtQixHQUFHLFdBQVcsS0FBSyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUVoRSxJQUFJLFdBQVcsS0FBSyxDQUFDLENBQUMsSUFBSSxtQkFBbUIsRUFBRTtZQUM3QyxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsTUFBTSxVQUFVLEdBQUcsV0FBVyxHQUFHLENBQUMsQ0FBQztRQUNuQyxNQUFNLFNBQVMsR0FBbUM7WUFDaEQsQ0FBQyxTQUFTLENBQUMsRUFBRSxRQUFRLENBQUMsVUFBVSxDQUFDO1NBQ2xDLENBQUM7UUFFRixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3BDLFNBQVMsQ0FBQyxHQUFHLGtCQUFrQixHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3REO1FBRUQsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLENBQUM7SUFDcEUsQ0FBQyxDQUFDO0lBRUYsSUFBSSxTQUFTLEVBQUUsRUFBRTtRQUNmLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxrQkFBa0IsRUFBRSxDQUFDLENBQUMsZ0RBQWdEO0tBQzVIO0lBRUQsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQztBQUVELFNBQVMsYUFBYSxDQUFJLFFBQWEsRUFBRSxTQUE2QjtJQUNwRSxLQUFLLElBQUksS0FBSyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUU7UUFDekQsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDOUIsT0FBTyxLQUFLLENBQUM7U0FDZDtLQUNGO0lBQ0QsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUNaLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVybE1hdGNoUmVzdWx0LCBVcmxTZWdtZW50IH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuLyoqXG4gKiBNYXRjaGVzIHRoZSBwYXR0ZXJuICdbICoqIC8gXSBtYXJrZXIgLyA6cGFyYW1OYW1lJ1xuICpcbiAqIEBwYXJhbSBtYXJrZXIgcGhyYXNlIHRoYXQgaW5kaWNhdGVzIHRoZSBzdGFydCBvZiB0aGUgbWF0Y2hcbiAqIEBwYXJhbSBwYXJhbU5hbWUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIHByZXNlbnQgYWZ0ZXIgdGhlIG1hcmtlclxuICogQHBhcmFtIHByZWNlZGluZ1BhcmFtTmFtZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgZm9yIGV2ZXJ5IHByZWNlZGluZyB1cmwgc2VnbWVudFxuICogICAgICAgIGkuZS4gYHBhcmFtYCB3aWxsIHJlc3VsdCBpbiBgcGFyYW0wYCwgYHBhcmFtMWAsIC4uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VmZml4VXJsTWF0Y2hlcih7XG4gIG1hcmtlcixcbiAgcGFyYW1OYW1lLFxuICBwcmVjZWRpbmdQYXJhbU5hbWUsXG59OiB7XG4gIG1hcmtlcjogc3RyaW5nO1xuICBwYXJhbU5hbWU6IHN0cmluZztcbiAgcHJlY2VkaW5nUGFyYW1OYW1lPzogc3RyaW5nO1xufSkge1xuICBwcmVjZWRpbmdQYXJhbU5hbWUgPSBwcmVjZWRpbmdQYXJhbU5hbWUgfHwgJ3BhcmFtJztcbiAgY29uc3QgbWF0Y2hlciA9IGZ1bmN0aW9uIHN1ZmZpeFVybE1hdGNoZXIoXG4gICAgc2VnbWVudHM6IFVybFNlZ21lbnRbXVxuICApOiBVcmxNYXRjaFJlc3VsdCB8IG51bGwge1xuICAgIGNvbnN0IG1hcmtlckluZGV4ID0gZmluZExhc3RJbmRleChzZWdtZW50cywgKHsgcGF0aCB9KSA9PiBwYXRoID09PSBtYXJrZXIpO1xuICAgIGNvbnN0IGlzTWFya2VyTGFzdFNlZ21lbnQgPSBtYXJrZXJJbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoIC0gMTtcblxuICAgIGlmIChtYXJrZXJJbmRleCA9PT0gLTEgfHwgaXNNYXJrZXJMYXN0U2VnbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1JbmRleCA9IG1hcmtlckluZGV4ICsgMTtcbiAgICBjb25zdCBwb3NQYXJhbXM6IHsgW25hbWU6IHN0cmluZ106IFVybFNlZ21lbnQgfSA9IHtcbiAgICAgIFtwYXJhbU5hbWVdOiBzZWdtZW50c1twYXJhbUluZGV4XSxcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXJJbmRleDsgaSsrKSB7XG4gICAgICBwb3NQYXJhbXNbYCR7cHJlY2VkaW5nUGFyYW1OYW1lfSR7aX1gXSA9IHNlZ21lbnRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNvbnN1bWVkOiBzZWdtZW50cy5zbGljZSgwLCBwYXJhbUluZGV4ICsgMSksIHBvc1BhcmFtcyB9O1xuICB9O1xuXG4gIGlmIChpc0Rldk1vZGUoKSkge1xuICAgIG1hdGNoZXJbJ19zdWZmaXhSb3V0ZUNvbmZpZyddID0geyBtYXJrZXIsIHBhcmFtTmFtZSwgcHJlY2VkaW5nUGFyYW1OYW1lIH07IC8vIHByb3BlcnR5IGFkZGVkIGZvciBlYXNpZXIgZGVidWdnaW5nIG9mIHJvdXRlc1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXI7XG59XG5cbmZ1bmN0aW9uIGZpbmRMYXN0SW5kZXg8VD4oZWxlbWVudHM6IFRbXSwgcHJlZGljYXRlOiAoZWw6IFQpID0+IGJvb2xlYW4pIHtcbiAgZm9yIChsZXQgaW5kZXggPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgaWYgKHByZWRpY2F0ZShlbGVtZW50c1tpbmRleF0pKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbiJdfQ==