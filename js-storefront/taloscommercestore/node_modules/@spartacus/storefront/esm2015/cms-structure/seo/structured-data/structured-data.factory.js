import { Inject, Injectable, Optional } from '@angular/core';
import { combineLatest, Subscription } from 'rxjs';
import { SCHEMA_BUILDER } from './builders/tokens';
import { JsonLdScriptFactory } from './json-ld-script.factory';
import * as i0 from "@angular/core";
import * as i1 from "./json-ld-script.factory";
import * as i2 from "./builders/tokens";
/**
 * Factory service that is used to build the structured data for
 * all configured schema builders.
 */
export class StructuredDataFactory {
    constructor(scriptBuilder, builders) {
        this.scriptBuilder = scriptBuilder;
        this.builders = builders;
        this.subscription = new Subscription();
    }
    /**
     * Initiates the build of structured data by collecting all schema
     * builders.
     */
    build() {
        if (this.scriptBuilder.isJsonLdRequired() && this.builders) {
            this.subscription.add(this.collectSchemas().subscribe((schema) => {
                this.scriptBuilder.build(schema);
            }));
        }
    }
    /**
     * Collects all schema builders and observe their structured data.
     */
    collectSchemas() {
        return combineLatest(this.builders.map((builder) => builder.build()));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
StructuredDataFactory.ɵprov = i0.ɵɵdefineInjectable({ factory: function StructuredDataFactory_Factory() { return new StructuredDataFactory(i0.ɵɵinject(i1.JsonLdScriptFactory), i0.ɵɵinject(i2.SCHEMA_BUILDER, 8)); }, token: StructuredDataFactory, providedIn: "root" });
StructuredDataFactory.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
StructuredDataFactory.ctorParameters = () => [
    { type: JsonLdScriptFactory },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [SCHEMA_BUILDER,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RydWN0dXJlZC1kYXRhLmZhY3RvcnkuanMiLCJzb3VyY2VSb290IjoiQzovVXNlcnMvUGF0cnlrL0Rlc2t0b3Avc3BhcnRhY3VzL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc3JjLyIsInNvdXJjZXMiOlsiY21zLXN0cnVjdHVyZS9zZW8vc3RydWN0dXJlZC1kYXRhL3N0cnVjdHVyZWQtZGF0YS5mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFhLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RSxPQUFPLEVBQUUsYUFBYSxFQUFjLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbkQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7Ozs7QUFFL0Q7OztHQUdHO0FBSUgsTUFBTSxPQUFPLHFCQUFxQjtJQUNoQyxZQUNVLGFBQWtDLEVBR2xDLFFBQXlCO1FBSHpCLGtCQUFhLEdBQWIsYUFBYSxDQUFxQjtRQUdsQyxhQUFRLEdBQVIsUUFBUSxDQUFpQjtRQUd6QixpQkFBWSxHQUFpQixJQUFJLFlBQVksRUFBRSxDQUFDO0lBRnZELENBQUM7SUFJSjs7O09BR0c7SUFDSCxLQUFLO1FBQ0gsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixFQUFFLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUMxRCxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FDbkIsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQVksRUFBRSxFQUFFO2dCQUMvQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNuQyxDQUFDLENBQUMsQ0FDSCxDQUFDO1NBQ0g7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDTyxjQUFjO1FBQ3RCLE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNsQyxDQUFDOzs7O1lBcENGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O1lBUlEsbUJBQW1CO3dDQVl2QixRQUFRLFlBQ1IsTUFBTSxTQUFDLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QsIE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU2NoZW1hQnVpbGRlciB9IGZyb20gJy4vYnVpbGRlcnMvc2NoZW1hLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTQ0hFTUFfQlVJTERFUiB9IGZyb20gJy4vYnVpbGRlcnMvdG9rZW5zJztcbmltcG9ydCB7IEpzb25MZFNjcmlwdEZhY3RvcnkgfSBmcm9tICcuL2pzb24tbGQtc2NyaXB0LmZhY3RvcnknO1xuXG4vKipcbiAqIEZhY3Rvcnkgc2VydmljZSB0aGF0IGlzIHVzZWQgdG8gYnVpbGQgdGhlIHN0cnVjdHVyZWQgZGF0YSBmb3JcbiAqIGFsbCBjb25maWd1cmVkIHNjaGVtYSBidWlsZGVycy5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIFN0cnVjdHVyZWREYXRhRmFjdG9yeSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgc2NyaXB0QnVpbGRlcjogSnNvbkxkU2NyaXB0RmFjdG9yeSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoU0NIRU1BX0JVSUxERVIpXG4gICAgcHJpdmF0ZSBidWlsZGVyczogU2NoZW1hQnVpbGRlcltdXG4gICkge31cblxuICBwcm90ZWN0ZWQgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyB0aGUgYnVpbGQgb2Ygc3RydWN0dXJlZCBkYXRhIGJ5IGNvbGxlY3RpbmcgYWxsIHNjaGVtYVxuICAgKiBidWlsZGVycy5cbiAgICovXG4gIGJ1aWxkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNjcmlwdEJ1aWxkZXIuaXNKc29uTGRSZXF1aXJlZCgpICYmIHRoaXMuYnVpbGRlcnMpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgICAgdGhpcy5jb2xsZWN0U2NoZW1hcygpLnN1YnNjcmliZSgoc2NoZW1hOiB7fVtdKSA9PiB7XG4gICAgICAgICAgdGhpcy5zY3JpcHRCdWlsZGVyLmJ1aWxkKHNjaGVtYSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0cyBhbGwgc2NoZW1hIGJ1aWxkZXJzIGFuZCBvYnNlcnZlIHRoZWlyIHN0cnVjdHVyZWQgZGF0YS5cbiAgICovXG4gIHByb3RlY3RlZCBjb2xsZWN0U2NoZW1hcygpOiBPYnNlcnZhYmxlPGFueVtdPiB7XG4gICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QodGhpcy5idWlsZGVycy5tYXAoKGJ1aWxkZXIpID0+IGJ1aWxkZXIuYnVpbGQoKSkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIl19