import { isPlatformServer } from '@angular/common';
import { Inject, Injectable, isDevMode, PLATFORM_ID, } from '@angular/core';
import { CmsConfig, ConfigInitializerService, deepMerge, } from '@spartacus/core';
import { defer, forkJoin, of } from 'rxjs';
import { mapTo, share, tap } from 'rxjs/operators';
import { FeatureModulesService } from './feature-modules.service';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
import * as i2 from "./feature-modules.service";
/**
 * Service with logic related to resolving component from cms mapping
 */
export class CmsComponentsService {
    constructor(config, platformId, featureModules, configInitializer) {
        var _a;
        this.config = config;
        this.platformId = platformId;
        this.featureModules = featureModules;
        this.configInitializer = configInitializer;
        this.missingComponents = [];
        this.mappings = {};
        // contains
        this.mappingResolvers = new Map();
        (_a = this.configInitializer) === null || _a === void 0 ? void 0 : _a.getStable('cmsComponents').subscribe((cmsConfig) => {
            // we want to grab cms configuration available at config initialization phase
            // as lazy-loaded modules can affect global configuration resulting in
            // non-deterministic state
            this.staticCmsConfig = Object.assign({}, cmsConfig.cmsComponents);
        });
    }
    /**
     * Should be called to make sure all component mappings are determined,
     * especially lazy loaded ones.
     *
     * It's recommended way to make sure all other methods of CmsComponentService
     * will be able to work synchronously for asked component types and avoid risk
     * of potential errors that could be thrown otherwise.
     */
    determineMappings(componentTypes) {
        return defer(() => {
            var _a, _b;
            // we use defer, to be sure the logic below used to compose final observable
            // will be executed at subscription time (with up to date state at the time,
            // when it will be needed)
            const featureResolvers = [];
            for (const componentType of componentTypes) {
                if (!this.mappings[componentType]) {
                    const staticConfig = (_b = ((_a = this.staticCmsConfig) !== null && _a !== void 0 ? _a : this.config.cmsComponents)) === null || _b === void 0 ? void 0 : _b[componentType];
                    // check if this component type is managed by feature module
                    if (this.featureModules.hasFeatureFor(componentType)) {
                        featureResolvers.push(
                        // we delegate populating this.mappings to feature resolver
                        this.getFeatureMappingResolver(componentType, staticConfig));
                    }
                    else {
                        // simply use only static config
                        this.mappings[componentType] = staticConfig;
                    }
                }
            }
            if (featureResolvers.length) {
                return forkJoin(featureResolvers).pipe(mapTo(componentTypes));
            }
            else {
                return of(componentTypes);
            }
        });
    }
    getFeatureMappingResolver(componentType, staticConfig) {
        if (!this.mappingResolvers.has(componentType)) {
            const mappingResolver$ = this.featureModules
                .getCmsMapping(componentType)
                .pipe(tap((featureComponentMapping) => {
                // We treat cms mapping configuration from a feature as a default,
                // that can be overridden by app/static configuration
                this.mappings[componentType] = deepMerge({}, featureComponentMapping, staticConfig);
                this.mappingResolvers.delete(componentType);
            }), share());
            this.mappingResolvers.set(componentType, mappingResolver$);
        }
        return this.mappingResolvers.get(componentType);
    }
    /**
     * Returns the feature module for a cms component.
     * It will only work for cms components provided by feature modules.
     *
     * @param componentType
     */
    getModule(componentType) {
        return (this.featureModules.hasFeatureFor(componentType) &&
            this.featureModules.getModule(componentType));
    }
    /**
     * Return collection of component mapping configuration for specified list of
     * component types.
     *
     * If component mapping can't be determined synchronously, for example, lazy
     * loaded one, it will throw an error.
     *
     * To make sure component mapping is available, determineMappings()
     * should be called and completed first.
     */
    getMapping(componentType) {
        var _a, _b, _c;
        const componentConfig = (_a = this.mappings[componentType]) !== null && _a !== void 0 ? _a : (_c = ((_b = this.staticCmsConfig) !== null && _b !== void 0 ? _b : this.config.cmsComponents)) === null || _c === void 0 ? void 0 : _c[componentType];
        if (isDevMode() && !componentConfig) {
            if (!this.missingComponents.includes(componentType)) {
                this.missingComponents.push(componentType);
                console.warn(`No component implementation found for the CMS component type '${componentType}'.\n`, `Make sure you implement a component and register it in the mapper.`);
            }
        }
        return componentConfig;
    }
    /**
     * Checks, if component should be rendered as some components
     * could be disabled for server side renderings
     */
    shouldRender(componentType) {
        var _a;
        const isSSR = isPlatformServer(this.platformId);
        return !(isSSR && ((_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.disableSSR));
    }
    /**
     * Return DeferLoadingStrategy for component type.
     */
    getDeferLoadingStrategy(componentType) {
        var _a, _b, _c;
        return (_c = (_b = ((_a = this.staticCmsConfig) !== null && _a !== void 0 ? _a : this.config.cmsComponents)) === null || _b === void 0 ? void 0 : _b[componentType]) === null || _c === void 0 ? void 0 : _c.deferLoading;
    }
    /**
     * Get cms driven child routes for components
     */
    getChildRoutes(componentTypes) {
        var _a, _b;
        const configs = [];
        for (const componentType of componentTypes) {
            if (this.shouldRender(componentType)) {
                configs.push((_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.childRoutes) !== null && _b !== void 0 ? _b : []);
            }
        }
        return this.standardizeChildRoutes(configs);
    }
    /**
     * Returns the static data for the component type.
     */
    getStaticData(componentType) {
        var _a;
        return (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.data;
    }
    /**
     * Standardizes the format of `childRoutes` config.
     *
     * Some `childRoutes` configs are simple arrays of Routes (without the notion of the parent route).
     * But some configs can be an object with children routes and their parent defined in separate property.
     */
    standardizeChildRoutes(childRoutesConfigs) {
        const result = { children: [] };
        (childRoutesConfigs || []).forEach((config) => {
            if (Array.isArray(config)) {
                result.children.push(...config);
            }
            else {
                result.children.push(...(config.children || []));
                if (config.parent) {
                    result.parent = config.parent;
                }
            }
        });
        return result;
    }
    /**
     * Get cms driven guards for components
     */
    getGuards(componentTypes) {
        var _a, _b;
        const guards = new Set();
        for (const componentType of componentTypes) {
            (_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.guards) === null || _b === void 0 ? void 0 : _b.forEach((guard) => guards.add(guard));
        }
        return Array.from(guards);
    }
    /**
     * Get i18n keys associated with components
     */
    getI18nKeys(componentTypes) {
        var _a, _b;
        const i18nKeys = new Set();
        for (const componentType of componentTypes) {
            if (this.shouldRender(componentType)) {
                (_b = (_a = this.getMapping(componentType)) === null || _a === void 0 ? void 0 : _a.i18nKeys) === null || _b === void 0 ? void 0 : _b.forEach((key) => i18nKeys.add(key));
            }
        }
        return Array.from(i18nKeys);
    }
}
CmsComponentsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CmsComponentsService_Factory() { return new CmsComponentsService(i0.ɵɵinject(i1.CmsConfig), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i2.FeatureModulesService), i0.ɵɵinject(i1.ConfigInitializerService)); }, token: CmsComponentsService, providedIn: "root" });
CmsComponentsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
CmsComponentsService.ctorParameters = () => [
    { type: CmsConfig },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: FeatureModulesService },
    { type: ConfigInitializerService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY21zLWNvbXBvbmVudHMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvc3RvcmVmcm9udGxpYi9zcmMvIiwic291cmNlcyI6WyJjbXMtc3RydWN0dXJlL3NlcnZpY2VzL2Ntcy1jb21wb25lbnRzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbkQsT0FBTyxFQUNMLE1BQU0sRUFDTixVQUFVLEVBQ1YsU0FBUyxFQUVULFdBQVcsR0FDWixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBS0wsU0FBUyxFQUNULHdCQUF3QixFQUN4QixTQUFTLEdBRVYsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QixPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdkQsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7Ozs7QUFFbEU7O0dBRUc7QUFJSCxNQUFNLE9BQU8sb0JBQW9CO0lBWS9CLFlBQ1ksTUFBaUIsRUFDSSxVQUFrQixFQUN2QyxjQUFzQyxFQUN0QyxpQkFBNEM7O1FBSDVDLFdBQU0sR0FBTixNQUFNLENBQVc7UUFDSSxlQUFVLEdBQVYsVUFBVSxDQUFRO1FBQ3ZDLG1CQUFjLEdBQWQsY0FBYyxDQUF3QjtRQUN0QyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQTJCO1FBZmhELHNCQUFpQixHQUFhLEVBQUUsQ0FBQztRQUNqQyxhQUFRLEdBQXFELEVBQUUsQ0FBQztRQUl4RSxXQUFXO1FBQ0gscUJBQWdCLEdBR3BCLElBQUksR0FBRyxFQUFFLENBQUM7UUFRWixNQUFBLElBQUksQ0FBQyxpQkFBaUIsMENBQ2xC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QUFDLEVBQ2pCO1NBQ0g7UUFDRCxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsV0FBVyxDQUFDLGNBQXdCOztRQUNsQyxNQUFNLFFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ25DLEtBQUssTUFBTSxhQUFhLElBQUksY0FBYyxFQUFFO1lBQzFDLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDcEMsWUFBQSxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQywwQ0FBRSxRQUFRLDBDQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ3hELFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQ2pCO2FBQ0g7U0FDRjtRQUNELE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM5QixDQUFDOzs7O1lBdk9GLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O1lBZEMsU0FBUztZQTZCb0MsTUFBTSx1QkFBaEQsTUFBTSxTQUFDLFdBQVc7WUF0QmQscUJBQXFCO1lBTjVCLHdCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUGxhdGZvcm1TZXJ2ZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgSW5qZWN0LFxuICBJbmplY3RhYmxlLFxuICBpc0Rldk1vZGUsXG4gIE5nTW9kdWxlUmVmLFxuICBQTEFURk9STV9JRCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQge1xuICBDbXNDb21wb25lbnQsXG4gIENtc0NvbXBvbmVudENoaWxkUm91dGVzQ29uZmlnLFxuICBDTVNDb21wb25lbnRDb25maWcsXG4gIENtc0NvbXBvbmVudE1hcHBpbmcsXG4gIENtc0NvbmZpZyxcbiAgQ29uZmlnSW5pdGlhbGl6ZXJTZXJ2aWNlLFxuICBkZWVwTWVyZ2UsXG4gIERlZmVyTG9hZGluZ1N0cmF0ZWd5LFxufSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xuaW1wb3J0IHsgZGVmZXIsIGZvcmtKb2luLCBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwVG8sIHNoYXJlLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBGZWF0dXJlTW9kdWxlc1NlcnZpY2UgfSBmcm9tICcuL2ZlYXR1cmUtbW9kdWxlcy5zZXJ2aWNlJztcblxuLyoqXG4gKiBTZXJ2aWNlIHdpdGggbG9naWMgcmVsYXRlZCB0byByZXNvbHZpbmcgY29tcG9uZW50IGZyb20gY21zIG1hcHBpbmdcbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIENtc0NvbXBvbmVudHNTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBtaXNzaW5nQ29tcG9uZW50czogc3RyaW5nW10gPSBbXTtcbiAgcHJpdmF0ZSBtYXBwaW5nczogeyBbY29tcG9uZW50VHlwZTogc3RyaW5nXTogQ21zQ29tcG9uZW50TWFwcGluZyB9ID0ge307XG4gIC8vIENvcHkgb2YgaW5pdGlhbC9zdGF0aWMgY21zIG1hcHBpbmcgY29uZmlndXJhdGlvbiB1bmFmZmVjdGVkIGJ5IGxhenktbG9hZGVkIG1vZHVsZXNcbiAgcHJpdmF0ZSBzdGF0aWNDbXNDb25maWc6IENNU0NvbXBvbmVudENvbmZpZyB8IHVuZGVmaW5lZDtcblxuICAvLyBjb250YWluc1xuICBwcml2YXRlIG1hcHBpbmdSZXNvbHZlcnM6IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgT2JzZXJ2YWJsZTxDbXNDb21wb25lbnRNYXBwaW5nPlxuICA+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBjb25maWc6IENtc0NvbmZpZyxcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcm90ZWN0ZWQgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIHByb3RlY3RlZCBmZWF0dXJlTW9kdWxlcz86IEZlYXR1cmVNb2R1bGVzU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgY29uZmlnSW5pdGlhbGl6ZXI/OiBDb25maWdJbml0aWFsaXplclNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5jb25maWdJbml0aWFsaXplclxuICAgICAgPy5nZXRTdGFibGUoJ2Ntc0NvbXBvbmVudHMnKVxuICAgICAgLnN1YnNjcmliZSgoY21zQ29uZmlnOiBDbXNDb25maWcpID0+IHtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBncmFiIGNtcyBjb25maWd1cmF0aW9uIGF2YWlsYWJsZSBhdCBjb25maWcgaW5pdGlhbGl6YXRpb24gcGhhc2VcbiAgICAgICAgLy8gYXMgbGF6eS1sb2FkZWQgbW9kdWxlcyBjYW4gYWZmZWN0IGdsb2JhbCBjb25maWd1cmF0aW9uIHJlc3VsdGluZyBpblxuICAgICAgICAvLyBub24tZGV0ZXJtaW5pc3RpYyBzdGF0ZVxuICAgICAgICB0aGlzLnN0YXRpY0Ntc0NvbmZpZyA9IHsgLi4uY21zQ29uZmlnLmNtc0NvbXBvbmVudHMgfTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgdG8gbWFrZSBzdXJlIGFsbCBjb21wb25lbnQgbWFwcGluZ3MgYXJlIGRldGVybWluZWQsXG4gICAqIGVzcGVjaWFsbHkgbGF6eSBsb2FkZWQgb25lcy5cbiAgICpcbiAgICogSXQncyByZWNvbW1lbmRlZCB3YXkgdG8gbWFrZSBzdXJlIGFsbCBvdGhlciBtZXRob2RzIG9mIENtc0NvbXBvbmVudFNlcnZpY2VcbiAgICogd2lsbCBiZSBhYmxlIHRvIHdvcmsgc3luY2hyb25vdXNseSBmb3IgYXNrZWQgY29tcG9uZW50IHR5cGVzIGFuZCBhdm9pZCByaXNrXG4gICAqIG9mIHBvdGVudGlhbCBlcnJvcnMgdGhhdCBjb3VsZCBiZSB0aHJvd24gb3RoZXJ3aXNlLlxuICAgKi9cbiAgZGV0ZXJtaW5lTWFwcGluZ3MoY29tcG9uZW50VHlwZXM6IHN0cmluZ1tdKTogT2JzZXJ2YWJsZTxzdHJpbmdbXT4ge1xuICAgIHJldHVybiBkZWZlcigoKSA9PiB7XG4gICAgICAvLyB3ZSB1c2UgZGVmZXIsIHRvIGJlIHN1cmUgdGhlIGxvZ2ljIGJlbG93IHVzZWQgdG8gY29tcG9zZSBmaW5hbCBvYnNlcnZhYmxlXG4gICAgICAvLyB3aWxsIGJlIGV4ZWN1dGVkIGF0IHN1YnNjcmlwdGlvbiB0aW1lICh3aXRoIHVwIHRvIGRhdGUgc3RhdGUgYXQgdGhlIHRpbWUsXG4gICAgICAvLyB3aGVuIGl0IHdpbGwgYmUgbmVlZGVkKVxuICAgICAgY29uc3QgZmVhdHVyZVJlc29sdmVycyA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudFR5cGUgb2YgY29tcG9uZW50VHlwZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcHBpbmdzW2NvbXBvbmVudFR5cGVdKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGljQ29uZmlnID0gKHRoaXMuc3RhdGljQ21zQ29uZmlnID8/XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jbXNDb21wb25lbnRzKT8uW2NvbXBvbmVudFR5cGVdO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBjb21wb25lbnQgdHlwZSBpcyBtYW5hZ2VkIGJ5IGZlYXR1cmUgbW9kdWxlXG4gICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZU1vZHVsZXMuaGFzRmVhdHVyZUZvcihjb21wb25lbnRUeXBlKSkge1xuICAgICAgICAgICAgZmVhdHVyZVJlc29sdmVycy5wdXNoKFxuICAgICAgICAgICAgICAvLyB3ZSBkZWxlZ2F0ZSBwb3B1bGF0aW5nIHRoaXMubWFwcGluZ3MgdG8gZmVhdHVyZSByZXNvbHZlclxuICAgICAgICAgICAgICB0aGlzLmdldEZlYXR1cmVNYXBwaW5nUmVzb2x2ZXIoY29tcG9uZW50VHlwZSwgc3RhdGljQ29uZmlnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2ltcGx5IHVzZSBvbmx5IHN0YXRpYyBjb25maWdcbiAgICAgICAgICAgIHRoaXMubWFwcGluZ3NbY29tcG9uZW50VHlwZV0gPSBzdGF0aWNDb25maWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmZWF0dXJlUmVzb2x2ZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZm9ya0pvaW4oZmVhdHVyZVJlc29sdmVycykucGlwZShtYXBUbyhjb21wb25lbnRUeXBlcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9mKGNvbXBvbmVudFR5cGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RmVhdHVyZU1hcHBpbmdSZXNvbHZlcihcbiAgICBjb21wb25lbnRUeXBlOiBzdHJpbmcsXG4gICAgc3RhdGljQ29uZmlnPzogQ21zQ29tcG9uZW50TWFwcGluZ1xuICApOiBPYnNlcnZhYmxlPENtc0NvbXBvbmVudE1hcHBpbmc+IHtcbiAgICBpZiAoIXRoaXMubWFwcGluZ1Jlc29sdmVycy5oYXMoY29tcG9uZW50VHlwZSkpIHtcbiAgICAgIGNvbnN0IG1hcHBpbmdSZXNvbHZlciQgPSB0aGlzLmZlYXR1cmVNb2R1bGVzXG4gICAgICAgIC5nZXRDbXNNYXBwaW5nKGNvbXBvbmVudFR5cGUpXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIHRhcCgoZmVhdHVyZUNvbXBvbmVudE1hcHBpbmcpID0+IHtcbiAgICAgICAgICAgIC8vIFdlIHRyZWF0IGNtcyBtYXBwaW5nIGNvbmZpZ3VyYXRpb24gZnJvbSBhIGZlYXR1cmUgYXMgYSBkZWZhdWx0LFxuICAgICAgICAgICAgLy8gdGhhdCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBhcHAvc3RhdGljIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIHRoaXMubWFwcGluZ3NbY29tcG9uZW50VHlwZV0gPSBkZWVwTWVyZ2UoXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICBmZWF0dXJlQ29tcG9uZW50TWFwcGluZyxcbiAgICAgICAgICAgICAgc3RhdGljQ29uZmlnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5tYXBwaW5nUmVzb2x2ZXJzLmRlbGV0ZShjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzaGFyZSgpXG4gICAgICAgICk7XG4gICAgICB0aGlzLm1hcHBpbmdSZXNvbHZlcnMuc2V0KGNvbXBvbmVudFR5cGUsIG1hcHBpbmdSZXNvbHZlciQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXBwaW5nUmVzb2x2ZXJzLmdldChjb21wb25lbnRUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmZWF0dXJlIG1vZHVsZSBmb3IgYSBjbXMgY29tcG9uZW50LlxuICAgKiBJdCB3aWxsIG9ubHkgd29yayBmb3IgY21zIGNvbXBvbmVudHMgcHJvdmlkZWQgYnkgZmVhdHVyZSBtb2R1bGVzLlxuICAgKlxuICAgKiBAcGFyYW0gY29tcG9uZW50VHlwZVxuICAgKi9cbiAgZ2V0TW9kdWxlKGNvbXBvbmVudFR5cGU6IHN0cmluZyk6IE5nTW9kdWxlUmVmPGFueT4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmZlYXR1cmVNb2R1bGVzLmhhc0ZlYXR1cmVGb3IoY29tcG9uZW50VHlwZSkgJiZcbiAgICAgIHRoaXMuZmVhdHVyZU1vZHVsZXMuZ2V0TW9kdWxlKGNvbXBvbmVudFR5cGUpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gY29sbGVjdGlvbiBvZiBjb21wb25lbnQgbWFwcGluZyBjb25maWd1cmF0aW9uIGZvciBzcGVjaWZpZWQgbGlzdCBvZlxuICAgKiBjb21wb25lbnQgdHlwZXMuXG4gICAqXG4gICAqIElmIGNvbXBvbmVudCBtYXBwaW5nIGNhbid0IGJlIGRldGVybWluZWQgc3luY2hyb25vdXNseSwgZm9yIGV4YW1wbGUsIGxhenlcbiAgICogbG9hZGVkIG9uZSwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICpcbiAgICogVG8gbWFrZSBzdXJlIGNvbXBvbmVudCBtYXBwaW5nIGlzIGF2YWlsYWJsZSwgZGV0ZXJtaW5lTWFwcGluZ3MoKVxuICAgKiBzaG91bGQgYmUgY2FsbGVkIGFuZCBjb21wbGV0ZWQgZmlyc3QuXG4gICAqL1xuICBnZXRNYXBwaW5nKGNvbXBvbmVudFR5cGU6IHN0cmluZyk6IENtc0NvbXBvbmVudE1hcHBpbmcge1xuICAgIGNvbnN0IGNvbXBvbmVudENvbmZpZyA9XG4gICAgICB0aGlzLm1hcHBpbmdzW2NvbXBvbmVudFR5cGVdID8/XG4gICAgICAodGhpcy5zdGF0aWNDbXNDb25maWcgPz8gdGhpcy5jb25maWcuY21zQ29tcG9uZW50cyk/Lltjb21wb25lbnRUeXBlXTtcblxuICAgIGlmIChpc0Rldk1vZGUoKSAmJiAhY29tcG9uZW50Q29uZmlnKSB7XG4gICAgICBpZiAoIXRoaXMubWlzc2luZ0NvbXBvbmVudHMuaW5jbHVkZXMoY29tcG9uZW50VHlwZSkpIHtcbiAgICAgICAgdGhpcy5taXNzaW5nQ29tcG9uZW50cy5wdXNoKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYE5vIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvbiBmb3VuZCBmb3IgdGhlIENNUyBjb21wb25lbnQgdHlwZSAnJHtjb21wb25lbnRUeXBlfScuXFxuYCxcbiAgICAgICAgICBgTWFrZSBzdXJlIHlvdSBpbXBsZW1lbnQgYSBjb21wb25lbnQgYW5kIHJlZ2lzdGVyIGl0IGluIHRoZSBtYXBwZXIuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzLCBpZiBjb21wb25lbnQgc2hvdWxkIGJlIHJlbmRlcmVkIGFzIHNvbWUgY29tcG9uZW50c1xuICAgKiBjb3VsZCBiZSBkaXNhYmxlZCBmb3Igc2VydmVyIHNpZGUgcmVuZGVyaW5nc1xuICAgKi9cbiAgc2hvdWxkUmVuZGVyKGNvbXBvbmVudFR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlzU1NSID0gaXNQbGF0Zm9ybVNlcnZlcih0aGlzLnBsYXRmb3JtSWQpO1xuICAgIHJldHVybiAhKGlzU1NSICYmIHRoaXMuZ2V0TWFwcGluZyhjb21wb25lbnRUeXBlKT8uZGlzYWJsZVNTUik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIERlZmVyTG9hZGluZ1N0cmF0ZWd5IGZvciBjb21wb25lbnQgdHlwZS5cbiAgICovXG4gIGdldERlZmVyTG9hZGluZ1N0cmF0ZWd5KFxuICAgIGNvbXBvbmVudFR5cGU6IHN0cmluZ1xuICApOiBEZWZlckxvYWRpbmdTdHJhdGVneSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuICh0aGlzLnN0YXRpY0Ntc0NvbmZpZyA/PyB0aGlzLmNvbmZpZy5jbXNDb21wb25lbnRzKT8uW2NvbXBvbmVudFR5cGVdXG4gICAgICA/LmRlZmVyTG9hZGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY21zIGRyaXZlbiBjaGlsZCByb3V0ZXMgZm9yIGNvbXBvbmVudHNcbiAgICovXG4gIGdldENoaWxkUm91dGVzKGNvbXBvbmVudFR5cGVzOiBzdHJpbmdbXSk6IENtc0NvbXBvbmVudENoaWxkUm91dGVzQ29uZmlnIHtcbiAgICBjb25zdCBjb25maWdzID0gW107XG4gICAgZm9yIChjb25zdCBjb21wb25lbnRUeXBlIG9mIGNvbXBvbmVudFR5cGVzKSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRSZW5kZXIoY29tcG9uZW50VHlwZSkpIHtcbiAgICAgICAgY29uZmlncy5wdXNoKHRoaXMuZ2V0TWFwcGluZyhjb21wb25lbnRUeXBlKT8uY2hpbGRSb3V0ZXMgPz8gW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YW5kYXJkaXplQ2hpbGRSb3V0ZXMoY29uZmlncyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdGljIGRhdGEgZm9yIHRoZSBjb21wb25lbnQgdHlwZS5cbiAgICovXG4gIGdldFN0YXRpY0RhdGE8VCBleHRlbmRzIENtc0NvbXBvbmVudCA9IENtc0NvbXBvbmVudD4oXG4gICAgY29tcG9uZW50VHlwZTogc3RyaW5nXG4gICk6IFQgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmdldE1hcHBpbmcoY29tcG9uZW50VHlwZSk/LmRhdGEgYXMgVDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFuZGFyZGl6ZXMgdGhlIGZvcm1hdCBvZiBgY2hpbGRSb3V0ZXNgIGNvbmZpZy5cbiAgICpcbiAgICogU29tZSBgY2hpbGRSb3V0ZXNgIGNvbmZpZ3MgYXJlIHNpbXBsZSBhcnJheXMgb2YgUm91dGVzICh3aXRob3V0IHRoZSBub3Rpb24gb2YgdGhlIHBhcmVudCByb3V0ZSkuXG4gICAqIEJ1dCBzb21lIGNvbmZpZ3MgY2FuIGJlIGFuIG9iamVjdCB3aXRoIGNoaWxkcmVuIHJvdXRlcyBhbmQgdGhlaXIgcGFyZW50IGRlZmluZWQgaW4gc2VwYXJhdGUgcHJvcGVydHkuXG4gICAqL1xuICBwcm90ZWN0ZWQgc3RhbmRhcmRpemVDaGlsZFJvdXRlcyhcbiAgICBjaGlsZFJvdXRlc0NvbmZpZ3M6IChSb3V0ZVtdIHwgQ21zQ29tcG9uZW50Q2hpbGRSb3V0ZXNDb25maWcpW11cbiAgKTogQ21zQ29tcG9uZW50Q2hpbGRSb3V0ZXNDb25maWcge1xuICAgIGNvbnN0IHJlc3VsdDogQ21zQ29tcG9uZW50Q2hpbGRSb3V0ZXNDb25maWcgPSB7IGNoaWxkcmVuOiBbXSB9O1xuXG4gICAgKGNoaWxkUm91dGVzQ29uZmlncyB8fCBbXSkuZm9yRWFjaCgoY29uZmlnKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIHJlc3VsdC5jaGlsZHJlbi5wdXNoKC4uLmNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuY2hpbGRyZW4ucHVzaCguLi4oY29uZmlnLmNoaWxkcmVuIHx8IFtdKSk7XG4gICAgICAgIGlmIChjb25maWcucGFyZW50KSB7XG4gICAgICAgICAgcmVzdWx0LnBhcmVudCA9IGNvbmZpZy5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNtcyBkcml2ZW4gZ3VhcmRzIGZvciBjb21wb25lbnRzXG4gICAqL1xuICBnZXRHdWFyZHMoY29tcG9uZW50VHlwZXM6IHN0cmluZ1tdKTogYW55W10ge1xuICAgIGNvbnN0IGd1YXJkcyA9IG5ldyBTZXQ8YW55PigpO1xuICAgIGZvciAoY29uc3QgY29tcG9uZW50VHlwZSBvZiBjb21wb25lbnRUeXBlcykge1xuICAgICAgdGhpcy5nZXRNYXBwaW5nKGNvbXBvbmVudFR5cGUpPy5ndWFyZHM/LmZvckVhY2goKGd1YXJkKSA9PlxuICAgICAgICBndWFyZHMuYWRkKGd1YXJkKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZ3VhcmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaTE4biBrZXlzIGFzc29jaWF0ZWQgd2l0aCBjb21wb25lbnRzXG4gICAqL1xuICBnZXRJMThuS2V5cyhjb21wb25lbnRUeXBlczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgaTE4bktleXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudFR5cGUgb2YgY29tcG9uZW50VHlwZXMpIHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFJlbmRlcihjb21wb25lbnRUeXBlKSkge1xuICAgICAgICB0aGlzLmdldE1hcHBpbmcoY29tcG9uZW50VHlwZSk/LmkxOG5LZXlzPy5mb3JFYWNoKChrZXkpID0+XG4gICAgICAgICAgaTE4bktleXMuYWRkKGtleSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaTE4bktleXMpO1xuICB9XG59XG4iXX0=