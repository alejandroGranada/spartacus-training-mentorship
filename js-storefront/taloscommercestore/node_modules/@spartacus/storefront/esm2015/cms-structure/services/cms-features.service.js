import { Injectable, InjectFlags } from '@angular/core';
import { ConfigChunk, ConfigInitializerService, deepMerge, DefaultConfigChunk, FeatureModulesService, } from '@spartacus/core';
import { defer, of } from 'rxjs';
import { map, shareReplay } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
/**
 * Service responsible for resolving cms config based feature modules.
 */
export class CmsFeaturesService {
    constructor(configInitializer, featureModules) {
        this.configInitializer = configInitializer;
        this.featureModules = featureModules;
        // maps componentType to feature
        this.componentFeatureMap = new Map();
        /*
         * Contains either FeatureInstance or FeatureInstance resolver for not yet
         * resolved feature modules
         */
        this.featureInstances = new Map();
        this.initFeatureMap();
    }
    initFeatureMap() {
        this.configInitializer
            .getStable('featureModules')
            .subscribe((config) => {
            var _a, _b;
            this.featureModulesConfig = (_a = config.featureModules) !== null && _a !== void 0 ? _a : {};
            for (const [featureName, featureConfig] of Object.entries(this.featureModulesConfig)) {
                if (typeof featureConfig !== 'string' && (featureConfig === null || featureConfig === void 0 ? void 0 : featureConfig.module) && ((_b = featureConfig === null || featureConfig === void 0 ? void 0 : featureConfig.cmsComponents) === null || _b === void 0 ? void 0 : _b.length)) {
                    for (const component of featureConfig.cmsComponents) {
                        this.componentFeatureMap.set(component, featureName);
                    }
                }
            }
        });
    }
    /**
     * Check if there is feature module configuration that covers specified
     * component type
     */
    hasFeatureFor(componentType) {
        return this.componentFeatureMap.has(componentType);
    }
    /**
     * Return full CmsComponent mapping defined in feature module
     */
    getCmsMapping(componentType) {
        const feature = this.componentFeatureMap.get(componentType);
        if (!feature) {
            return of(undefined);
        }
        return this.resolveFeatureInstance(feature).pipe(map((featureInstance) => { var _a; return (_a = featureInstance.componentsMappings) === null || _a === void 0 ? void 0 : _a[componentType]; }));
    }
    /**
     * Resolves feature module for provided component type
     *
     * @param componentType
     */
    getModule(componentType) {
        var _a;
        const feature = this.componentFeatureMap.get(componentType);
        if (!feature) {
            return undefined;
        }
        let module;
        // we are returning injectors only for already resolved features
        (_a = this.featureInstances
            .get(feature)) === null || _a === void 0 ? void 0 : _a.subscribe((featureInstance) => {
            module = featureInstance.moduleRef;
        }).unsubscribe();
        return module;
    }
    /**
     * Resolve feature based on feature name, if feature was not yet resolved
     *
     * It will first resolve all module dependencies if defined
     */
    resolveFeatureInstance(featureName) {
        return defer(() => {
            if (!this.featureInstances.has(featureName)) {
                this.featureInstances.set(featureName, this.featureModules.resolveFeature(featureName).pipe(map((moduleRef) => this.createFeatureInstance(moduleRef, featureName)), shareReplay()));
            }
            return this.featureInstances.get(featureName);
        });
    }
    /**
     * Create feature instance from feature's moduleRef
     */
    createFeatureInstance(moduleRef, feature) {
        var _a, _b, _c;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const featureConfig = this.featureModulesConfig[feature];
        const featureInstance = {
            moduleRef,
            componentsMappings: {},
        };
        // resolve configuration for feature module
        const resolvedConfiguration = this.resolveFeatureConfiguration(moduleRef.injector);
        // extract cms components configuration from feature config
        for (const componentType of (_a = featureConfig.cmsComponents) !== null && _a !== void 0 ? _a : []) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            featureInstance.componentsMappings[componentType] = (_c = (_b = resolvedConfiguration.cmsComponents) === null || _b === void 0 ? void 0 : _b[componentType]) !== null && _c !== void 0 ? _c : {};
        }
        return featureInstance;
    }
    /**
     * Returns configuration provided in feature module
     */
    resolveFeatureConfiguration(featureInjector) {
        // get config chunks from feature lib
        const featureConfigChunks = featureInjector.get(ConfigChunk, [], InjectFlags.Self);
        // get default config chunks from feature lib
        const featureDefaultConfigChunks = featureInjector.get(DefaultConfigChunk, [], InjectFlags.Self);
        return deepMerge({}, ...(featureDefaultConfigChunks !== null && featureDefaultConfigChunks !== void 0 ? featureDefaultConfigChunks : []), ...(featureConfigChunks !== null && featureConfigChunks !== void 0 ? featureConfigChunks : []));
    }
}
CmsFeaturesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CmsFeaturesService_Factory() { return new CmsFeaturesService(i0.ɵɵinject(i1.ConfigInitializerService), i0.ɵɵinject(i1.FeatureModulesService)); }, token: CmsFeaturesService, providedIn: "root" });
CmsFeaturesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
CmsFeaturesService.ctorParameters = () => [
    { type: ConfigInitializerService },
    { type: FeatureModulesService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY21zLWZlYXR1cmVzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiQzovVXNlcnMvUGF0cnlrL0Rlc2t0b3Avc3BhcnRhY3VzL3Byb2plY3RzL3N0b3JlZnJvbnRsaWIvc3JjLyIsInNvdXJjZXMiOlsiY21zLXN0cnVjdHVyZS9zZXJ2aWNlcy9jbXMtZmVhdHVyZXMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBeUIsTUFBTSxlQUFlLENBQUM7QUFDL0UsT0FBTyxFQUlMLFdBQVcsRUFDWCx3QkFBd0IsRUFDeEIsU0FBUyxFQUNULGtCQUFrQixFQUVsQixxQkFBcUIsR0FDdEIsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QixPQUFPLEVBQUUsS0FBSyxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFPbEQ7O0dBRUc7QUFJSCxNQUFNLE9BQU8sa0JBQWtCO0lBa0I3QixZQUNZLGlCQUEyQyxFQUMzQyxjQUFxQztRQURyQyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQTBCO1FBQzNDLG1CQUFjLEdBQWQsY0FBYyxDQUF1QjtRQWRqRCxnQ0FBZ0M7UUFDeEIsd0JBQW1CLEdBQXdCLElBQUksR0FBRyxFQUFFLENBQUM7UUFFN0Q7OztXQUdHO1FBQ0sscUJBQWdCLEdBR3BCLElBQUksR0FBRyxFQUFFLENBQUM7UUFNWixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVPLGNBQWM7UUFDcEIsSUFBSSxDQUFDLGlCQUFpQjthQUNuQixTQUFTLENBQUMsZ0JBQWdCLENBQUM7YUFDM0IsU0FBUyxDQUFDLENBQUMsTUFBaUIsRUFBRSxFQUFFOztZQUMvQixJQUFJLENBQUMsb0JBQW9CLFNBQUcsTUFBTSxDQUFDLGNBQWMsbUNBQUksRUFBRSxDQUFDO1lBRXhELEtBQUssTUFBTSxDQUFDLFdBQVcsRUFBRSxhQUFhLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUN2RCxJQUFJLENBQUMsb0JBQW9CLENBQzFCLEVBQUU7Z0JBQ0QsSUFDRSxPQUFPLGFBQWEsS0FBSyxRQUFRLEtBQ2pDLGFBQWEsYUFBYixhQUFhLHVCQUFiLGFBQWEsQ0FBRSxNQUFNLENBQUEsV0FDckIsYUFBYSxhQUFiLGFBQWEsdUJBQWIsYUFBYSxDQUFFLGFBQWEsMENBQUUsTUFBTSxDQUFBLEVBQ3BDO29CQUNBLEtBQUssTUFBTSxTQUFTLElBQUksYUFBYSxDQUFDLGFBQWEsRUFBRTt3QkFDbkQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUM7cUJBQ3REO2lCQUNGO2FBQ0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhLENBQUMsYUFBcUI7UUFDakMsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRDs7T0FFRztJQUNILGFBQWEsQ0FDWCxhQUFxQjtRQUVyQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRTVELElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDWixPQUFPLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUN0QjtRQUVELE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FDOUMsR0FBRyxDQUNELENBQUMsZUFBZSxFQUFFLEVBQUUsd0JBQUMsZUFBZSxDQUFDLGtCQUFrQiwwQ0FBRyxhQUFhLElBQUMsQ0FDekUsQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxTQUFTLENBQUMsYUFBcUI7O1FBQzdCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFNUQsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNaLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBRUQsSUFBSSxNQUFNLENBQUM7UUFFWCxnRUFBZ0U7UUFDaEUsTUFBQSxJQUFJLENBQUMsZ0JBQWdCO2FBQ2xCLEdBQUcsQ0FBQyxPQUFPLENBQUMsMENBQ1gsU0FBUyxDQUFDLENBQUMsZUFBZSxFQUFFLEVBQUU7WUFDOUIsTUFBTSxHQUFHLGVBQWUsQ0FBQyxTQUFTLENBQUM7UUFDckMsQ0FBQyxFQUNBLFdBQVcsR0FBRztRQUNqQixPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLHNCQUFzQixDQUM1QixXQUFtQjtRQUVuQixPQUFPLEtBQUssQ0FBQyxHQUFHLEVBQUU7WUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQzNDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQ3ZCLFdBQVcsRUFDWCxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQ2xELEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQ2hCLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQ25ELEVBQ0QsV0FBVyxFQUFFLENBQ2QsQ0FDRixDQUFDO2FBQ0g7WUFFRCxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDaEQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxxQkFBcUIsQ0FDM0IsU0FBMkIsRUFDM0IsT0FBZTs7UUFFZixvRUFBb0U7UUFDcEUsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLG9CQUFxQixDQUM5QyxPQUFPLENBQ2UsQ0FBQztRQUV6QixNQUFNLGVBQWUsR0FBb0I7WUFDdkMsU0FBUztZQUNULGtCQUFrQixFQUFFLEVBQUU7U0FDdkIsQ0FBQztRQUVGLDJDQUEyQztRQUMzQyxNQUFNLHFCQUFxQixHQUFHLElBQUksQ0FBQywyQkFBMkIsQ0FDNUQsU0FBUyxDQUFDLFFBQVEsQ0FDbkIsQ0FBQztRQUVGLDJEQUEyRDtRQUMzRCxLQUFLLE1BQU0sYUFBYSxVQUFJLGFBQWEsQ0FBQyxhQUFhLG1DQUFJLEVBQUUsRUFBRTtZQUM3RCxvRUFBb0U7WUFDcEUsZUFBZSxDQUFDLGtCQUFtQixDQUFDLGFBQWEsQ0FBQyxlQUNoRCxxQkFBcUIsQ0FBQyxhQUFhLDBDQUFHLGFBQWEsb0NBQUssRUFBRSxDQUFDO1NBQzlEO1FBQ0QsT0FBTyxlQUFlLENBQUM7SUFDekIsQ0FBQztJQUVEOztPQUVHO0lBQ0ssMkJBQTJCLENBQUMsZUFBeUI7UUFDM0QscUNBQXFDO1FBQ3JDLE1BQU0sbUJBQW1CLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FDN0MsV0FBVyxFQUNYLEVBQUUsRUFDRixXQUFXLENBQUMsSUFBSSxDQUNqQixDQUFDO1FBQ0YsNkNBQTZDO1FBQzdDLE1BQU0sMEJBQTBCLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FDcEQsa0JBQWtCLEVBQ2xCLEVBQUUsRUFDRixXQUFXLENBQUMsSUFBSSxDQUNqQixDQUFDO1FBRUYsT0FBTyxTQUFTLENBQ2QsRUFBRSxFQUNGLEdBQUcsQ0FBQywwQkFBMEIsYUFBMUIsMEJBQTBCLGNBQTFCLDBCQUEwQixHQUFJLEVBQUUsQ0FBQyxFQUNyQyxHQUFHLENBQUMsbUJBQW1CLGFBQW5CLG1CQUFtQixjQUFuQixtQkFBbUIsR0FBSSxFQUFFLENBQUMsQ0FDbEIsQ0FBQztJQUNqQixDQUFDOzs7O1lBbkxGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O1lBbkJDLHdCQUF3QjtZQUl4QixxQkFBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3RGbGFncywgSW5qZWN0b3IsIE5nTW9kdWxlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBDTVNDb21wb25lbnRDb25maWcsXG4gIENtc0NvbXBvbmVudE1hcHBpbmcsXG4gIENtc0NvbmZpZyxcbiAgQ29uZmlnQ2h1bmssXG4gIENvbmZpZ0luaXRpYWxpemVyU2VydmljZSxcbiAgZGVlcE1lcmdlLFxuICBEZWZhdWx0Q29uZmlnQ2h1bmssXG4gIEZlYXR1cmVNb2R1bGVDb25maWcsXG4gIEZlYXR1cmVNb2R1bGVzU2VydmljZSxcbn0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcbmltcG9ydCB7IGRlZmVyLCBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBzaGFyZVJlcGxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW50ZXJmYWNlIEZlYXR1cmVJbnN0YW5jZSBleHRlbmRzIEZlYXR1cmVNb2R1bGVDb25maWcge1xuICBtb2R1bGVSZWY/OiBOZ01vZHVsZVJlZjxhbnk+O1xuICBjb21wb25lbnRzTWFwcGluZ3M/OiBDTVNDb21wb25lbnRDb25maWc7XG59XG5cbi8qKlxuICogU2VydmljZSByZXNwb25zaWJsZSBmb3IgcmVzb2x2aW5nIGNtcyBjb25maWcgYmFzZWQgZmVhdHVyZSBtb2R1bGVzLlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQ21zRmVhdHVyZXNTZXJ2aWNlIHtcbiAgLy8gZmVhdHVyZSBtb2R1bGVzIGNvbmZpZ3VyYXRpb25cbiAgcHJpdmF0ZSBmZWF0dXJlTW9kdWxlc0NvbmZpZz86IHtcbiAgICBbZmVhdHVyZU5hbWU6IHN0cmluZ106IEZlYXR1cmVNb2R1bGVDb25maWcgfCBzdHJpbmc7XG4gIH07XG5cbiAgLy8gbWFwcyBjb21wb25lbnRUeXBlIHRvIGZlYXR1cmVcbiAgcHJpdmF0ZSBjb21wb25lbnRGZWF0dXJlTWFwOiBNYXA8c3RyaW5nLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xuXG4gIC8qXG4gICAqIENvbnRhaW5zIGVpdGhlciBGZWF0dXJlSW5zdGFuY2Ugb3IgRmVhdHVyZUluc3RhbmNlIHJlc29sdmVyIGZvciBub3QgeWV0XG4gICAqIHJlc29sdmVkIGZlYXR1cmUgbW9kdWxlc1xuICAgKi9cbiAgcHJpdmF0ZSBmZWF0dXJlSW5zdGFuY2VzOiBNYXA8XG4gICAgc3RyaW5nLFxuICAgIE9ic2VydmFibGU8RmVhdHVyZUluc3RhbmNlPlxuICA+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBjb25maWdJbml0aWFsaXplcjogQ29uZmlnSW5pdGlhbGl6ZXJTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBmZWF0dXJlTW9kdWxlczogRmVhdHVyZU1vZHVsZXNTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuaW5pdEZlYXR1cmVNYXAoKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdEZlYXR1cmVNYXAoKTogdm9pZCB7XG4gICAgdGhpcy5jb25maWdJbml0aWFsaXplclxuICAgICAgLmdldFN0YWJsZSgnZmVhdHVyZU1vZHVsZXMnKVxuICAgICAgLnN1YnNjcmliZSgoY29uZmlnOiBDbXNDb25maWcpID0+IHtcbiAgICAgICAgdGhpcy5mZWF0dXJlTW9kdWxlc0NvbmZpZyA9IGNvbmZpZy5mZWF0dXJlTW9kdWxlcyA/PyB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtmZWF0dXJlTmFtZSwgZmVhdHVyZUNvbmZpZ10gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgdGhpcy5mZWF0dXJlTW9kdWxlc0NvbmZpZ1xuICAgICAgICApKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGZlYXR1cmVDb25maWcgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBmZWF0dXJlQ29uZmlnPy5tb2R1bGUgJiZcbiAgICAgICAgICAgIGZlYXR1cmVDb25maWc/LmNtc0NvbXBvbmVudHM/Lmxlbmd0aFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgZmVhdHVyZUNvbmZpZy5jbXNDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50RmVhdHVyZU1hcC5zZXQoY29tcG9uZW50LCBmZWF0dXJlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGVyZSBpcyBmZWF0dXJlIG1vZHVsZSBjb25maWd1cmF0aW9uIHRoYXQgY292ZXJzIHNwZWNpZmllZFxuICAgKiBjb21wb25lbnQgdHlwZVxuICAgKi9cbiAgaGFzRmVhdHVyZUZvcihjb21wb25lbnRUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRGZWF0dXJlTWFwLmhhcyhjb21wb25lbnRUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gZnVsbCBDbXNDb21wb25lbnQgbWFwcGluZyBkZWZpbmVkIGluIGZlYXR1cmUgbW9kdWxlXG4gICAqL1xuICBnZXRDbXNNYXBwaW5nKFxuICAgIGNvbXBvbmVudFR5cGU6IHN0cmluZ1xuICApOiBPYnNlcnZhYmxlPENtc0NvbXBvbmVudE1hcHBpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5jb21wb25lbnRGZWF0dXJlTWFwLmdldChjb21wb25lbnRUeXBlKTtcblxuICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgcmV0dXJuIG9mKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZUZlYXR1cmVJbnN0YW5jZShmZWF0dXJlKS5waXBlKFxuICAgICAgbWFwKFxuICAgICAgICAoZmVhdHVyZUluc3RhbmNlKSA9PiBmZWF0dXJlSW5zdGFuY2UuY29tcG9uZW50c01hcHBpbmdzPy5bY29tcG9uZW50VHlwZV1cbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGZlYXR1cmUgbW9kdWxlIGZvciBwcm92aWRlZCBjb21wb25lbnQgdHlwZVxuICAgKlxuICAgKiBAcGFyYW0gY29tcG9uZW50VHlwZVxuICAgKi9cbiAgZ2V0TW9kdWxlKGNvbXBvbmVudFR5cGU6IHN0cmluZyk6IE5nTW9kdWxlUmVmPGFueT4gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmNvbXBvbmVudEZlYXR1cmVNYXAuZ2V0KGNvbXBvbmVudFR5cGUpO1xuXG4gICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGxldCBtb2R1bGU7XG5cbiAgICAvLyB3ZSBhcmUgcmV0dXJuaW5nIGluamVjdG9ycyBvbmx5IGZvciBhbHJlYWR5IHJlc29sdmVkIGZlYXR1cmVzXG4gICAgdGhpcy5mZWF0dXJlSW5zdGFuY2VzXG4gICAgICAuZ2V0KGZlYXR1cmUpXG4gICAgICA/LnN1YnNjcmliZSgoZmVhdHVyZUluc3RhbmNlKSA9PiB7XG4gICAgICAgIG1vZHVsZSA9IGZlYXR1cmVJbnN0YW5jZS5tb2R1bGVSZWY7XG4gICAgICB9KVxuICAgICAgLnVuc3Vic2NyaWJlKCk7XG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGZlYXR1cmUgYmFzZWQgb24gZmVhdHVyZSBuYW1lLCBpZiBmZWF0dXJlIHdhcyBub3QgeWV0IHJlc29sdmVkXG4gICAqXG4gICAqIEl0IHdpbGwgZmlyc3QgcmVzb2x2ZSBhbGwgbW9kdWxlIGRlcGVuZGVuY2llcyBpZiBkZWZpbmVkXG4gICAqL1xuICBwcml2YXRlIHJlc29sdmVGZWF0dXJlSW5zdGFuY2UoXG4gICAgZmVhdHVyZU5hbWU6IHN0cmluZ1xuICApOiBPYnNlcnZhYmxlPEZlYXR1cmVJbnN0YW5jZT4ge1xuICAgIHJldHVybiBkZWZlcigoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZmVhdHVyZUluc3RhbmNlcy5oYXMoZmVhdHVyZU5hbWUpKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZUluc3RhbmNlcy5zZXQoXG4gICAgICAgICAgZmVhdHVyZU5hbWUsXG4gICAgICAgICAgdGhpcy5mZWF0dXJlTW9kdWxlcy5yZXNvbHZlRmVhdHVyZShmZWF0dXJlTmFtZSkucGlwZShcbiAgICAgICAgICAgIG1hcCgobW9kdWxlUmVmKSA9PlxuICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZlYXR1cmVJbnN0YW5jZShtb2R1bGVSZWYsIGZlYXR1cmVOYW1lKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHNoYXJlUmVwbGF5KClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVJbnN0YW5jZXMuZ2V0KGZlYXR1cmVOYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZmVhdHVyZSBpbnN0YW5jZSBmcm9tIGZlYXR1cmUncyBtb2R1bGVSZWZcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlRmVhdHVyZUluc3RhbmNlKFxuICAgIG1vZHVsZVJlZjogTmdNb2R1bGVSZWY8YW55PixcbiAgICBmZWF0dXJlOiBzdHJpbmdcbiAgKTogRmVhdHVyZUluc3RhbmNlIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IGZlYXR1cmVDb25maWcgPSB0aGlzLmZlYXR1cmVNb2R1bGVzQ29uZmlnIVtcbiAgICAgIGZlYXR1cmVcbiAgICBdIGFzIEZlYXR1cmVNb2R1bGVDb25maWc7XG5cbiAgICBjb25zdCBmZWF0dXJlSW5zdGFuY2U6IEZlYXR1cmVJbnN0YW5jZSA9IHtcbiAgICAgIG1vZHVsZVJlZixcbiAgICAgIGNvbXBvbmVudHNNYXBwaW5nczoge30sXG4gICAgfTtcblxuICAgIC8vIHJlc29sdmUgY29uZmlndXJhdGlvbiBmb3IgZmVhdHVyZSBtb2R1bGVcbiAgICBjb25zdCByZXNvbHZlZENvbmZpZ3VyYXRpb24gPSB0aGlzLnJlc29sdmVGZWF0dXJlQ29uZmlndXJhdGlvbihcbiAgICAgIG1vZHVsZVJlZi5pbmplY3RvclxuICAgICk7XG5cbiAgICAvLyBleHRyYWN0IGNtcyBjb21wb25lbnRzIGNvbmZpZ3VyYXRpb24gZnJvbSBmZWF0dXJlIGNvbmZpZ1xuICAgIGZvciAoY29uc3QgY29tcG9uZW50VHlwZSBvZiBmZWF0dXJlQ29uZmlnLmNtc0NvbXBvbmVudHMgPz8gW10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICBmZWF0dXJlSW5zdGFuY2UuY29tcG9uZW50c01hcHBpbmdzIVtjb21wb25lbnRUeXBlXSA9XG4gICAgICAgIHJlc29sdmVkQ29uZmlndXJhdGlvbi5jbXNDb21wb25lbnRzPy5bY29tcG9uZW50VHlwZV0gPz8ge307XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlSW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maWd1cmF0aW9uIHByb3ZpZGVkIGluIGZlYXR1cmUgbW9kdWxlXG4gICAqL1xuICBwcml2YXRlIHJlc29sdmVGZWF0dXJlQ29uZmlndXJhdGlvbihmZWF0dXJlSW5qZWN0b3I6IEluamVjdG9yKTogQ21zQ29uZmlnIHtcbiAgICAvLyBnZXQgY29uZmlnIGNodW5rcyBmcm9tIGZlYXR1cmUgbGliXG4gICAgY29uc3QgZmVhdHVyZUNvbmZpZ0NodW5rcyA9IGZlYXR1cmVJbmplY3Rvci5nZXQ8YW55W10+KFxuICAgICAgQ29uZmlnQ2h1bmssXG4gICAgICBbXSxcbiAgICAgIEluamVjdEZsYWdzLlNlbGZcbiAgICApO1xuICAgIC8vIGdldCBkZWZhdWx0IGNvbmZpZyBjaHVua3MgZnJvbSBmZWF0dXJlIGxpYlxuICAgIGNvbnN0IGZlYXR1cmVEZWZhdWx0Q29uZmlnQ2h1bmtzID0gZmVhdHVyZUluamVjdG9yLmdldDxhbnlbXT4oXG4gICAgICBEZWZhdWx0Q29uZmlnQ2h1bmssXG4gICAgICBbXSxcbiAgICAgIEluamVjdEZsYWdzLlNlbGZcbiAgICApO1xuXG4gICAgcmV0dXJuIGRlZXBNZXJnZShcbiAgICAgIHt9LFxuICAgICAgLi4uKGZlYXR1cmVEZWZhdWx0Q29uZmlnQ2h1bmtzID8/IFtdKSxcbiAgICAgIC4uLihmZWF0dXJlQ29uZmlnQ2h1bmtzID8/IFtdKVxuICAgICkgYXMgQ21zQ29uZmlnO1xuICB9XG59XG4iXX0=