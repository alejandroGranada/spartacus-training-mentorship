import { Injectable } from '@angular/core';
import { OccConfig } from '../config/occ-config';
import * as i0 from "@angular/core";
import * as i1 from "../config/occ-config";
export class LoadingScopesService {
    constructor(config) {
        this.config = config;
    }
    /**
     * Aims to expand scopes based on loading scopes config.
     *
     * I.e. if 'details' scope includes 'list' scope by configuration, it'll return ['details', 'list']
     *
     * If scope data overlaps with each other, the data should be merged in the order of scopes provided,
     * i.e. the last scope is merged last, overwriting parts of the data already provided by preceding scope.
     * It should apply also to implicit scopes (that are included by configuration).
     *
     * @param model
     * @param scopes
     */
    expand(model, scopes) {
        const scopesConfig = this.config &&
            this.config.backend &&
            this.config.backend.loadingScopes &&
            this.config.backend.loadingScopes[model];
        if (scopesConfig) {
            const expandedScopes = [...scopes];
            let i = expandedScopes.length;
            while (i > 0) {
                i--;
                const includedScopes = scopesConfig[expandedScopes[i]] &&
                    scopesConfig[expandedScopes[i]].include;
                if (includedScopes) {
                    for (const includedScope of includedScopes) {
                        if (!expandedScopes.includes(includedScope)) {
                            expandedScopes.splice(i, 0, includedScope);
                            i++;
                        }
                    }
                }
            }
            return expandedScopes;
        }
        return scopes;
    }
    /**
     * Return maxAge for product scope in milliseconds
     *
     * @param model
     * @param scope
     */
    getMaxAge(model, scope) {
        const scopesConfig = this.config &&
            this.config.backend &&
            this.config.backend.loadingScopes &&
            this.config.backend.loadingScopes[model];
        return (scopesConfig[scope] && scopesConfig[scope].maxAge) * 1000 || 0;
    }
}
LoadingScopesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LoadingScopesService_Factory() { return new LoadingScopesService(i0.ɵɵinject(i1.OccConfig)); }, token: LoadingScopesService, providedIn: "root" });
LoadingScopesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
LoadingScopesService.ctorParameters = () => [
    { type: OccConfig }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZGluZy1zY29wZXMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvY29yZS8iLCJzb3VyY2VzIjpbInNyYy9vY2Mvc2VydmljZXMvbG9hZGluZy1zY29wZXMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQzs7O0FBS2pELE1BQU0sT0FBTyxvQkFBb0I7SUFDL0IsWUFBc0IsTUFBaUI7UUFBakIsV0FBTSxHQUFOLE1BQU0sQ0FBVztJQUFHLENBQUM7SUFFM0M7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxNQUFNLENBQUMsS0FBYSxFQUFFLE1BQWdCO1FBQ3BDLE1BQU0sWUFBWSxHQUNoQixJQUFJLENBQUMsTUFBTTtZQUNYLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTztZQUNuQixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhO1lBQ2pDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUzQyxJQUFJLFlBQVksRUFBRTtZQUNoQixNQUFNLGNBQWMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUM7WUFDbkMsSUFBSSxDQUFDLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQztZQUU5QixPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ1osQ0FBQyxFQUFFLENBQUM7Z0JBQ0osTUFBTSxjQUFjLEdBQ2xCLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQy9CLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7Z0JBQzFDLElBQUksY0FBYyxFQUFFO29CQUNsQixLQUFLLE1BQU0sYUFBYSxJQUFJLGNBQWMsRUFBRTt3QkFDMUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEVBQUU7NEJBQzNDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQzs0QkFDM0MsQ0FBQyxFQUFFLENBQUM7eUJBQ0w7cUJBQ0Y7aUJBQ0Y7YUFDRjtZQUVELE9BQU8sY0FBYyxDQUFDO1NBQ3ZCO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsU0FBUyxDQUFDLEtBQWEsRUFBRSxLQUFhO1FBQ3BDLE1BQU0sWUFBWSxHQUNoQixJQUFJLENBQUMsTUFBTTtZQUNYLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTztZQUNuQixJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhO1lBQ2pDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQyxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDO0lBQ3pFLENBQUM7Ozs7WUEvREYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUFKUSxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2NjQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL29jYy1jb25maWcnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgTG9hZGluZ1Njb3Blc1NlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgY29uZmlnOiBPY2NDb25maWcpIHt9XG5cbiAgLyoqXG4gICAqIEFpbXMgdG8gZXhwYW5kIHNjb3BlcyBiYXNlZCBvbiBsb2FkaW5nIHNjb3BlcyBjb25maWcuXG4gICAqXG4gICAqIEkuZS4gaWYgJ2RldGFpbHMnIHNjb3BlIGluY2x1ZGVzICdsaXN0JyBzY29wZSBieSBjb25maWd1cmF0aW9uLCBpdCdsbCByZXR1cm4gWydkZXRhaWxzJywgJ2xpc3QnXVxuICAgKlxuICAgKiBJZiBzY29wZSBkYXRhIG92ZXJsYXBzIHdpdGggZWFjaCBvdGhlciwgdGhlIGRhdGEgc2hvdWxkIGJlIG1lcmdlZCBpbiB0aGUgb3JkZXIgb2Ygc2NvcGVzIHByb3ZpZGVkLFxuICAgKiBpLmUuIHRoZSBsYXN0IHNjb3BlIGlzIG1lcmdlZCBsYXN0LCBvdmVyd3JpdGluZyBwYXJ0cyBvZiB0aGUgZGF0YSBhbHJlYWR5IHByb3ZpZGVkIGJ5IHByZWNlZGluZyBzY29wZS5cbiAgICogSXQgc2hvdWxkIGFwcGx5IGFsc28gdG8gaW1wbGljaXQgc2NvcGVzICh0aGF0IGFyZSBpbmNsdWRlZCBieSBjb25maWd1cmF0aW9uKS5cbiAgICpcbiAgICogQHBhcmFtIG1vZGVsXG4gICAqIEBwYXJhbSBzY29wZXNcbiAgICovXG4gIGV4cGFuZChtb2RlbDogc3RyaW5nLCBzY29wZXM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHNjb3Blc0NvbmZpZyA9XG4gICAgICB0aGlzLmNvbmZpZyAmJlxuICAgICAgdGhpcy5jb25maWcuYmFja2VuZCAmJlxuICAgICAgdGhpcy5jb25maWcuYmFja2VuZC5sb2FkaW5nU2NvcGVzICYmXG4gICAgICB0aGlzLmNvbmZpZy5iYWNrZW5kLmxvYWRpbmdTY29wZXNbbW9kZWxdO1xuXG4gICAgaWYgKHNjb3Blc0NvbmZpZykge1xuICAgICAgY29uc3QgZXhwYW5kZWRTY29wZXMgPSBbLi4uc2NvcGVzXTtcbiAgICAgIGxldCBpID0gZXhwYW5kZWRTY29wZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgaS0tO1xuICAgICAgICBjb25zdCBpbmNsdWRlZFNjb3BlcyA9XG4gICAgICAgICAgc2NvcGVzQ29uZmlnW2V4cGFuZGVkU2NvcGVzW2ldXSAmJlxuICAgICAgICAgIHNjb3Blc0NvbmZpZ1tleHBhbmRlZFNjb3Blc1tpXV0uaW5jbHVkZTtcbiAgICAgICAgaWYgKGluY2x1ZGVkU2NvcGVzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBpbmNsdWRlZFNjb3BlIG9mIGluY2x1ZGVkU2NvcGVzKSB7XG4gICAgICAgICAgICBpZiAoIWV4cGFuZGVkU2NvcGVzLmluY2x1ZGVzKGluY2x1ZGVkU2NvcGUpKSB7XG4gICAgICAgICAgICAgIGV4cGFuZGVkU2NvcGVzLnNwbGljZShpLCAwLCBpbmNsdWRlZFNjb3BlKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwYW5kZWRTY29wZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjb3BlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gbWF4QWdlIGZvciBwcm9kdWN0IHNjb3BlIGluIG1pbGxpc2Vjb25kc1xuICAgKlxuICAgKiBAcGFyYW0gbW9kZWxcbiAgICogQHBhcmFtIHNjb3BlXG4gICAqL1xuICBnZXRNYXhBZ2UobW9kZWw6IHN0cmluZywgc2NvcGU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3Qgc2NvcGVzQ29uZmlnID1cbiAgICAgIHRoaXMuY29uZmlnICYmXG4gICAgICB0aGlzLmNvbmZpZy5iYWNrZW5kICYmXG4gICAgICB0aGlzLmNvbmZpZy5iYWNrZW5kLmxvYWRpbmdTY29wZXMgJiZcbiAgICAgIHRoaXMuY29uZmlnLmJhY2tlbmQubG9hZGluZ1Njb3Blc1ttb2RlbF07XG4gICAgcmV0dXJuIChzY29wZXNDb25maWdbc2NvcGVdICYmIHNjb3Blc0NvbmZpZ1tzY29wZV0ubWF4QWdlKSAqIDEwMDAgfHwgMDtcbiAgfVxufVxuIl19