import { Injectable } from '@angular/core';
import { map, shareReplay } from 'rxjs/operators';
import { extractFields } from '../utils/occ-fields';
import { OccFieldsService, } from './occ-fields.service';
import { HttpClient } from '@angular/common/http';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "./occ-fields.service";
export class OccRequestsOptimizerService {
    constructor(http, occFields) {
        this.http = http;
        this.occFields = occFields;
    }
    /**
     * Optimize occ endpoint calls merging requests to the same url by merging field parameters
     *
     * @param scopedDataWithUrls
     * @param dataFactory
     */
    scopedDataLoad(scopedDataWithUrls, dataFactory) {
        const result = [];
        if (!dataFactory) {
            dataFactory = (url) => this.http.get(url);
        }
        const mergedUrls = this.occFields.getOptimalUrlGroups(scopedDataWithUrls);
        Object.entries(mergedUrls).forEach(([url, groupedModelsSet]) => {
            const groupedModels = Object.values(groupedModelsSet);
            if (groupedModels.length === 1) {
                // only one scope for url, we can pass the data straightaway
                result.push(Object.assign(Object.assign({}, groupedModels[0].scopedData), { data$: dataFactory(url) }));
            }
            else {
                // multiple scopes per url
                // we have to split the model per each scope
                const data$ = dataFactory(url).pipe(shareReplay(1));
                groupedModels.forEach((modelData) => {
                    result.push(Object.assign(Object.assign({}, modelData.scopedData), { data$: data$.pipe(map((data) => extractFields(data, modelData.fields))) }));
                });
            }
        });
        return result;
    }
}
OccRequestsOptimizerService.ɵprov = i0.ɵɵdefineInjectable({ factory: function OccRequestsOptimizerService_Factory() { return new OccRequestsOptimizerService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.OccFieldsService)); }, token: OccRequestsOptimizerService, providedIn: "root" });
OccRequestsOptimizerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
OccRequestsOptimizerService.ctorParameters = () => [
    { type: HttpClient },
    { type: OccFieldsService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NjLXJlcXVlc3RzLW9wdGltaXplci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL1BhdHJ5ay9EZXNrdG9wL3NwYXJ0YWN1cy9wcm9qZWN0cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL29jYy9zZXJ2aWNlcy9vY2MtcmVxdWVzdHMtb3B0aW1pemVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUczQyxPQUFPLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRCxPQUFPLEVBRUwsZ0JBQWdCLEdBRWpCLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDOzs7O0FBS2xELE1BQU0sT0FBTywyQkFBMkI7SUFDdEMsWUFDWSxJQUFnQixFQUNoQixTQUEyQjtRQUQzQixTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLGNBQVMsR0FBVCxTQUFTLENBQWtCO0lBQ3BDLENBQUM7SUFFSjs7Ozs7T0FLRztJQUNILGNBQWMsQ0FDWixrQkFBdUMsRUFDdkMsV0FBNEM7UUFFNUMsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBRWxCLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsV0FBVyxHQUFHLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBTSxHQUFHLENBQUMsQ0FBQztTQUNoRDtRQUVELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUUxRSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FDaEMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxnQkFBZ0IsQ0FLdEIsRUFBRSxFQUFFO1lBQ0gsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBRXRELElBQUksYUFBYSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQzlCLDREQUE0RDtnQkFDNUQsTUFBTSxDQUFDLElBQUksaUNBQ04sYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsS0FDOUIsS0FBSyxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFDdkIsQ0FBQzthQUNKO2lCQUFNO2dCQUNMLDBCQUEwQjtnQkFDMUIsNENBQTRDO2dCQUM1QyxNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUVwRCxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7b0JBQ2xDLE1BQU0sQ0FBQyxJQUFJLGlDQUNOLFNBQVMsQ0FBQyxVQUFVLEtBQ3ZCLEtBQUssRUFBRSxLQUFLLENBQUMsSUFBSSxDQUNmLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFJLElBQUksRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FDeEQsSUFDRCxDQUFDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2FBQ0o7UUFDSCxDQUFDLENBQ0YsQ0FBQztRQUVGLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7Ozs7WUE1REYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUFKUSxVQUFVO1lBSGpCLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFNjb3BlZERhdGEgfSBmcm9tICcuLi8uLi9tb2RlbC9zY29wZWQtZGF0YSc7XG5pbXBvcnQgeyBtYXAsIHNoYXJlUmVwbGF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZXh0cmFjdEZpZWxkcyB9IGZyb20gJy4uL3V0aWxzL29jYy1maWVsZHMnO1xuaW1wb3J0IHtcbiAgT2NjRmllbGRzTW9kZWwsXG4gIE9jY0ZpZWxkc1NlcnZpY2UsXG4gIFNjb3BlZERhdGFXaXRoVXJsLFxufSBmcm9tICcuL29jYy1maWVsZHMuc2VydmljZSc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgT2NjUmVxdWVzdHNPcHRpbWl6ZXJTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGh0dHA6IEh0dHBDbGllbnQsXG4gICAgcHJvdGVjdGVkIG9jY0ZpZWxkczogT2NjRmllbGRzU2VydmljZVxuICApIHt9XG5cbiAgLyoqXG4gICAqIE9wdGltaXplIG9jYyBlbmRwb2ludCBjYWxscyBtZXJnaW5nIHJlcXVlc3RzIHRvIHRoZSBzYW1lIHVybCBieSBtZXJnaW5nIGZpZWxkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIHNjb3BlZERhdGFXaXRoVXJsc1xuICAgKiBAcGFyYW0gZGF0YUZhY3RvcnlcbiAgICovXG4gIHNjb3BlZERhdGFMb2FkPFQ+KFxuICAgIHNjb3BlZERhdGFXaXRoVXJsczogU2NvcGVkRGF0YVdpdGhVcmxbXSxcbiAgICBkYXRhRmFjdG9yeT86ICh1cmw6IHN0cmluZykgPT4gT2JzZXJ2YWJsZTxUPlxuICApOiBTY29wZWREYXRhPFQ+W10ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKCFkYXRhRmFjdG9yeSkge1xuICAgICAgZGF0YUZhY3RvcnkgPSAodXJsKSA9PiB0aGlzLmh0dHAuZ2V0PGFueT4odXJsKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXJnZWRVcmxzID0gdGhpcy5vY2NGaWVsZHMuZ2V0T3B0aW1hbFVybEdyb3VwcyhzY29wZWREYXRhV2l0aFVybHMpO1xuXG4gICAgT2JqZWN0LmVudHJpZXMobWVyZ2VkVXJscykuZm9yRWFjaChcbiAgICAgIChbdXJsLCBncm91cGVkTW9kZWxzU2V0XTogW1xuICAgICAgICBzdHJpbmcsXG4gICAgICAgIHtcbiAgICAgICAgICBbc2NvcGU6IHN0cmluZ106IE9jY0ZpZWxkc01vZGVsO1xuICAgICAgICB9XG4gICAgICBdKSA9PiB7XG4gICAgICAgIGNvbnN0IGdyb3VwZWRNb2RlbHMgPSBPYmplY3QudmFsdWVzKGdyb3VwZWRNb2RlbHNTZXQpO1xuXG4gICAgICAgIGlmIChncm91cGVkTW9kZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIG9ubHkgb25lIHNjb3BlIGZvciB1cmwsIHdlIGNhbiBwYXNzIHRoZSBkYXRhIHN0cmFpZ2h0YXdheVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmdyb3VwZWRNb2RlbHNbMF0uc2NvcGVkRGF0YSxcbiAgICAgICAgICAgIGRhdGEkOiBkYXRhRmFjdG9yeSh1cmwpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG11bHRpcGxlIHNjb3BlcyBwZXIgdXJsXG4gICAgICAgICAgLy8gd2UgaGF2ZSB0byBzcGxpdCB0aGUgbW9kZWwgcGVyIGVhY2ggc2NvcGVcbiAgICAgICAgICBjb25zdCBkYXRhJCA9IGRhdGFGYWN0b3J5KHVybCkucGlwZShzaGFyZVJlcGxheSgxKSk7XG5cbiAgICAgICAgICBncm91cGVkTW9kZWxzLmZvckVhY2goKG1vZGVsRGF0YSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAuLi5tb2RlbERhdGEuc2NvcGVkRGF0YSxcbiAgICAgICAgICAgICAgZGF0YSQ6IGRhdGEkLnBpcGUoXG4gICAgICAgICAgICAgICAgbWFwKChkYXRhKSA9PiBleHRyYWN0RmllbGRzPFQ+KGRhdGEsIG1vZGVsRGF0YS5maWVsZHMpKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuIl19