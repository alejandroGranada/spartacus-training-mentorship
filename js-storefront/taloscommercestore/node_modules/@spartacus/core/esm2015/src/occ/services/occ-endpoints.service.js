import { HttpParams } from '@angular/common/http';
import { Injectable, isDevMode, Optional } from '@angular/core';
import { StringTemplate } from '../../config/utils/string-template';
import { getContextParameterDefault } from '../../site-context/config/context-config-utils';
import { BaseSiteService } from '../../site-context/facade/base-site.service';
import { BASE_SITE_CONTEXT_ID } from '../../site-context/providers/context-ids';
import { HttpParamsURIEncoder } from '../../util/http-params-uri.encoder';
import { OccConfig } from '../config/occ-config';
import { DEFAULT_SCOPE } from '../occ-models/occ-endpoints.model';
import { urlPathJoin } from '../utils/occ-url-util';
import * as i0 from "@angular/core";
import * as i1 from "../config/occ-config";
import * as i2 from "../../site-context/facade/base-site.service";
export class OccEndpointsService {
    constructor(config, baseSiteService) {
        this.config = config;
        this.baseSiteService = baseSiteService;
        if (this.baseSiteService) {
            this.baseSiteService
                .getActive()
                .subscribe((value) => (this._activeBaseSite = value));
        }
    }
    get activeBaseSite() {
        var _a;
        return ((_a = this._activeBaseSite) !== null && _a !== void 0 ? _a : getContextParameterDefault(this.config, BASE_SITE_CONTEXT_ID));
    }
    /**
     * @Deprecated since 3.2 - use "getRawEndpointValue" or "buildUrl" instead
     *
     * Returns an endpoint starting from the OCC baseUrl (no baseSite)
     * @param endpoint Endpoint suffix
     */
    getRawEndpoint(endpoint) {
        var _a, _b, _c;
        if (!((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.backend) === null || _b === void 0 ? void 0 : _b.occ)) {
            return '';
        }
        endpoint = (_c = this.config.backend.occ.endpoints) === null || _c === void 0 ? void 0 : _c[endpoint];
        if (!endpoint.startsWith('/')) {
            endpoint = '/' + endpoint;
        }
        return this.config.backend.occ.baseUrl + endpoint;
    }
    /**
     * Returns the value configured for a specific endpoint
     *
     * @param endpointKey the configuration key for the endpoint to return
     * @param scope endpoint configuration scope
     */
    getRawEndpointValue(endpoint, scope) {
        const endpointValue = this.getEndpointForScope(endpoint, scope);
        return endpointValue;
    }
    /**
     * Returns true when the endpoint is configured
     *
     * @param endpointKey the configuration key for the endpoint to return
     * @param scope endpoint configuration scope
     */
    isConfigured(endpoint, scope) {
        return !(typeof this.getEndpointFromConfig(endpoint, scope) === 'undefined');
    }
    /**
     * @Deprecated since 3.2 - use "buildUrl" instead
     *
     * Returns an endpoint starting from the OCC prefix (no baseSite), i.e. /occ/v2/{endpoint}
     * Most OCC endpoints are related to a baseSite context and are therefor prefixed
     * with the baseSite. The `/basesites` endpoint does not relate to a specific baseSite
     * as it will load all baseSites.
     *
     * @param endpoint Endpoint suffix
     */
    getOccEndpoint(endpoint) {
        endpoint = this.getRawEndpointValue(endpoint);
        return this.getEndpoint(endpoint, { baseSite: false });
    }
    /**
     * @Deprecated since 3.2 - use "getBaseUrl" with the same parameters
     *
     * Returns base OCC endpoint (baseUrl + prefix + baseSite) by if no parameters are specified
     *
     * @param propertiesToOmit Specify properties to not add to the url (baseUrl, prefix, baseSite)
     */
    getBaseEndpoint(propertiesToOmit) {
        var _a, _b;
        if (!((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.backend) === null || _b === void 0 ? void 0 : _b.occ)) {
            return '';
        }
        return this.getBaseUrl(propertiesToOmit);
    }
    /**
     * @Deprecated since 3.2 - use "buildUrl" with configurable endpoints instead
     *
     * Returns an OCC endpoint including baseUrl and baseSite
     *
     * @param endpoint Endpoint suffix
     * @param propertiesToOmit Specify properties to not add to the url (baseUrl, prefix, baseSite)
     */
    getEndpoint(endpoint, propertiesToOmit) {
        if (!endpoint.startsWith('/') && !this.getPrefix().endsWith('/')) {
            endpoint = '/' + endpoint;
        }
        return this.buildUrlFromEndpointString(endpoint, propertiesToOmit);
    }
    /**
     * Returns base OCC endpoint (baseUrl + prefix + baseSite) base on provided values
     *
     * @param baseUrlProperties Specify properties to not add to the url (baseUrl, prefix, baseSite)
     */
    getBaseUrl(baseUrlProperties = {
        baseUrl: true,
        prefix: true,
        baseSite: true,
    }) {
        const baseUrl = baseUrlProperties.baseUrl === false
            ? ''
            : this.config.backend.occ.baseUrl;
        const prefix = baseUrlProperties.prefix === false ? '' : this.getPrefix();
        const baseSite = baseUrlProperties.baseSite === false ? '' : this.activeBaseSite;
        return urlPathJoin(baseUrl, prefix, baseSite);
    }
    /**
     * Returns a fully qualified OCC Url
     *
     * @param endpoint Name of the OCC endpoint key
     * @param attributes Dynamic attributes used to build the url
     * @param propertiesToOmit Specify properties to not add to the url (baseUrl, prefix, baseSite)
     */
    buildUrl(endpoint, attributes, propertiesToOmit) {
        let url = this.getEndpointForScope(endpoint, attributes === null || attributes === void 0 ? void 0 : attributes.scope);
        if (attributes) {
            const { urlParams, queryParams } = attributes;
            if (urlParams) {
                url = StringTemplate.resolve(url, attributes.urlParams, true);
            }
            if (queryParams) {
                let httpParamsOptions = { encoder: new HttpParamsURIEncoder() };
                if (url.includes('?')) {
                    let queryParamsFromEndpoint;
                    [url, queryParamsFromEndpoint] = url.split('?');
                    httpParamsOptions = Object.assign(Object.assign({}, httpParamsOptions), { fromString: queryParamsFromEndpoint });
                }
                let httpParams = new HttpParams(httpParamsOptions);
                Object.keys(queryParams).forEach((key) => {
                    const value = queryParams[key];
                    if (value !== undefined) {
                        if (value === null) {
                            httpParams = httpParams.delete(key);
                        }
                        else {
                            httpParams = httpParams.set(key, value);
                        }
                    }
                });
                const params = httpParams.toString();
                if (params.length) {
                    url += '?' + params;
                }
            }
        }
        return this.buildUrlFromEndpointString(url, propertiesToOmit);
    }
    /**
     * @Deprecated since 3.2 - use "buildUrl" instead
     *
     * Returns a fully qualified OCC Url (including baseUrl and baseSite)
     * @param endpoint Name of the OCC endpoint key config
     * @param urlParams  URL parameters
     * @param queryParams Query parameters
     * @param scope
     */
    getUrl(endpoint, urlParams, queryParams, scope) {
        endpoint = this.getEndpointForScope(endpoint, scope);
        if (urlParams) {
            Object.keys(urlParams).forEach((key) => {
                urlParams[key] = encodeURIComponent(urlParams[key]);
            });
            endpoint = StringTemplate.resolve(endpoint, urlParams);
        }
        if (queryParams) {
            let httpParamsOptions = { encoder: new HttpParamsURIEncoder() };
            if (endpoint.includes('?')) {
                let queryParamsFromEndpoint;
                [endpoint, queryParamsFromEndpoint] = endpoint.split('?');
                httpParamsOptions = Object.assign(Object.assign({}, httpParamsOptions), { fromString: queryParamsFromEndpoint });
            }
            let httpParams = new HttpParams(httpParamsOptions);
            Object.keys(queryParams).forEach((key) => {
                const value = queryParams[key];
                if (value !== undefined) {
                    if (value === null) {
                        httpParams = httpParams.delete(key);
                    }
                    else {
                        httpParams = httpParams.set(key, value);
                    }
                }
            });
            const params = httpParams.toString();
            if (params.length) {
                endpoint += '?' + params;
            }
        }
        return this.getEndpoint(endpoint);
    }
    getEndpointFromConfig(endpoint, scope) {
        var _a, _b;
        const endpointsConfig = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.occ) === null || _b === void 0 ? void 0 : _b.endpoints;
        if (!endpointsConfig) {
            return undefined;
        }
        const endpointConfig = endpointsConfig[endpoint];
        if (scope) {
            if (scope === DEFAULT_SCOPE && typeof endpointConfig === 'string') {
                return endpointConfig;
            }
            return endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[scope];
        }
        return typeof endpointConfig === 'string'
            ? endpointConfig
            : endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[DEFAULT_SCOPE];
    }
    // TODO: Can we reuse getEndpointFromConfig in this method? Should we change behavior of this function?
    getEndpointForScope(endpoint, scope) {
        var _a, _b;
        const endpointsConfig = (_b = (_a = this.config.backend) === null || _a === void 0 ? void 0 : _a.occ) === null || _b === void 0 ? void 0 : _b.endpoints;
        if (!Boolean(endpointsConfig)) {
            return '';
        }
        const endpointConfig = endpointsConfig[endpoint];
        if (scope) {
            if (endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[scope]) {
                return endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[scope];
            }
            if (scope === DEFAULT_SCOPE && typeof endpointConfig === 'string') {
                return endpointConfig;
            }
            if (isDevMode()) {
                console.warn(`${endpoint} endpoint configuration missing for scope "${scope}"`);
            }
        }
        return ((typeof endpointConfig === 'string'
            ? endpointConfig
            : endpointConfig === null || endpointConfig === void 0 ? void 0 : endpointConfig[DEFAULT_SCOPE]) || endpoint);
    }
    /**
     * Add the base OCC url properties to the specified endpoint string
     *
     * @param endpointString String value for the url endpoint
     * @param propertiesToOmit Specify properties to not add to the url (baseUrl, prefix, baseSite)
     */
    buildUrlFromEndpointString(endpointString, propertiesToOmit) {
        return urlPathJoin(this.getBaseUrl(propertiesToOmit), endpointString);
    }
    getPrefix() {
        var _a, _b, _c;
        if (((_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.backend) === null || _b === void 0 ? void 0 : _b.occ) === null || _c === void 0 ? void 0 : _c.prefix) &&
            !this.config.backend.occ.prefix.startsWith('/')) {
            return '/' + this.config.backend.occ.prefix;
        }
        return this.config.backend.occ.prefix;
    }
}
OccEndpointsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function OccEndpointsService_Factory() { return new OccEndpointsService(i0.ɵɵinject(i1.OccConfig), i0.ɵɵinject(i2.BaseSiteService, 8)); }, token: OccEndpointsService, providedIn: "root" });
OccEndpointsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
OccEndpointsService.ctorParameters = () => [
    { type: OccConfig },
    { type: BaseSiteService, decorators: [{ type: Optional }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NjLWVuZHBvaW50cy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL1BhdHJ5ay9EZXNrdG9wL3NwYXJ0YWN1cy9wcm9qZWN0cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL29jYy9zZXJ2aWNlcy9vY2MtZW5kcG9pbnRzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDcEUsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sZ0RBQWdELENBQUM7QUFDNUYsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQzlFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBQ2hGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQzFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDbEUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7O0FBaUJwRCxNQUFNLE9BQU8sbUJBQW1CO0lBVTlCLFlBQ1UsTUFBaUIsRUFDTCxlQUFnQztRQUQ1QyxXQUFNLEdBQU4sTUFBTSxDQUFXO1FBQ0wsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBRXBELElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN4QixJQUFJLENBQUMsZUFBZTtpQkFDakIsU0FBUyxFQUFFO2lCQUNYLFNBQVMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQyxDQUFD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QjtZQUNELElBQUksU0FBUyxFQUFFLEVBQUU7Z0JBQ2YsT0FBTyxDQUFDLElBQUksQ0FDVixHQUFHLFFBQVEsOENBQThDLEtBQUssR0FBRyxDQUNsRSxDQUFDO2FBQ0g7U0FDRjtRQUVELE9BQU8sQ0FDTCxDQUFDLE9BQU8sY0FBYyxLQUFLLFFBQVE7WUFDakMsQ0FBQyxDQUFDLGNBQWM7WUFDaEIsQ0FBQyxDQUFDLGNBQWMsYUFBZCxjQUFjLHVCQUFkLGNBQWMsQ0FBRyxhQUFhLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FDakQsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLDBCQUEwQixDQUNoQyxjQUFzQixFQUN0QixnQkFBdUM7UUFFdkMsT0FBTyxXQUFXLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFTyxTQUFTOztRQUNmLElBQ0UsbUJBQUEsSUFBSSxDQUFDLE1BQU0sMENBQUUsT0FBTywwQ0FBRSxHQUFHLDBDQUFFLE1BQU07WUFDakMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFDL0M7WUFDQSxPQUFPLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDO1NBQzdDO1FBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDO0lBQ3hDLENBQUM7Ozs7WUF4VUYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUFsQlEsU0FBUztZQUhULGVBQWUsdUJBa0NuQixRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cFBhcmFtcyB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IEluamVjdGFibGUsIGlzRGV2TW9kZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN0cmluZ1RlbXBsYXRlIH0gZnJvbSAnLi4vLi4vY29uZmlnL3V0aWxzL3N0cmluZy10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBnZXRDb250ZXh0UGFyYW1ldGVyRGVmYXVsdCB9IGZyb20gJy4uLy4uL3NpdGUtY29udGV4dC9jb25maWcvY29udGV4dC1jb25maWctdXRpbHMnO1xuaW1wb3J0IHsgQmFzZVNpdGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2l0ZS1jb250ZXh0L2ZhY2FkZS9iYXNlLXNpdGUuc2VydmljZSc7XG5pbXBvcnQgeyBCQVNFX1NJVEVfQ09OVEVYVF9JRCB9IGZyb20gJy4uLy4uL3NpdGUtY29udGV4dC9wcm92aWRlcnMvY29udGV4dC1pZHMnO1xuaW1wb3J0IHsgSHR0cFBhcmFtc1VSSUVuY29kZXIgfSBmcm9tICcuLi8uLi91dGlsL2h0dHAtcGFyYW1zLXVyaS5lbmNvZGVyJztcbmltcG9ydCB7IE9jY0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9vY2MtY29uZmlnJztcbmltcG9ydCB7IERFRkFVTFRfU0NPUEUgfSBmcm9tICcuLi9vY2MtbW9kZWxzL29jYy1lbmRwb2ludHMubW9kZWwnO1xuaW1wb3J0IHsgdXJsUGF0aEpvaW4gfSBmcm9tICcuLi91dGlscy9vY2MtdXJsLXV0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2VPY2NVcmxQcm9wZXJ0aWVzIHtcbiAgYmFzZVVybD86IGJvb2xlYW47XG4gIHByZWZpeD86IGJvb2xlYW47XG4gIGJhc2VTaXRlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEeW5hbWljQXR0cmlidXRlcyB7XG4gIHVybFBhcmFtcz86IG9iamVjdDtcbiAgcXVlcnlQYXJhbXM/OiBvYmplY3Q7XG4gIHNjb3BlPzogc3RyaW5nO1xufVxuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgT2NjRW5kcG9pbnRzU2VydmljZSB7XG4gIHByaXZhdGUgX2FjdGl2ZUJhc2VTaXRlOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBnZXQgYWN0aXZlQmFzZVNpdGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fYWN0aXZlQmFzZVNpdGUgPz9cbiAgICAgIGdldENvbnRleHRQYXJhbWV0ZXJEZWZhdWx0KHRoaXMuY29uZmlnLCBCQVNFX1NJVEVfQ09OVEVYVF9JRClcbiAgICApO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb25maWc6IE9jY0NvbmZpZyxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGJhc2VTaXRlU2VydmljZTogQmFzZVNpdGVTZXJ2aWNlXG4gICkge1xuICAgIGlmICh0aGlzLmJhc2VTaXRlU2VydmljZSkge1xuICAgICAgdGhpcy5iYXNlU2l0ZVNlcnZpY2VcbiAgICAgICAgLmdldEFjdGl2ZSgpXG4gICAgICAgIC5zdWJzY3JpYmUoKHZhbHVlKSA9PiAodGhpcy5fYWN0aXZlQmFzZVNpdGUgPSB2YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBARGVwcmVjYXRlZCBzaW5jZSAzLjIgLSB1c2UgXCJnZXRSYXdFbmRwb2ludFZhbHVlXCIgb3IgXCJidWlsZFVybFwiIGluc3RlYWRcbiAgICpcbiAgICogUmV0dXJucyBhbiBlbmRwb2ludCBzdGFydGluZyBmcm9tIHRoZSBPQ0MgYmFzZVVybCAobm8gYmFzZVNpdGUpXG4gICAqIEBwYXJhbSBlbmRwb2ludCBFbmRwb2ludCBzdWZmaXhcbiAgICovXG4gIGdldFJhd0VuZHBvaW50KGVuZHBvaW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5jb25maWc/LmJhY2tlbmQ/Lm9jYykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBlbmRwb2ludCA9IHRoaXMuY29uZmlnLmJhY2tlbmQub2NjLmVuZHBvaW50cz8uW2VuZHBvaW50XTtcblxuICAgIGlmICghZW5kcG9pbnQuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICBlbmRwb2ludCA9ICcvJyArIGVuZHBvaW50O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbmZpZy5iYWNrZW5kLm9jYy5iYXNlVXJsICsgZW5kcG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgY29uZmlndXJlZCBmb3IgYSBzcGVjaWZpYyBlbmRwb2ludFxuICAgKlxuICAgKiBAcGFyYW0gZW5kcG9pbnRLZXkgdGhlIGNvbmZpZ3VyYXRpb24ga2V5IGZvciB0aGUgZW5kcG9pbnQgdG8gcmV0dXJuXG4gICAqIEBwYXJhbSBzY29wZSBlbmRwb2ludCBjb25maWd1cmF0aW9uIHNjb3BlXG4gICAqL1xuICBnZXRSYXdFbmRwb2ludFZhbHVlKGVuZHBvaW50OiBzdHJpbmcsIHNjb3BlPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBlbmRwb2ludFZhbHVlID0gdGhpcy5nZXRFbmRwb2ludEZvclNjb3BlKGVuZHBvaW50LCBzY29wZSk7XG5cbiAgICByZXR1cm4gZW5kcG9pbnRWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZW5kcG9pbnQgaXMgY29uZmlndXJlZFxuICAgKlxuICAgKiBAcGFyYW0gZW5kcG9pbnRLZXkgdGhlIGNvbmZpZ3VyYXRpb24ga2V5IGZvciB0aGUgZW5kcG9pbnQgdG8gcmV0dXJuXG4gICAqIEBwYXJhbSBzY29wZSBlbmRwb2ludCBjb25maWd1cmF0aW9uIHNjb3BlXG4gICAqL1xuICBpc0NvbmZpZ3VyZWQoZW5kcG9pbnQ6IHN0cmluZywgc2NvcGU/OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIShcbiAgICAgIHR5cGVvZiB0aGlzLmdldEVuZHBvaW50RnJvbUNvbmZpZyhlbmRwb2ludCwgc2NvcGUpID09PSAndW5kZWZpbmVkJ1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQERlcHJlY2F0ZWQgc2luY2UgMy4yIC0gdXNlIFwiYnVpbGRVcmxcIiBpbnN0ZWFkXG4gICAqXG4gICAqIFJldHVybnMgYW4gZW5kcG9pbnQgc3RhcnRpbmcgZnJvbSB0aGUgT0NDIHByZWZpeCAobm8gYmFzZVNpdGUpLCBpLmUuIC9vY2MvdjIve2VuZHBvaW50fVxuICAgKiBNb3N0IE9DQyBlbmRwb2ludHMgYXJlIHJlbGF0ZWQgdG8gYSBiYXNlU2l0ZSBjb250ZXh0IGFuZCBhcmUgdGhlcmVmb3IgcHJlZml4ZWRcbiAgICogd2l0aCB0aGUgYmFzZVNpdGUuIFRoZSBgL2Jhc2VzaXRlc2AgZW5kcG9pbnQgZG9lcyBub3QgcmVsYXRlIHRvIGEgc3BlY2lmaWMgYmFzZVNpdGVcbiAgICogYXMgaXQgd2lsbCBsb2FkIGFsbCBiYXNlU2l0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludCBFbmRwb2ludCBzdWZmaXhcbiAgICovXG4gIGdldE9jY0VuZHBvaW50KGVuZHBvaW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGVuZHBvaW50ID0gdGhpcy5nZXRSYXdFbmRwb2ludFZhbHVlKGVuZHBvaW50KTtcblxuICAgIHJldHVybiB0aGlzLmdldEVuZHBvaW50KGVuZHBvaW50LCB7IGJhc2VTaXRlOiBmYWxzZSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBARGVwcmVjYXRlZCBzaW5jZSAzLjIgLSB1c2UgXCJnZXRCYXNlVXJsXCIgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIFJldHVybnMgYmFzZSBPQ0MgZW5kcG9pbnQgKGJhc2VVcmwgKyBwcmVmaXggKyBiYXNlU2l0ZSkgYnkgaWYgbm8gcGFyYW1ldGVycyBhcmUgc3BlY2lmaWVkXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wZXJ0aWVzVG9PbWl0IFNwZWNpZnkgcHJvcGVydGllcyB0byBub3QgYWRkIHRvIHRoZSB1cmwgKGJhc2VVcmwsIHByZWZpeCwgYmFzZVNpdGUpXG4gICAqL1xuICBnZXRCYXNlRW5kcG9pbnQocHJvcGVydGllc1RvT21pdD86IEJhc2VPY2NVcmxQcm9wZXJ0aWVzKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnPy5iYWNrZW5kPy5vY2MpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRCYXNlVXJsKHByb3BlcnRpZXNUb09taXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBEZXByZWNhdGVkIHNpbmNlIDMuMiAtIHVzZSBcImJ1aWxkVXJsXCIgd2l0aCBjb25maWd1cmFibGUgZW5kcG9pbnRzIGluc3RlYWRcbiAgICpcbiAgICogUmV0dXJucyBhbiBPQ0MgZW5kcG9pbnQgaW5jbHVkaW5nIGJhc2VVcmwgYW5kIGJhc2VTaXRlXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludCBFbmRwb2ludCBzdWZmaXhcbiAgICogQHBhcmFtIHByb3BlcnRpZXNUb09taXQgU3BlY2lmeSBwcm9wZXJ0aWVzIHRvIG5vdCBhZGQgdG8gdGhlIHVybCAoYmFzZVVybCwgcHJlZml4LCBiYXNlU2l0ZSlcbiAgICovXG4gIGdldEVuZHBvaW50KFxuICAgIGVuZHBvaW50OiBzdHJpbmcsXG4gICAgcHJvcGVydGllc1RvT21pdD86IEJhc2VPY2NVcmxQcm9wZXJ0aWVzXG4gICk6IHN0cmluZyB7XG4gICAgaWYgKCFlbmRwb2ludC5zdGFydHNXaXRoKCcvJykgJiYgIXRoaXMuZ2V0UHJlZml4KCkuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgZW5kcG9pbnQgPSAnLycgKyBlbmRwb2ludDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxGcm9tRW5kcG9pbnRTdHJpbmcoZW5kcG9pbnQsIHByb3BlcnRpZXNUb09taXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYmFzZSBPQ0MgZW5kcG9pbnQgKGJhc2VVcmwgKyBwcmVmaXggKyBiYXNlU2l0ZSkgYmFzZSBvbiBwcm92aWRlZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIGJhc2VVcmxQcm9wZXJ0aWVzIFNwZWNpZnkgcHJvcGVydGllcyB0byBub3QgYWRkIHRvIHRoZSB1cmwgKGJhc2VVcmwsIHByZWZpeCwgYmFzZVNpdGUpXG4gICAqL1xuICBnZXRCYXNlVXJsKFxuICAgIGJhc2VVcmxQcm9wZXJ0aWVzOiBCYXNlT2NjVXJsUHJvcGVydGllcyA9IHtcbiAgICAgIGJhc2VVcmw6IHRydWUsXG4gICAgICBwcmVmaXg6IHRydWUsXG4gICAgICBiYXNlU2l0ZTogdHJ1ZSxcbiAgICB9XG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgYmFzZVVybCA9XG4gICAgICBiYXNlVXJsUHJvcGVydGllcy5iYXNlVXJsID09PSBmYWxzZVxuICAgICAgICA/ICcnXG4gICAgICAgIDogdGhpcy5jb25maWcuYmFja2VuZC5vY2MuYmFzZVVybDtcbiAgICBjb25zdCBwcmVmaXggPSBiYXNlVXJsUHJvcGVydGllcy5wcmVmaXggPT09IGZhbHNlID8gJycgOiB0aGlzLmdldFByZWZpeCgpO1xuICAgIGNvbnN0IGJhc2VTaXRlID1cbiAgICAgIGJhc2VVcmxQcm9wZXJ0aWVzLmJhc2VTaXRlID09PSBmYWxzZSA/ICcnIDogdGhpcy5hY3RpdmVCYXNlU2l0ZTtcblxuICAgIHJldHVybiB1cmxQYXRoSm9pbihiYXNlVXJsLCBwcmVmaXgsIGJhc2VTaXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVsbHkgcXVhbGlmaWVkIE9DQyBVcmxcbiAgICpcbiAgICogQHBhcmFtIGVuZHBvaW50IE5hbWUgb2YgdGhlIE9DQyBlbmRwb2ludCBrZXlcbiAgICogQHBhcmFtIGF0dHJpYnV0ZXMgRHluYW1pYyBhdHRyaWJ1dGVzIHVzZWQgdG8gYnVpbGQgdGhlIHVybFxuICAgKiBAcGFyYW0gcHJvcGVydGllc1RvT21pdCBTcGVjaWZ5IHByb3BlcnRpZXMgdG8gbm90IGFkZCB0byB0aGUgdXJsIChiYXNlVXJsLCBwcmVmaXgsIGJhc2VTaXRlKVxuICAgKi9cbiAgYnVpbGRVcmwoXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICBhdHRyaWJ1dGVzPzogRHluYW1pY0F0dHJpYnV0ZXMsXG4gICAgcHJvcGVydGllc1RvT21pdD86IEJhc2VPY2NVcmxQcm9wZXJ0aWVzXG4gICk6IHN0cmluZyB7XG4gICAgbGV0IHVybCA9IHRoaXMuZ2V0RW5kcG9pbnRGb3JTY29wZShlbmRwb2ludCwgYXR0cmlidXRlcz8uc2NvcGUpO1xuXG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHsgdXJsUGFyYW1zLCBxdWVyeVBhcmFtcyB9ID0gYXR0cmlidXRlcztcblxuICAgICAgaWYgKHVybFBhcmFtcykge1xuICAgICAgICB1cmwgPSBTdHJpbmdUZW1wbGF0ZS5yZXNvbHZlKHVybCwgYXR0cmlidXRlcy51cmxQYXJhbXMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocXVlcnlQYXJhbXMpIHtcbiAgICAgICAgbGV0IGh0dHBQYXJhbXNPcHRpb25zID0geyBlbmNvZGVyOiBuZXcgSHR0cFBhcmFtc1VSSUVuY29kZXIoKSB9O1xuXG4gICAgICAgIGlmICh1cmwuaW5jbHVkZXMoJz8nKSkge1xuICAgICAgICAgIGxldCBxdWVyeVBhcmFtc0Zyb21FbmRwb2ludDogc3RyaW5nO1xuICAgICAgICAgIFt1cmwsIHF1ZXJ5UGFyYW1zRnJvbUVuZHBvaW50XSA9IHVybC5zcGxpdCgnPycpO1xuICAgICAgICAgIGh0dHBQYXJhbXNPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4uaHR0cFBhcmFtc09wdGlvbnMsXG4gICAgICAgICAgICAuLi57IGZyb21TdHJpbmc6IHF1ZXJ5UGFyYW1zRnJvbUVuZHBvaW50IH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBodHRwUGFyYW1zID0gbmV3IEh0dHBQYXJhbXMoaHR0cFBhcmFtc09wdGlvbnMpO1xuICAgICAgICBPYmplY3Qua2V5cyhxdWVyeVBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVBhcmFtc1trZXldO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaHR0cFBhcmFtcyA9IGh0dHBQYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBodHRwUGFyYW1zID0gaHR0cFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBwYXJhbXMgPSBodHRwUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgdXJsICs9ICc/JyArIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJ1aWxkVXJsRnJvbUVuZHBvaW50U3RyaW5nKHVybCwgcHJvcGVydGllc1RvT21pdCk7XG4gIH1cblxuICAvKipcbiAgICogQERlcHJlY2F0ZWQgc2luY2UgMy4yIC0gdXNlIFwiYnVpbGRVcmxcIiBpbnN0ZWFkXG4gICAqXG4gICAqIFJldHVybnMgYSBmdWxseSBxdWFsaWZpZWQgT0NDIFVybCAoaW5jbHVkaW5nIGJhc2VVcmwgYW5kIGJhc2VTaXRlKVxuICAgKiBAcGFyYW0gZW5kcG9pbnQgTmFtZSBvZiB0aGUgT0NDIGVuZHBvaW50IGtleSBjb25maWdcbiAgICogQHBhcmFtIHVybFBhcmFtcyAgVVJMIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHF1ZXJ5UGFyYW1zIFF1ZXJ5IHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHNjb3BlXG4gICAqL1xuICBnZXRVcmwoXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICB1cmxQYXJhbXM/OiBvYmplY3QsXG4gICAgcXVlcnlQYXJhbXM/OiBvYmplY3QsXG4gICAgc2NvcGU/OiBzdHJpbmdcbiAgKTogc3RyaW5nIHtcbiAgICBlbmRwb2ludCA9IHRoaXMuZ2V0RW5kcG9pbnRGb3JTY29wZShlbmRwb2ludCwgc2NvcGUpO1xuXG4gICAgaWYgKHVybFBhcmFtcykge1xuICAgICAgT2JqZWN0LmtleXModXJsUGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgdXJsUGFyYW1zW2tleV0gPSBlbmNvZGVVUklDb21wb25lbnQodXJsUGFyYW1zW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBlbmRwb2ludCA9IFN0cmluZ1RlbXBsYXRlLnJlc29sdmUoZW5kcG9pbnQsIHVybFBhcmFtcyk7XG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5UGFyYW1zKSB7XG4gICAgICBsZXQgaHR0cFBhcmFtc09wdGlvbnMgPSB7IGVuY29kZXI6IG5ldyBIdHRwUGFyYW1zVVJJRW5jb2RlcigpIH07XG5cbiAgICAgIGlmIChlbmRwb2ludC5pbmNsdWRlcygnPycpKSB7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtc0Zyb21FbmRwb2ludDogc3RyaW5nO1xuICAgICAgICBbZW5kcG9pbnQsIHF1ZXJ5UGFyYW1zRnJvbUVuZHBvaW50XSA9IGVuZHBvaW50LnNwbGl0KCc/Jyk7XG5cbiAgICAgICAgaHR0cFBhcmFtc09wdGlvbnMgPSB7XG4gICAgICAgICAgLi4uaHR0cFBhcmFtc09wdGlvbnMsXG4gICAgICAgICAgLi4ueyBmcm9tU3RyaW5nOiBxdWVyeVBhcmFtc0Zyb21FbmRwb2ludCB9LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgaHR0cFBhcmFtcyA9IG5ldyBIdHRwUGFyYW1zKGh0dHBQYXJhbXNPcHRpb25zKTtcbiAgICAgIE9iamVjdC5rZXlzKHF1ZXJ5UGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVBhcmFtc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaHR0cFBhcmFtcyA9IGh0dHBQYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0dHBQYXJhbXMgPSBodHRwUGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwYXJhbXMgPSBodHRwUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCkge1xuICAgICAgICBlbmRwb2ludCArPSAnPycgKyBwYXJhbXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0RW5kcG9pbnQoZW5kcG9pbnQpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRFbmRwb2ludEZyb21Db25maWcoXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICBzY29wZT86IHN0cmluZ1xuICApOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGVuZHBvaW50c0NvbmZpZyA9IHRoaXMuY29uZmlnLmJhY2tlbmQ/Lm9jYz8uZW5kcG9pbnRzO1xuXG4gICAgaWYgKCFlbmRwb2ludHNDb25maWcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kcG9pbnRDb25maWcgPSBlbmRwb2ludHNDb25maWdbZW5kcG9pbnRdO1xuXG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBpZiAoc2NvcGUgPT09IERFRkFVTFRfU0NPUEUgJiYgdHlwZW9mIGVuZHBvaW50Q29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZW5kcG9pbnRDb25maWc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5kcG9pbnRDb25maWc/LltzY29wZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmRwb2ludENvbmZpZyA9PT0gJ3N0cmluZydcbiAgICAgID8gZW5kcG9pbnRDb25maWdcbiAgICAgIDogZW5kcG9pbnRDb25maWc/LltERUZBVUxUX1NDT1BFXTtcbiAgfVxuXG4gIC8vIFRPRE86IENhbiB3ZSByZXVzZSBnZXRFbmRwb2ludEZyb21Db25maWcgaW4gdGhpcyBtZXRob2Q/IFNob3VsZCB3ZSBjaGFuZ2UgYmVoYXZpb3Igb2YgdGhpcyBmdW5jdGlvbj9cbiAgcHJpdmF0ZSBnZXRFbmRwb2ludEZvclNjb3BlKGVuZHBvaW50OiBzdHJpbmcsIHNjb3BlPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBlbmRwb2ludHNDb25maWcgPSB0aGlzLmNvbmZpZy5iYWNrZW5kPy5vY2M/LmVuZHBvaW50cztcblxuICAgIGlmICghQm9vbGVhbihlbmRwb2ludHNDb25maWcpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kcG9pbnRDb25maWcgPSBlbmRwb2ludHNDb25maWdbZW5kcG9pbnRdO1xuXG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBpZiAoZW5kcG9pbnRDb25maWc/LltzY29wZV0pIHtcbiAgICAgICAgcmV0dXJuIGVuZHBvaW50Q29uZmlnPy5bc2NvcGVdO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlID09PSBERUZBVUxUX1NDT1BFICYmIHR5cGVvZiBlbmRwb2ludENvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVuZHBvaW50Q29uZmlnO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgJHtlbmRwb2ludH0gZW5kcG9pbnQgY29uZmlndXJhdGlvbiBtaXNzaW5nIGZvciBzY29wZSBcIiR7c2NvcGV9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICh0eXBlb2YgZW5kcG9pbnRDb25maWcgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZW5kcG9pbnRDb25maWdcbiAgICAgICAgOiBlbmRwb2ludENvbmZpZz8uW0RFRkFVTFRfU0NPUEVdKSB8fCBlbmRwb2ludFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSBiYXNlIE9DQyB1cmwgcHJvcGVydGllcyB0byB0aGUgc3BlY2lmaWVkIGVuZHBvaW50IHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0gZW5kcG9pbnRTdHJpbmcgU3RyaW5nIHZhbHVlIGZvciB0aGUgdXJsIGVuZHBvaW50XG4gICAqIEBwYXJhbSBwcm9wZXJ0aWVzVG9PbWl0IFNwZWNpZnkgcHJvcGVydGllcyB0byBub3QgYWRkIHRvIHRoZSB1cmwgKGJhc2VVcmwsIHByZWZpeCwgYmFzZVNpdGUpXG4gICAqL1xuICBwcml2YXRlIGJ1aWxkVXJsRnJvbUVuZHBvaW50U3RyaW5nKFxuICAgIGVuZHBvaW50U3RyaW5nOiBzdHJpbmcsXG4gICAgcHJvcGVydGllc1RvT21pdD86IEJhc2VPY2NVcmxQcm9wZXJ0aWVzXG4gICk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHVybFBhdGhKb2luKHRoaXMuZ2V0QmFzZVVybChwcm9wZXJ0aWVzVG9PbWl0KSwgZW5kcG9pbnRTdHJpbmcpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRQcmVmaXgoKTogc3RyaW5nIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmNvbmZpZz8uYmFja2VuZD8ub2NjPy5wcmVmaXggJiZcbiAgICAgICF0aGlzLmNvbmZpZy5iYWNrZW5kLm9jYy5wcmVmaXguc3RhcnRzV2l0aCgnLycpXG4gICAgKSB7XG4gICAgICByZXR1cm4gJy8nICsgdGhpcy5jb25maWcuYmFja2VuZC5vY2MucHJlZml4O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25maWcuYmFja2VuZC5vY2MucHJlZml4O1xuICB9XG59XG4iXX0=