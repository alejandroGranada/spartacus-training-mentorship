import { Injectable } from '@angular/core';
import { LazyModulesService } from './lazy-modules.service';
import { defer, forkJoin, of, throwError } from 'rxjs';
import { shareReplay, switchMap } from 'rxjs/operators';
import { CmsConfig } from '../cms/config/cms-config';
import * as i0 from "@angular/core";
import * as i1 from "../cms/config/cms-config";
import * as i2 from "./lazy-modules.service";
export class FeatureModulesService {
    constructor(cmsConfig, lazyModules) {
        this.cmsConfig = cmsConfig;
        this.lazyModules = lazyModules;
        /*
         * Contains resolvers for features.
         * Each resolver runs only once and caches the result.
         */
        this.features = new Map();
    }
    /**
     * Check if feature is configured properly by providing module the shell app
     *
     * @param featureName
     */
    isConfigured(featureName) {
        var _a;
        return !!((_a = this.getFeatureConfig(featureName)) === null || _a === void 0 ? void 0 : _a.module);
    }
    /**
     * Resolve feature based on feature name, if feature was not yet resolved
     *
     * It will first resolve all module dependencies if defined
     */
    resolveFeature(featureName) {
        featureName = this.resolveFeatureAlias(featureName);
        return defer(() => {
            if (!this.features.has(featureName)) {
                if (!this.isConfigured(featureName)) {
                    return throwError(new Error('No module defined for Feature Module ' + featureName));
                }
                const featureConfig = this.getFeatureConfig(featureName);
                this.features.set(featureName, this.resolveDependencies(featureConfig.dependencies).pipe(switchMap((deps) => this.lazyModules.resolveModuleInstance(featureConfig.module, featureName, deps)), shareReplay()));
            }
            return this.features.get(featureName);
        });
    }
    /**
     * Resolve
     * @param featureName
     * @protected
     */
    getFeatureConfig(featureName) {
        var _a;
        return (_a = this.cmsConfig.featureModules) === null || _a === void 0 ? void 0 : _a[this.resolveFeatureAlias(featureName)];
    }
    /**
     * Will return target feature name, resolving optional feature to feature
     * string mapping
     *
     * @param featureName
     * @protected
     */
    resolveFeatureAlias(featureName) {
        var _a, _b;
        while (typeof ((_a = this.cmsConfig.featureModules) === null || _a === void 0 ? void 0 : _a[featureName]) === 'string') {
            featureName = (_b = this.cmsConfig.featureModules) === null || _b === void 0 ? void 0 : _b[featureName];
        }
        return featureName;
    }
    /**
     * Resolve dependency modules for the feature
     *
     * @param dependencies
     * @protected
     */
    resolveDependencies(dependencies = []) {
        return (dependencies === null || dependencies === void 0 ? void 0 : dependencies.length) ? forkJoin(dependencies.map((dependency) => {
            if (typeof dependency === 'string') {
                // dependency is a feature, referenced by a feature name
                return this.resolveFeature(dependency);
            }
            // resolve dependency from a module function
            return this.lazyModules.resolveDependencyModuleInstance(dependency);
        }))
            : of(undefined);
    }
}
FeatureModulesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function FeatureModulesService_Factory() { return new FeatureModulesService(i0.ɵɵinject(i1.CmsConfig), i0.ɵɵinject(i2.LazyModulesService)); }, token: FeatureModulesService, providedIn: "root" });
FeatureModulesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
FeatureModulesService.ctorParameters = () => [
    { type: CmsConfig },
    { type: LazyModulesService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmVhdHVyZS1tb2R1bGVzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiQzovVXNlcnMvUGF0cnlrL0Rlc2t0b3Avc3BhcnRhY3VzL3Byb2plY3RzL2NvcmUvIiwic291cmNlcyI6WyJzcmMvbGF6eS1sb2FkaW5nL2ZlYXR1cmUtbW9kdWxlcy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQWUsTUFBTSxlQUFlLENBQUM7QUFDeEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDNUQsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQWMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxTQUFTLEVBQXVCLE1BQU0sMEJBQTBCLENBQUM7Ozs7QUFLMUUsTUFBTSxPQUFPLHFCQUFxQjtJQU9oQyxZQUNZLFNBQW9CLEVBQ3BCLFdBQStCO1FBRC9CLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFDcEIsZ0JBQVcsR0FBWCxXQUFXLENBQW9CO1FBUjNDOzs7V0FHRztRQUNLLGFBQVEsR0FBOEMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUtyRSxDQUFDO0lBRUo7Ozs7T0FJRztJQUNILFlBQVksQ0FBQyxXQUFtQjs7UUFDOUIsT0FBTyxDQUFDLFFBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQywwQ0FBRSxNQUFNLENBQUEsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGNBQWMsQ0FBQyxXQUFtQjtRQUNoQyxXQUFXLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXBELE9BQU8sS0FBSyxDQUFDLEdBQUcsRUFBRTtZQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxFQUFFO29CQUNuQyxPQUFPLFVBQVUsQ0FDZixJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsR0FBRyxXQUFXLENBQUMsQ0FDakUsQ0FBQztpQkFDSDtnQkFFRCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBRXpELElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUNmLFdBQVcsRUFDWCxJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FDdkQsU0FBUyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FDakIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxxQkFBcUIsQ0FDcEMsYUFBYSxDQUFDLE1BQU0sRUFDcEIsV0FBVyxFQUNYLElBQUksQ0FDTCxDQUNGLEVBQ0QsV0FBVyxFQUFFLENBQ2QsQ0FDRixDQUFDO2FBQ0g7WUFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3hDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxnQkFBZ0IsQ0FDeEIsV0FBbUI7O1FBRW5CLE9BQU8sTUFBQSxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsMENBQ2xDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsQ0FDSCxDQUFDO0lBQ3ZDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDTyxtQkFBbUIsQ0FBQyxXQUFtQjs7UUFDL0MsT0FBTyxjQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYywwQ0FBRyxXQUFXLEVBQUMsS0FBSyxRQUFRLEVBQUU7WUFDdkUsV0FBVyxHQUFHLE1BQUEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLDBDQUFHLFdBQVcsQ0FBVyxDQUFDO1NBQ3RFO1FBQ0QsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ08sbUJBQW1CLENBQzNCLGVBQXNCLEVBQUU7UUFFeEIsT0FBTyxDQUFBLFlBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRSxNQUFNLEVBQ3pCLENBQUMsQ0FBQyxRQUFRLENBQ04sWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQzlCLElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxFQUFFO2dCQUNsQyx3REFBd0Q7Z0JBQ3hELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUN4QztZQUNELDRDQUE0QztZQUM1QyxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsK0JBQStCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdEUsQ0FBQyxDQUFDLENBQ0g7WUFDSCxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BCLENBQUM7Ozs7WUE3R0YsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUFKUSxTQUFTO1lBSFQsa0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdNb2R1bGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExhenlNb2R1bGVzU2VydmljZSB9IGZyb20gJy4vbGF6eS1tb2R1bGVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgZGVmZXIsIGZvcmtKb2luLCBPYnNlcnZhYmxlLCBvZiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc2hhcmVSZXBsYXksIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENtc0NvbmZpZywgRmVhdHVyZU1vZHVsZUNvbmZpZyB9IGZyb20gJy4uL2Ntcy9jb25maWcvY21zLWNvbmZpZyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBGZWF0dXJlTW9kdWxlc1NlcnZpY2Uge1xuICAvKlxuICAgKiBDb250YWlucyByZXNvbHZlcnMgZm9yIGZlYXR1cmVzLlxuICAgKiBFYWNoIHJlc29sdmVyIHJ1bnMgb25seSBvbmNlIGFuZCBjYWNoZXMgdGhlIHJlc3VsdC5cbiAgICovXG4gIHByaXZhdGUgZmVhdHVyZXM6IE1hcDxzdHJpbmcsIE9ic2VydmFibGU8TmdNb2R1bGVSZWY8YW55Pj4+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBjbXNDb25maWc6IENtc0NvbmZpZyxcbiAgICBwcm90ZWN0ZWQgbGF6eU1vZHVsZXM6IExhenlNb2R1bGVzU2VydmljZVxuICApIHt9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGZlYXR1cmUgaXMgY29uZmlndXJlZCBwcm9wZXJseSBieSBwcm92aWRpbmcgbW9kdWxlIHRoZSBzaGVsbCBhcHBcbiAgICpcbiAgICogQHBhcmFtIGZlYXR1cmVOYW1lXG4gICAqL1xuICBpc0NvbmZpZ3VyZWQoZmVhdHVyZU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0RmVhdHVyZUNvbmZpZyhmZWF0dXJlTmFtZSk/Lm1vZHVsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGZlYXR1cmUgYmFzZWQgb24gZmVhdHVyZSBuYW1lLCBpZiBmZWF0dXJlIHdhcyBub3QgeWV0IHJlc29sdmVkXG4gICAqXG4gICAqIEl0IHdpbGwgZmlyc3QgcmVzb2x2ZSBhbGwgbW9kdWxlIGRlcGVuZGVuY2llcyBpZiBkZWZpbmVkXG4gICAqL1xuICByZXNvbHZlRmVhdHVyZShmZWF0dXJlTmFtZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxOZ01vZHVsZVJlZjxhbnk+PiB7XG4gICAgZmVhdHVyZU5hbWUgPSB0aGlzLnJlc29sdmVGZWF0dXJlQWxpYXMoZmVhdHVyZU5hbWUpO1xuXG4gICAgcmV0dXJuIGRlZmVyKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5mZWF0dXJlcy5oYXMoZmVhdHVyZU5hbWUpKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbmZpZ3VyZWQoZmVhdHVyZU5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ05vIG1vZHVsZSBkZWZpbmVkIGZvciBGZWF0dXJlIE1vZHVsZSAnICsgZmVhdHVyZU5hbWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZlYXR1cmVDb25maWcgPSB0aGlzLmdldEZlYXR1cmVDb25maWcoZmVhdHVyZU5hbWUpO1xuXG4gICAgICAgIHRoaXMuZmVhdHVyZXMuc2V0KFxuICAgICAgICAgIGZlYXR1cmVOYW1lLFxuICAgICAgICAgIHRoaXMucmVzb2x2ZURlcGVuZGVuY2llcyhmZWF0dXJlQ29uZmlnLmRlcGVuZGVuY2llcykucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoZGVwcykgPT5cbiAgICAgICAgICAgICAgdGhpcy5sYXp5TW9kdWxlcy5yZXNvbHZlTW9kdWxlSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgZmVhdHVyZUNvbmZpZy5tb2R1bGUsXG4gICAgICAgICAgICAgICAgZmVhdHVyZU5hbWUsXG4gICAgICAgICAgICAgICAgZGVwc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgc2hhcmVSZXBsYXkoKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXMuZ2V0KGZlYXR1cmVOYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlXG4gICAqIEBwYXJhbSBmZWF0dXJlTmFtZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0RmVhdHVyZUNvbmZpZyhcbiAgICBmZWF0dXJlTmFtZTogc3RyaW5nXG4gICk6IEZlYXR1cmVNb2R1bGVDb25maWcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmNtc0NvbmZpZy5mZWF0dXJlTW9kdWxlcz8uW1xuICAgICAgdGhpcy5yZXNvbHZlRmVhdHVyZUFsaWFzKGZlYXR1cmVOYW1lKVxuICAgIF0gYXMgRmVhdHVyZU1vZHVsZUNvbmZpZyB8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiB0YXJnZXQgZmVhdHVyZSBuYW1lLCByZXNvbHZpbmcgb3B0aW9uYWwgZmVhdHVyZSB0byBmZWF0dXJlXG4gICAqIHN0cmluZyBtYXBwaW5nXG4gICAqXG4gICAqIEBwYXJhbSBmZWF0dXJlTmFtZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVzb2x2ZUZlYXR1cmVBbGlhcyhmZWF0dXJlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICB3aGlsZSAodHlwZW9mIHRoaXMuY21zQ29uZmlnLmZlYXR1cmVNb2R1bGVzPy5bZmVhdHVyZU5hbWVdID09PSAnc3RyaW5nJykge1xuICAgICAgZmVhdHVyZU5hbWUgPSB0aGlzLmNtc0NvbmZpZy5mZWF0dXJlTW9kdWxlcz8uW2ZlYXR1cmVOYW1lXSBhcyBzdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlTmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGRlcGVuZGVuY3kgbW9kdWxlcyBmb3IgdGhlIGZlYXR1cmVcbiAgICpcbiAgICogQHBhcmFtIGRlcGVuZGVuY2llc1xuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVzb2x2ZURlcGVuZGVuY2llcyhcbiAgICBkZXBlbmRlbmNpZXM6IGFueVtdID0gW11cbiAgKTogT2JzZXJ2YWJsZTxOZ01vZHVsZVJlZjxhbnk+W10gfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzPy5sZW5ndGhcbiAgICAgID8gZm9ya0pvaW4oXG4gICAgICAgICAgZGVwZW5kZW5jaWVzLm1hcCgoZGVwZW5kZW5jeSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXBlbmRlbmN5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAvLyBkZXBlbmRlbmN5IGlzIGEgZmVhdHVyZSwgcmVmZXJlbmNlZCBieSBhIGZlYXR1cmUgbmFtZVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlRmVhdHVyZShkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlc29sdmUgZGVwZW5kZW5jeSBmcm9tIGEgbW9kdWxlIGZ1bmN0aW9uXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXp5TW9kdWxlcy5yZXNvbHZlRGVwZW5kZW5jeU1vZHVsZUluc3RhbmNlKGRlcGVuZGVuY3kpO1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIDogb2YodW5kZWZpbmVkKTtcbiAgfVxufVxuIl19