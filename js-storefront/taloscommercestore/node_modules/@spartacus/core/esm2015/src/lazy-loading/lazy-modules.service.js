import { Compiler, Injectable, InjectFlags, Injector, NgModuleFactory, } from '@angular/core';
import { combineLatest, from, of, queueScheduler, throwError, } from 'rxjs';
import { catchError, concatMap, map, observeOn, publishReplay, switchMap, switchMapTo, tap, } from 'rxjs/operators';
import { EventService } from '../event/event.service';
import { CombinedInjector } from '../util/combined-injector';
import { createFrom } from '../util/create-from';
import { ModuleInitializedEvent } from './events/module-initialized-event';
import { MODULE_INITIALIZER } from './tokens';
import * as i0 from "@angular/core";
import * as i1 from "../event/event.service";
/**
 * Utility service for managing dynamic imports of Angular services
 */
export class LazyModulesService {
    constructor(compiler, injector, events) {
        this.compiler = compiler;
        this.injector = injector;
        this.events = events;
        /**
         * Expose lazy loaded module references
         */
        this.modules$ = this.events
            .get(ModuleInitializedEvent)
            .pipe(map((event) => event.moduleRef), publishReplay());
        this.dependencyModules = new Map();
        this.eventSubscription = this.modules$.connect();
    }
    /**
     * Resolves module instance based dynamic import wrapped in an arrow function
     *
     * New module instance will be created with each call.
     *
     * @param moduleFunc
     * @param feature
     */
    resolveModuleInstance(moduleFunc, feature, dependencyModuleRefs = []) {
        let parentInjector;
        if (!dependencyModuleRefs.length) {
            parentInjector = this.injector;
        }
        else if (dependencyModuleRefs.length === 1) {
            parentInjector = dependencyModuleRefs[0].injector;
        }
        else {
            parentInjector = new CombinedInjector(this.injector, dependencyModuleRefs.map((moduleRef) => moduleRef.injector));
        }
        return this.resolveModuleFactory(moduleFunc).pipe(map(([moduleFactory]) => moduleFactory.create(parentInjector)), concatMap((moduleRef) => this.runModuleInitializersForModule(moduleRef)), tap((moduleRef) => this.events.dispatch(createFrom(ModuleInitializedEvent, {
            feature,
            moduleRef,
        }))));
    }
    /**
     * Returns dependency module instance and initializes it when needed.
     *
     * Module will be instantiated only once, at first request for a this specific module class
     */
    resolveDependencyModuleInstance(moduleFunc) {
        // We grab moduleFactory symbol from module function and if there is no
        // such a module created yet, we create it and store it in a
        // dependencyModules map
        return this.resolveModuleFactory(moduleFunc).pipe(map(([moduleFactory, module]) => {
            if (!this.dependencyModules.has(module)) {
                const moduleRef = moduleFactory.create(this.injector);
                this.dependencyModules.set(module, moduleRef);
            }
            return this.dependencyModules.get(module);
        }), concatMap((moduleRef) => this.runModuleInitializersForModule(moduleRef)), tap((moduleRef) => this.events.dispatch(createFrom(ModuleInitializedEvent, {
            moduleRef,
        }))));
    }
    /**
     * The purpose of this function is to run MODULE_INITIALIZER logic that can be provided
     * by a lazy loaded module.  The module is recieved as a function parameter.
     * This function returns an Observable to the module reference passed as an argument.
     *
     * @param {NgModuleRef<any>} moduleRef
     *
     * @returns {Observable<NgModuleRef<any>>}
     */
    runModuleInitializersForModule(moduleRef) {
        const moduleInits = moduleRef.injector.get(MODULE_INITIALIZER, [], InjectFlags.Self);
        const asyncInitPromises = this.runModuleInitializerFunctions(moduleInits);
        if (asyncInitPromises.length) {
            return from(Promise.all(asyncInitPromises)).pipe(catchError((error) => {
                console.error('MODULE_INITIALIZER promise was rejected while lazy loading a module.', error);
                return throwError(error);
            }), switchMapTo(of(moduleRef)));
        }
        else {
            return of(moduleRef);
        }
    }
    /**
     * This function accepts an array of functions and runs them all. For each function that returns a promise,
     * the resulting promise is stored in an array of promises.  That array of promises is returned.
     * It is not required for the functions to return a Promise.  All functions are run.  The return values
     * that are not a Promise are simply not stored and returned.
     *
     * @param {(() => any)[]} initFunctions An array of functions too be run.
     *
     * @return {Promise<any>[]} An array of Promise returned by the functions, if any,
     */
    runModuleInitializerFunctions(initFunctions) {
        const initPromises = [];
        try {
            if (initFunctions) {
                for (let i = 0; i < initFunctions.length; i++) {
                    const initResult = initFunctions[i]();
                    if (this.isObjectPromise(initResult)) {
                        initPromises.push(initResult);
                    }
                }
            }
            return initPromises;
        }
        catch (error) {
            console.error(`MODULE_INITIALIZER init function throwed an error. `, error);
            throw error;
        }
    }
    /**
     * Determine if the argument is shaped like a Promise
     */
    isObjectPromise(obj) {
        return !!obj && typeof obj.then === 'function';
    }
    /**
     * Resolve any Angular module from an function that return module or moduleFactory
     */
    resolveModuleFactory(moduleFunc) {
        return from(moduleFunc()).pipe(switchMap((module) => module instanceof NgModuleFactory
            ? of([module, module])
            : combineLatest([
                // using compiler here is for jit compatibility, there is no overhead
                // for aot production builds as it will be stubbed
                from(this.compiler.compileModuleAsync(module)),
                of(module),
            ])), observeOn(queueScheduler));
    }
    ngOnDestroy() {
        if (this.eventSubscription) {
            this.eventSubscription.unsubscribe();
        }
        // clean up all initialized dependency modules
        this.dependencyModules.forEach((dependency) => dependency.destroy());
    }
}
LazyModulesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LazyModulesService_Factory() { return new LazyModulesService(i0.ɵɵinject(i0.Compiler), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.EventService)); }, token: LazyModulesService, providedIn: "root" });
LazyModulesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
LazyModulesService.ctorParameters = () => [
    { type: Compiler },
    { type: Injector },
    { type: EventService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF6eS1tb2R1bGVzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiQzovVXNlcnMvUGF0cnlrL0Rlc2t0b3Avc3BhcnRhY3VzL3Byb2plY3RzL2NvcmUvIiwic291cmNlcyI6WyJzcmMvbGF6eS1sb2FkaW5nL2xhenktbW9kdWxlcy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxRQUFRLEVBQ1IsVUFBVSxFQUNWLFdBQVcsRUFDWCxRQUFRLEVBQ1IsZUFBZSxHQUdoQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQ0wsYUFBYSxFQUViLElBQUksRUFFSixFQUFFLEVBQ0YsY0FBYyxFQUVkLFVBQVUsR0FDWCxNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFDTCxVQUFVLEVBQ1YsU0FBUyxFQUNULEdBQUcsRUFDSCxTQUFTLEVBQ1QsYUFBYSxFQUNiLFNBQVMsRUFDVCxXQUFXLEVBQ1gsR0FBRyxHQUNKLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzdELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNqRCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUMzRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxVQUFVLENBQUM7OztBQUU5Qzs7R0FFRztBQUlILE1BQU0sT0FBTyxrQkFBa0I7SUFjN0IsWUFDWSxRQUFrQixFQUNsQixRQUFrQixFQUNsQixNQUFvQjtRQUZwQixhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQ2xCLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsV0FBTSxHQUFOLE1BQU0sQ0FBYztRQWhCaEM7O1dBRUc7UUFDTSxhQUFRLEdBQWlDLElBQUksQ0FBQyxNQUFNO2FBQzFELEdBQUcsQ0FBQyxzQkFB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QUssQ0FBQztTQUNiO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ssZUFBZSxDQUFVLEdBQVE7UUFDdkMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLE9BQU8sR0FBRyxDQUFDLElBQUksS0FBSyxVQUFVLENBQUM7SUFDakQsQ0FBQztJQUVEOztPQUVHO0lBQ0ssb0JBQW9CLENBQzFCLFVBQThCO1FBRTlCLE9BQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUM1QixTQUFTLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUNuQixNQUFNLFlBQVksZUFBZTtZQUMvQixDQUFDLENBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUE2QztZQUNuRSxDQUFDLENBQUMsYUFBYSxDQUFDO2dCQUNaLHFFQUFxRTtnQkFDckUsa0RBQWtEO2dCQUNsRCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFhLENBQUMsQ0FBQztnQkFDckQsRUFBRSxDQUFDLE1BQU0sQ0FBQzthQUNYLENBQUMsQ0FDUCxFQUNELFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FDMUIsQ0FBQztJQUNKLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDMUIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3RDO1FBRUQsOENBQThDO1FBQzlDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7Ozs7WUExTUYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUF2Q0MsUUFBUTtZQUdSLFFBQVE7WUF5QkQsWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBpbGVyLFxuICBJbmplY3RhYmxlLFxuICBJbmplY3RGbGFncyxcbiAgSW5qZWN0b3IsXG4gIE5nTW9kdWxlRmFjdG9yeSxcbiAgTmdNb2R1bGVSZWYsXG4gIE9uRGVzdHJveSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBjb21iaW5lTGF0ZXN0LFxuICBDb25uZWN0YWJsZU9ic2VydmFibGUsXG4gIGZyb20sXG4gIE9ic2VydmFibGUsXG4gIG9mLFxuICBxdWV1ZVNjaGVkdWxlcixcbiAgU3Vic2NyaXB0aW9uLFxuICB0aHJvd0Vycm9yLFxufSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGNvbmNhdE1hcCxcbiAgbWFwLFxuICBvYnNlcnZlT24sXG4gIHB1Ymxpc2hSZXBsYXksXG4gIHN3aXRjaE1hcCxcbiAgc3dpdGNoTWFwVG8sXG4gIHRhcCxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRXZlbnRTZXJ2aWNlIH0gZnJvbSAnLi4vZXZlbnQvZXZlbnQuc2VydmljZSc7XG5pbXBvcnQgeyBDb21iaW5lZEluamVjdG9yIH0gZnJvbSAnLi4vdXRpbC9jb21iaW5lZC1pbmplY3Rvcic7XG5pbXBvcnQgeyBjcmVhdGVGcm9tIH0gZnJvbSAnLi4vdXRpbC9jcmVhdGUtZnJvbSc7XG5pbXBvcnQgeyBNb2R1bGVJbml0aWFsaXplZEV2ZW50IH0gZnJvbSAnLi9ldmVudHMvbW9kdWxlLWluaXRpYWxpemVkLWV2ZW50JztcbmltcG9ydCB7IE1PRFVMRV9JTklUSUFMSVpFUiB9IGZyb20gJy4vdG9rZW5zJztcblxuLyoqXG4gKiBVdGlsaXR5IHNlcnZpY2UgZm9yIG1hbmFnaW5nIGR5bmFtaWMgaW1wb3J0cyBvZiBBbmd1bGFyIHNlcnZpY2VzXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBMYXp5TW9kdWxlc1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAvKipcbiAgICogRXhwb3NlIGxhenkgbG9hZGVkIG1vZHVsZSByZWZlcmVuY2VzXG4gICAqL1xuICByZWFkb25seSBtb2R1bGVzJDogT2JzZXJ2YWJsZTxOZ01vZHVsZVJlZjxhbnk+PiA9IHRoaXMuZXZlbnRzXG4gICAgLmdldChNb2R1bGVJbml0aWFsaXplZEV2ZW50KVxuICAgIC5waXBlKFxuICAgICAgbWFwKChldmVudCkgPT4gZXZlbnQubW9kdWxlUmVmKSxcbiAgICAgIHB1Ymxpc2hSZXBsYXkoKVxuICAgICk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBkZXBlbmRlbmN5TW9kdWxlcyA9IG5ldyBNYXA8YW55LCBOZ01vZHVsZVJlZjxhbnk+PigpO1xuICBwcml2YXRlIHJlYWRvbmx5IGV2ZW50U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGNvbXBpbGVyOiBDb21waWxlcixcbiAgICBwcm90ZWN0ZWQgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByb3RlY3RlZCBldmVudHM6IEV2ZW50U2VydmljZVxuICApIHtcbiAgICB0aGlzLmV2ZW50U3Vic2NyaXB0aW9uID0gKHRoaXMubW9kdWxlcyQgYXMgQ29ubmVjdGFibGVPYnNlcnZhYmxlPFxuICAgICAgTmdNb2R1bGVSZWY8YW55PlxuICAgID4pLmNvbm5lY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBtb2R1bGUgaW5zdGFuY2UgYmFzZWQgZHluYW1pYyBpbXBvcnQgd3JhcHBlZCBpbiBhbiBhcnJvdyBmdW5jdGlvblxuICAgKlxuICAgKiBOZXcgbW9kdWxlIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZCB3aXRoIGVhY2ggY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIG1vZHVsZUZ1bmNcbiAgICogQHBhcmFtIGZlYXR1cmVcbiAgICovXG4gIHB1YmxpYyByZXNvbHZlTW9kdWxlSW5zdGFuY2UoXG4gICAgbW9kdWxlRnVuYzogKCkgPT4gUHJvbWlzZTxhbnk+LFxuICAgIGZlYXR1cmU/OiBzdHJpbmcsXG4gICAgZGVwZW5kZW5jeU1vZHVsZVJlZnM6IE5nTW9kdWxlUmVmPGFueT5bXSA9IFtdXG4gICk6IE9ic2VydmFibGU8TmdNb2R1bGVSZWY8YW55Pj4ge1xuICAgIGxldCBwYXJlbnRJbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgICBpZiAoIWRlcGVuZGVuY3lNb2R1bGVSZWZzLmxlbmd0aCkge1xuICAgICAgcGFyZW50SW5qZWN0b3IgPSB0aGlzLmluamVjdG9yO1xuICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeU1vZHVsZVJlZnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBwYXJlbnRJbmplY3RvciA9IGRlcGVuZGVuY3lNb2R1bGVSZWZzWzBdLmluamVjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRJbmplY3RvciA9IG5ldyBDb21iaW5lZEluamVjdG9yKFxuICAgICAgICB0aGlzLmluamVjdG9yLFxuICAgICAgICBkZXBlbmRlbmN5TW9kdWxlUmVmcy5tYXAoKG1vZHVsZVJlZikgPT4gbW9kdWxlUmVmLmluamVjdG9yKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlTW9kdWxlRmFjdG9yeShtb2R1bGVGdW5jKS5waXBlKFxuICAgICAgbWFwKChbbW9kdWxlRmFjdG9yeV0pID0+IG1vZHVsZUZhY3RvcnkuY3JlYXRlKHBhcmVudEluamVjdG9yKSksXG4gICAgICBjb25jYXRNYXAoKG1vZHVsZVJlZikgPT4gdGhpcy5ydW5Nb2R1bGVJbml0aWFsaXplcnNGb3JNb2R1bGUobW9kdWxlUmVmKSksXG4gICAgICB0YXAoKG1vZHVsZVJlZikgPT5cbiAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2goXG4gICAgICAgICAgY3JlYXRlRnJvbShNb2R1bGVJbml0aWFsaXplZEV2ZW50LCB7XG4gICAgICAgICAgICBmZWF0dXJlLFxuICAgICAgICAgICAgbW9kdWxlUmVmLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGVwZW5kZW5jeSBtb2R1bGUgaW5zdGFuY2UgYW5kIGluaXRpYWxpemVzIGl0IHdoZW4gbmVlZGVkLlxuICAgKlxuICAgKiBNb2R1bGUgd2lsbCBiZSBpbnN0YW50aWF0ZWQgb25seSBvbmNlLCBhdCBmaXJzdCByZXF1ZXN0IGZvciBhIHRoaXMgc3BlY2lmaWMgbW9kdWxlIGNsYXNzXG4gICAqL1xuICBwdWJsaWMgcmVzb2x2ZURlcGVuZGVuY3lNb2R1bGVJbnN0YW5jZShcbiAgICBtb2R1bGVGdW5jOiAoKSA9PiBQcm9taXNlPGFueT5cbiAgKTogT2JzZXJ2YWJsZTxOZ01vZHVsZVJlZjxhbnk+PiB7XG4gICAgLy8gV2UgZ3JhYiBtb2R1bGVGYWN0b3J5IHN5bWJvbCBmcm9tIG1vZHVsZSBmdW5jdGlvbiBhbmQgaWYgdGhlcmUgaXMgbm9cbiAgICAvLyBzdWNoIGEgbW9kdWxlIGNyZWF0ZWQgeWV0LCB3ZSBjcmVhdGUgaXQgYW5kIHN0b3JlIGl0IGluIGFcbiAgICAvLyBkZXBlbmRlbmN5TW9kdWxlcyBtYXBcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlTW9kdWxlRmFjdG9yeShtb2R1bGVGdW5jKS5waXBlKFxuICAgICAgbWFwKChbbW9kdWxlRmFjdG9yeSwgbW9kdWxlXSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZGVwZW5kZW5jeU1vZHVsZXMuaGFzKG1vZHVsZSkpIHtcbiAgICAgICAgICBjb25zdCBtb2R1bGVSZWYgPSBtb2R1bGVGYWN0b3J5LmNyZWF0ZSh0aGlzLmluamVjdG9yKTtcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lNb2R1bGVzLnNldChtb2R1bGUsIG1vZHVsZVJlZik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kZXBlbmRlbmN5TW9kdWxlcy5nZXQobW9kdWxlKTtcbiAgICAgIH0pLFxuICAgICAgY29uY2F0TWFwKChtb2R1bGVSZWYpID0+IHRoaXMucnVuTW9kdWxlSW5pdGlhbGl6ZXJzRm9yTW9kdWxlKG1vZHVsZVJlZikpLFxuICAgICAgdGFwKChtb2R1bGVSZWYpID0+XG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKFxuICAgICAgICAgIGNyZWF0ZUZyb20oTW9kdWxlSW5pdGlhbGl6ZWRFdmVudCwge1xuICAgICAgICAgICAgbW9kdWxlUmVmLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gcnVuIE1PRFVMRV9JTklUSUFMSVpFUiBsb2dpYyB0aGF0IGNhbiBiZSBwcm92aWRlZFxuICAgKiBieSBhIGxhenkgbG9hZGVkIG1vZHVsZS4gIFRoZSBtb2R1bGUgaXMgcmVjaWV2ZWQgYXMgYSBmdW5jdGlvbiBwYXJhbWV0ZXIuXG4gICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRvIHRoZSBtb2R1bGUgcmVmZXJlbmNlIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtOZ01vZHVsZVJlZjxhbnk+fSBtb2R1bGVSZWZcbiAgICpcbiAgICogQHJldHVybnMge09ic2VydmFibGU8TmdNb2R1bGVSZWY8YW55Pj59XG4gICAqL1xuICBwdWJsaWMgcnVuTW9kdWxlSW5pdGlhbGl6ZXJzRm9yTW9kdWxlKFxuICAgIG1vZHVsZVJlZjogTmdNb2R1bGVSZWY8YW55PlxuICApOiBPYnNlcnZhYmxlPE5nTW9kdWxlUmVmPGFueT4+IHtcbiAgICBjb25zdCBtb2R1bGVJbml0czogYW55W10gPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0PGFueVtdPihcbiAgICAgIE1PRFVMRV9JTklUSUFMSVpFUixcbiAgICAgIFtdLFxuICAgICAgSW5qZWN0RmxhZ3MuU2VsZlxuICAgICk7XG4gICAgY29uc3QgYXN5bmNJbml0UHJvbWlzZXM6IFByb21pc2U8YW55PltdID0gdGhpcy5ydW5Nb2R1bGVJbml0aWFsaXplckZ1bmN0aW9ucyhcbiAgICAgIG1vZHVsZUluaXRzXG4gICAgKTtcbiAgICBpZiAoYXN5bmNJbml0UHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZnJvbShQcm9taXNlLmFsbChhc3luY0luaXRQcm9taXNlcykpLnBpcGUoXG4gICAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdNT0RVTEVfSU5JVElBTElaRVIgcHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2hpbGUgbGF6eSBsb2FkaW5nIGEgbW9kdWxlLicsXG4gICAgICAgICAgICBlcnJvclxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3IpO1xuICAgICAgICB9KSxcbiAgICAgICAgc3dpdGNoTWFwVG8ob2YobW9kdWxlUmVmKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvZihtb2R1bGVSZWYpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW4gYXJyYXkgb2YgZnVuY3Rpb25zIGFuZCBydW5zIHRoZW0gYWxsLiBGb3IgZWFjaCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLFxuICAgKiB0aGUgcmVzdWx0aW5nIHByb21pc2UgaXMgc3RvcmVkIGluIGFuIGFycmF5IG9mIHByb21pc2VzLiAgVGhhdCBhcnJheSBvZiBwcm9taXNlcyBpcyByZXR1cm5lZC5cbiAgICogSXQgaXMgbm90IHJlcXVpcmVkIGZvciB0aGUgZnVuY3Rpb25zIHRvIHJldHVybiBhIFByb21pc2UuICBBbGwgZnVuY3Rpb25zIGFyZSBydW4uICBUaGUgcmV0dXJuIHZhbHVlc1xuICAgKiB0aGF0IGFyZSBub3QgYSBQcm9taXNlIGFyZSBzaW1wbHkgbm90IHN0b3JlZCBhbmQgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7KCgpID0+IGFueSlbXX0gaW5pdEZ1bmN0aW9ucyBBbiBhcnJheSBvZiBmdW5jdGlvbnMgdG9vIGJlIHJ1bi5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxhbnk+W119IEFuIGFycmF5IG9mIFByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9ucywgaWYgYW55LFxuICAgKi9cbiAgcHVibGljIHJ1bk1vZHVsZUluaXRpYWxpemVyRnVuY3Rpb25zKFxuICAgIGluaXRGdW5jdGlvbnM6ICgoKSA9PiBhbnkpW11cbiAgKTogUHJvbWlzZTxhbnk+W10ge1xuICAgIGNvbnN0IGluaXRQcm9taXNlczogUHJvbWlzZTxhbnk+W10gPSBbXTtcbiAgICB0cnkge1xuICAgICAgaWYgKGluaXRGdW5jdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0RnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaW5pdFJlc3VsdCA9IGluaXRGdW5jdGlvbnNbaV0oKTtcbiAgICAgICAgICBpZiAodGhpcy5pc09iamVjdFByb21pc2UoaW5pdFJlc3VsdCkpIHtcbiAgICAgICAgICAgIGluaXRQcm9taXNlcy5wdXNoKGluaXRSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGluaXRQcm9taXNlcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYE1PRFVMRV9JTklUSUFMSVpFUiBpbml0IGZ1bmN0aW9uIHRocm93ZWQgYW4gZXJyb3IuIGAsXG4gICAgICAgIGVycm9yXG4gICAgICApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgYXJndW1lbnQgaXMgc2hhcGVkIGxpa2UgYSBQcm9taXNlXG4gICAqL1xuICBwcml2YXRlIGlzT2JqZWN0UHJvbWlzZTxUID0gYW55PihvYmo6IGFueSk6IG9iaiBpcyBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gISFvYmogJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgYW55IEFuZ3VsYXIgbW9kdWxlIGZyb20gYW4gZnVuY3Rpb24gdGhhdCByZXR1cm4gbW9kdWxlIG9yIG1vZHVsZUZhY3RvcnlcbiAgICovXG4gIHByaXZhdGUgcmVzb2x2ZU1vZHVsZUZhY3RvcnkoXG4gICAgbW9kdWxlRnVuYzogKCkgPT4gUHJvbWlzZTxhbnk+XG4gICk6IE9ic2VydmFibGU8W05nTW9kdWxlRmFjdG9yeTxhbnk+LCBhbnldPiB7XG4gICAgcmV0dXJuIGZyb20obW9kdWxlRnVuYygpKS5waXBlKFxuICAgICAgc3dpdGNoTWFwKChtb2R1bGUpID0+XG4gICAgICAgIG1vZHVsZSBpbnN0YW5jZW9mIE5nTW9kdWxlRmFjdG9yeVxuICAgICAgICAgID8gKG9mKFttb2R1bGUsIG1vZHVsZV0pIGFzIE9ic2VydmFibGU8W05nTW9kdWxlRmFjdG9yeTxhbnk+LCBhbnldPilcbiAgICAgICAgICA6IGNvbWJpbmVMYXRlc3QoW1xuICAgICAgICAgICAgICAvLyB1c2luZyBjb21waWxlciBoZXJlIGlzIGZvciBqaXQgY29tcGF0aWJpbGl0eSwgdGhlcmUgaXMgbm8gb3ZlcmhlYWRcbiAgICAgICAgICAgICAgLy8gZm9yIGFvdCBwcm9kdWN0aW9uIGJ1aWxkcyBhcyBpdCB3aWxsIGJlIHN0dWJiZWRcbiAgICAgICAgICAgICAgZnJvbSh0aGlzLmNvbXBpbGVyLmNvbXBpbGVNb2R1bGVBc3luYyhtb2R1bGUgYXMgYW55KSksXG4gICAgICAgICAgICAgIG9mKG1vZHVsZSksXG4gICAgICAgICAgICBdKVxuICAgICAgKSxcbiAgICAgIG9ic2VydmVPbihxdWV1ZVNjaGVkdWxlcilcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZXZlbnRTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuZXZlbnRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhbiB1cCBhbGwgaW5pdGlhbGl6ZWQgZGVwZW5kZW5jeSBtb2R1bGVzXG4gICAgdGhpcy5kZXBlbmRlbmN5TW9kdWxlcy5mb3JFYWNoKChkZXBlbmRlbmN5KSA9PiBkZXBlbmRlbmN5LmRlc3Ryb3koKSk7XG4gIH1cbn1cbiJdfQ==