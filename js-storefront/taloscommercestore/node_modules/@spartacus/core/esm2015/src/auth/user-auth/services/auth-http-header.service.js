import { Injectable } from '@angular/core';
import { filter, switchMap, take, tap } from 'rxjs/operators';
import { GlobalMessageService } from '../../../global-message/facade/global-message.service';
import { GlobalMessageType } from '../../../global-message/models/global-message.model';
import { OccEndpointsService } from '../../../occ/services/occ-endpoints.service';
import { RoutingService } from '../../../routing/facade/routing.service';
import { AuthService } from '../facade/auth.service';
import { AuthStorageService } from './auth-storage.service';
import { OAuthLibWrapperService } from './oauth-lib-wrapper.service';
import * as i0 from "@angular/core";
import * as i1 from "../facade/auth.service";
import * as i2 from "./auth-storage.service";
import * as i3 from "./oauth-lib-wrapper.service";
import * as i4 from "../../../routing/facade/routing.service";
import * as i5 from "../../../occ/services/occ-endpoints.service";
import * as i6 from "../../../global-message/facade/global-message.service";
/**
 * Extendable service for `AuthInterceptor`.
 */
export class AuthHttpHeaderService {
    constructor(authService, authStorageService, oAuthLibWrapperService, routingService, occEndpoints, globalMessageService) {
        this.authService = authService;
        this.authStorageService = authStorageService;
        this.oAuthLibWrapperService = oAuthLibWrapperService;
        this.routingService = routingService;
        this.occEndpoints = occEndpoints;
        this.globalMessageService = globalMessageService;
    }
    /**
     * Checks if request should be handled by this service (if it's OCC call).
     */
    shouldCatchError(request) {
        return this.isOccUrl(request.url);
    }
    /**
     * Adds `Authorization` header for OCC calls.
     */
    alterRequest(request) {
        const hasAuthorizationHeader = !!this.getAuthorizationHeader(request);
        const isOccUrl = this.isOccUrl(request.url);
        if (!hasAuthorizationHeader && isOccUrl) {
            return request.clone({
                setHeaders: Object.assign({}, this.createAuthorizationHeader()),
            });
        }
        return request;
    }
    isOccUrl(url) {
        return url.includes(this.occEndpoints.getBaseEndpoint());
    }
    getAuthorizationHeader(request) {
        const rawValue = request.headers.get('Authorization');
        return rawValue;
    }
    createAuthorizationHeader() {
        let token;
        this.authStorageService
            .getToken()
            .subscribe((tok) => (token = tok))
            .unsubscribe();
        if (token === null || token === void 0 ? void 0 : token.access_token) {
            return {
                Authorization: `${token.token_type || 'Bearer'} ${token.access_token}`,
            };
        }
        return {};
    }
    /**
     * Refreshes access_token and then retries the call with the new token.
     */
    handleExpiredAccessToken(request, next) {
        return this.handleExpiredToken().pipe(switchMap((token) => {
            return next.handle(this.createNewRequestWithNewToken(request, token));
        }));
    }
    /**
     * Logout user, redirected to login page and informs about expired session.
     */
    handleExpiredRefreshToken() {
        // Logout user
        // TODO(#9638): Use logout route when it will support passing redirect url
        this.authService.coreLogout();
        this.routingService.go({ cxRoute: 'login' });
        this.globalMessageService.add({
            key: 'httpHandlers.sessionExpired',
        }, GlobalMessageType.MSG_TYPE_ERROR);
    }
    /**
     * Attempts to refresh token if possible.
     * If it is not possible calls `handleExpiredRefreshToken`.
     *
     * @return observable which omits new access_token. (Warn: might never emit!).
     */
    handleExpiredToken() {
        const stream = this.authStorageService.getToken();
        let oldToken;
        return stream.pipe(tap((token) => {
            if (token.access_token && token.refresh_token && !oldToken) {
                this.oAuthLibWrapperService.refreshToken();
            }
            else if (!token.refresh_token) {
                this.handleExpiredRefreshToken();
            }
            oldToken = oldToken || token;
        }), filter((token) => oldToken.access_token !== token.access_token), take(1));
    }
    createNewRequestWithNewToken(request, token) {
        request = request.clone({
            setHeaders: {
                Authorization: `${token.token_type || 'Bearer'} ${token.access_token}`,
            },
        });
        return request;
    }
}
AuthHttpHeaderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthHttpHeaderService_Factory() { return new AuthHttpHeaderService(i0.ɵɵinject(i1.AuthService), i0.ɵɵinject(i2.AuthStorageService), i0.ɵɵinject(i3.OAuthLibWrapperService), i0.ɵɵinject(i4.RoutingService), i0.ɵɵinject(i5.OccEndpointsService), i0.ɵɵinject(i6.GlobalMessageService)); }, token: AuthHttpHeaderService, providedIn: "root" });
AuthHttpHeaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
AuthHttpHeaderService.ctorParameters = () => [
    { type: AuthService },
    { type: AuthStorageService },
    { type: OAuthLibWrapperService },
    { type: RoutingService },
    { type: OccEndpointsService },
    { type: GlobalMessageService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC1odHRwLWhlYWRlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL1BhdHJ5ay9EZXNrdG9wL3NwYXJ0YWN1cy9wcm9qZWN0cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL2F1dGgvdXNlci1hdXRoL3NlcnZpY2VzL2F1dGgtaHR0cC1oZWFkZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx1REFBdUQsQ0FBQztBQUM3RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxxREFBcUQsQ0FBQztBQUN4RixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSw2Q0FBNkMsQ0FBQztBQUNsRixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0seUNBQXlDLENBQUM7QUFDekUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRXJELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDOzs7Ozs7OztBQUVyRTs7R0FFRztBQUlILE1BQU0sT0FBTyxxQkFBcUI7SUFDaEMsWUFDWSxXQUF3QixFQUN4QixrQkFBc0MsRUFDdEMsc0JBQThDLEVBQzlDLGNBQThCLEVBQzlCLFlBQWlDLEVBQ2pDLG9CQUEwQztRQUwxQyxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUN4Qix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9CO1FBQ3RDLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFDOUMsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQzlCLGlCQUFZLEdBQVosWUFBWSxDQUFxQjtR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QUksQ0FBQyxzQkFBc0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUM1QztpQkFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRTtnQkFDL0IsSUFBSSxDQUFDLHlCQUF5QixFQUFFLENBQUM7YUFDbEM7WUFDRCxRQUFRLEdBQUcsUUFBUSxJQUFJLEtBQUssQ0FBQztRQUMvQixDQUFDLENBQUMsRUFDRixNQUFNLENBQ0osQ0FBQyxLQUFnQixFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsWUFBWSxLQUFLLEtBQUssQ0FBQyxZQUFZLENBQ25FLEVBQ0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNSLENBQUM7SUFDSixDQUFDO0lBRVMsNEJBQTRCLENBQ3BDLE9BQXlCLEVBQ3pCLEtBQWdCO1FBRWhCLE9BQU8sR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO1lBQ3RCLFVBQVUsRUFBRTtnQkFDVixhQUFhLEVBQUUsR0FBRyxLQUFLLENBQUMsVUFBVSxJQUFJLFFBQVEsSUFBSSxLQUFLLENBQUMsWUFBWSxFQUFFO2FBQ3ZFO1NBQ0YsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQzs7OztZQTdIRixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7OztZQVZRLFdBQVc7WUFFWCxrQkFBa0I7WUFDbEIsc0JBQXNCO1lBSnRCLGNBQWM7WUFEZCxtQkFBbUI7WUFGbkIsb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cEV2ZW50LCBIdHRwSGFuZGxlciwgSHR0cFJlcXVlc3QgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHN3aXRjaE1hcCwgdGFrZSwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgR2xvYmFsTWVzc2FnZVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWwtbWVzc2FnZS9mYWNhZGUvZ2xvYmFsLW1lc3NhZ2Uuc2VydmljZSc7XG5pbXBvcnQgeyBHbG9iYWxNZXNzYWdlVHlwZSB9IGZyb20gJy4uLy4uLy4uL2dsb2JhbC1tZXNzYWdlL21vZGVscy9nbG9iYWwtbWVzc2FnZS5tb2RlbCc7XG5pbXBvcnQgeyBPY2NFbmRwb2ludHNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vb2NjL3NlcnZpY2VzL29jYy1lbmRwb2ludHMuc2VydmljZSc7XG5pbXBvcnQgeyBSb3V0aW5nU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3JvdXRpbmcvZmFjYWRlL3JvdXRpbmcuc2VydmljZSc7XG5pbXBvcnQgeyBBdXRoU2VydmljZSB9IGZyb20gJy4uL2ZhY2FkZS9hdXRoLnNlcnZpY2UnO1xuaW1wb3J0IHsgQXV0aFRva2VuIH0gZnJvbSAnLi4vbW9kZWxzL2F1dGgtdG9rZW4ubW9kZWwnO1xuaW1wb3J0IHsgQXV0aFN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnLi9hdXRoLXN0b3JhZ2Uuc2VydmljZSc7XG5pbXBvcnQgeyBPQXV0aExpYldyYXBwZXJTZXJ2aWNlIH0gZnJvbSAnLi9vYXV0aC1saWItd3JhcHBlci5zZXJ2aWNlJztcblxuLyoqXG4gKiBFeHRlbmRhYmxlIHNlcnZpY2UgZm9yIGBBdXRoSW50ZXJjZXB0b3JgLlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQXV0aEh0dHBIZWFkZXJTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGF1dGhTZXJ2aWNlOiBBdXRoU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgYXV0aFN0b3JhZ2VTZXJ2aWNlOiBBdXRoU3RvcmFnZVNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIG9BdXRoTGliV3JhcHBlclNlcnZpY2U6IE9BdXRoTGliV3JhcHBlclNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIHJvdXRpbmdTZXJ2aWNlOiBSb3V0aW5nU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgb2NjRW5kcG9pbnRzOiBPY2NFbmRwb2ludHNTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBnbG9iYWxNZXNzYWdlU2VydmljZTogR2xvYmFsTWVzc2FnZVNlcnZpY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcmVxdWVzdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGlzIHNlcnZpY2UgKGlmIGl0J3MgT0NDIGNhbGwpLlxuICAgKi9cbiAgcHVibGljIHNob3VsZENhdGNoRXJyb3IocmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55Pik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzT2NjVXJsKHJlcXVlc3QudXJsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGBBdXRob3JpemF0aW9uYCBoZWFkZXIgZm9yIE9DQyBjYWxscy5cbiAgICovXG4gIHB1YmxpYyBhbHRlclJlcXVlc3QocmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55Pik6IEh0dHBSZXF1ZXN0PGFueT4ge1xuICAgIGNvbnN0IGhhc0F1dGhvcml6YXRpb25IZWFkZXIgPSAhIXRoaXMuZ2V0QXV0aG9yaXphdGlvbkhlYWRlcihyZXF1ZXN0KTtcbiAgICBjb25zdCBpc09jY1VybCA9IHRoaXMuaXNPY2NVcmwocmVxdWVzdC51cmwpO1xuICAgIGlmICghaGFzQXV0aG9yaXphdGlvbkhlYWRlciAmJiBpc09jY1VybCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3QuY2xvbmUoe1xuICAgICAgICBzZXRIZWFkZXJzOiB7XG4gICAgICAgICAgLi4udGhpcy5jcmVhdGVBdXRob3JpemF0aW9uSGVhZGVyKCksXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cblxuICBwcm90ZWN0ZWQgaXNPY2NVcmwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdXJsLmluY2x1ZGVzKHRoaXMub2NjRW5kcG9pbnRzLmdldEJhc2VFbmRwb2ludCgpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRBdXRob3JpemF0aW9uSGVhZGVyKHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PGFueT4pOiBzdHJpbmcge1xuICAgIGNvbnN0IHJhd1ZhbHVlID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnQXV0aG9yaXphdGlvbicpO1xuICAgIHJldHVybiByYXdWYWx1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjcmVhdGVBdXRob3JpemF0aW9uSGVhZGVyKCk6IHsgQXV0aG9yaXphdGlvbjogc3RyaW5nIH0gfCB7fSB7XG4gICAgbGV0IHRva2VuO1xuICAgIHRoaXMuYXV0aFN0b3JhZ2VTZXJ2aWNlXG4gICAgICAuZ2V0VG9rZW4oKVxuICAgICAgLnN1YnNjcmliZSgodG9rKSA9PiAodG9rZW4gPSB0b2spKVxuICAgICAgLnVuc3Vic2NyaWJlKCk7XG5cbiAgICBpZiAodG9rZW4/LmFjY2Vzc190b2tlbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYCR7dG9rZW4udG9rZW5fdHlwZSB8fCAnQmVhcmVyJ30gJHt0b2tlbi5hY2Nlc3NfdG9rZW59YCxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgYWNjZXNzX3Rva2VuIGFuZCB0aGVuIHJldHJpZXMgdGhlIGNhbGwgd2l0aCB0aGUgbmV3IHRva2VuLlxuICAgKi9cbiAgcHVibGljIGhhbmRsZUV4cGlyZWRBY2Nlc3NUb2tlbihcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+LFxuICAgIG5leHQ6IEh0dHBIYW5kbGVyXG4gICk6IE9ic2VydmFibGU8SHR0cEV2ZW50PEF1dGhUb2tlbj4+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVFeHBpcmVkVG9rZW4oKS5waXBlKFxuICAgICAgc3dpdGNoTWFwKCh0b2tlbjogQXV0aFRva2VuKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXh0LmhhbmRsZSh0aGlzLmNyZWF0ZU5ld1JlcXVlc3RXaXRoTmV3VG9rZW4ocmVxdWVzdCwgdG9rZW4pKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dvdXQgdXNlciwgcmVkaXJlY3RlZCB0byBsb2dpbiBwYWdlIGFuZCBpbmZvcm1zIGFib3V0IGV4cGlyZWQgc2Vzc2lvbi5cbiAgICovXG4gIHB1YmxpYyBoYW5kbGVFeHBpcmVkUmVmcmVzaFRva2VuKCk6IHZvaWQge1xuICAgIC8vIExvZ291dCB1c2VyXG4gICAgLy8gVE9ETygjOTYzOCk6IFVzZSBsb2dvdXQgcm91dGUgd2hlbiBpdCB3aWxsIHN1cHBvcnQgcGFzc2luZyByZWRpcmVjdCB1cmxcbiAgICB0aGlzLmF1dGhTZXJ2aWNlLmNvcmVMb2dvdXQoKTtcbiAgICB0aGlzLnJvdXRpbmdTZXJ2aWNlLmdvKHsgY3hSb3V0ZTogJ2xvZ2luJyB9KTtcbiAgICB0aGlzLmdsb2JhbE1lc3NhZ2VTZXJ2aWNlLmFkZChcbiAgICAgIHtcbiAgICAgICAga2V5OiAnaHR0cEhhbmRsZXJzLnNlc3Npb25FeHBpcmVkJyxcbiAgICAgIH0sXG4gICAgICBHbG9iYWxNZXNzYWdlVHlwZS5NU0dfVFlQRV9FUlJPUlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcmVmcmVzaCB0b2tlbiBpZiBwb3NzaWJsZS5cbiAgICogSWYgaXQgaXMgbm90IHBvc3NpYmxlIGNhbGxzIGBoYW5kbGVFeHBpcmVkUmVmcmVzaFRva2VuYC5cbiAgICpcbiAgICogQHJldHVybiBvYnNlcnZhYmxlIHdoaWNoIG9taXRzIG5ldyBhY2Nlc3NfdG9rZW4uIChXYXJuOiBtaWdodCBuZXZlciBlbWl0ISkuXG4gICAqL1xuICBwcm90ZWN0ZWQgaGFuZGxlRXhwaXJlZFRva2VuKCk6IE9ic2VydmFibGU8QXV0aFRva2VuPiB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5hdXRoU3RvcmFnZVNlcnZpY2UuZ2V0VG9rZW4oKTtcbiAgICBsZXQgb2xkVG9rZW46IEF1dGhUb2tlbjtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGUoXG4gICAgICB0YXAoKHRva2VuOiBBdXRoVG9rZW4pID0+IHtcbiAgICAgICAgaWYgKHRva2VuLmFjY2Vzc190b2tlbiAmJiB0b2tlbi5yZWZyZXNoX3Rva2VuICYmICFvbGRUb2tlbikge1xuICAgICAgICAgIHRoaXMub0F1dGhMaWJXcmFwcGVyU2VydmljZS5yZWZyZXNoVG9rZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICghdG9rZW4ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRXhwaXJlZFJlZnJlc2hUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIG9sZFRva2VuID0gb2xkVG9rZW4gfHwgdG9rZW47XG4gICAgICB9KSxcbiAgICAgIGZpbHRlcihcbiAgICAgICAgKHRva2VuOiBBdXRoVG9rZW4pID0+IG9sZFRva2VuLmFjY2Vzc190b2tlbiAhPT0gdG9rZW4uYWNjZXNzX3Rva2VuXG4gICAgICApLFxuICAgICAgdGFrZSgxKVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY3JlYXRlTmV3UmVxdWVzdFdpdGhOZXdUb2tlbihcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+LFxuICAgIHRva2VuOiBBdXRoVG9rZW5cbiAgKTogSHR0cFJlcXVlc3Q8YW55PiB7XG4gICAgcmVxdWVzdCA9IHJlcXVlc3QuY2xvbmUoe1xuICAgICAgc2V0SGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgJHt0b2tlbi50b2tlbl90eXBlIHx8ICdCZWFyZXInfSAke3Rva2VuLmFjY2Vzc190b2tlbn1gLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxufVxuIl19