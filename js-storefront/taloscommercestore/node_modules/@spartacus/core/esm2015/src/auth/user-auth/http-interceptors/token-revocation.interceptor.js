import { Injectable } from '@angular/core';
import { switchMap, take } from 'rxjs/operators';
import { AuthConfigService } from '../services/auth-config.service';
import { AuthStorageService } from '../services/auth-storage.service';
import * as i0 from "@angular/core";
import * as i1 from "../services/auth-storage.service";
import * as i2 from "../services/auth-config.service";
/**
 * This interceptor is dedicated for Hybris OAuth server which requires `Authorization` header for revoke token calls.
 */
export class TokenRevocationInterceptor {
    constructor(authStorageService, authConfigService) {
        this.authStorageService = authStorageService;
        this.authConfigService = authConfigService;
    }
    intercept(request, next) {
        const isTokenRevocationRequest = this.isTokenRevocationRequest(request);
        return this.authStorageService.getToken().pipe(take(1), switchMap((token) => {
            if (isTokenRevocationRequest) {
                request = request.clone({
                    setHeaders: {
                        Authorization: `${token.token_type || 'Bearer'} ${token.access_token}`,
                    },
                });
            }
            return next.handle(request);
        }));
    }
    isTokenRevocationRequest(request) {
        return request.url === this.authConfigService.getRevokeEndpoint();
    }
}
TokenRevocationInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function TokenRevocationInterceptor_Factory() { return new TokenRevocationInterceptor(i0.ɵɵinject(i1.AuthStorageService), i0.ɵɵinject(i2.AuthConfigService)); }, token: TokenRevocationInterceptor, providedIn: "root" });
TokenRevocationInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
TokenRevocationInterceptor.ctorParameters = () => [
    { type: AuthStorageService },
    { type: AuthConfigService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW4tcmV2b2NhdGlvbi5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvY29yZS8iLCJzb3VyY2VzIjpbInNyYy9hdXRoL3VzZXItYXV0aC9odHRwLWludGVyY2VwdG9ycy90b2tlbi1yZXZvY2F0aW9uLmludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU1BLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNwRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQzs7OztBQUV0RTs7R0FFRztBQUVILE1BQU0sT0FBTywwQkFBMEI7SUFDckMsWUFDWSxrQkFBc0MsRUFDdEMsaUJBQW9DO1FBRHBDLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBb0I7UUFDdEMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtJQUM3QyxDQUFDO0lBRUosU0FBUyxDQUNQLE9BQXlCLEVBQ3pCLElBQWlCO1FBRWpCLE1BQU0sd0JBQXdCLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3hFLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxDQUFDLElBQUksQ0FDNUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUNQLFNBQVMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ2xCLElBQUksd0JBQXdCLEVBQUU7Z0JBQzVCLE9BQU8sR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO29CQUN0QixVQUFVLEVBQUU7d0JBQ1YsYUFBYSxFQUFFLEdBQUcsS0FBSyxDQUFDLFVBQVUsSUFBSSxRQUFRLElBQzVDLEtBQUssQ0FBQyxZQUNSLEVBQUU7cUJBQ0g7aUJBQ0YsQ0FBQyxDQUFDO2FBQ0o7WUFDRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFUyx3QkFBd0IsQ0FBQyxPQUF5QjtRQUMxRCxPQUFPLE9BQU8sQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDcEUsQ0FBQzs7OztZQS9CRixVQUFVLFNBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOzs7WUFMekIsa0JBQWtCO1lBRGxCLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEh0dHBFdmVudCxcbiAgSHR0cEhhbmRsZXIsXG4gIEh0dHBJbnRlcmNlcHRvcixcbiAgSHR0cFJlcXVlc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHN3aXRjaE1hcCwgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEF1dGhDb25maWdTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvYXV0aC1jb25maWcuc2VydmljZSc7XG5pbXBvcnQgeyBBdXRoU3RvcmFnZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9hdXRoLXN0b3JhZ2Uuc2VydmljZSc7XG5cbi8qKlxuICogVGhpcyBpbnRlcmNlcHRvciBpcyBkZWRpY2F0ZWQgZm9yIEh5YnJpcyBPQXV0aCBzZXJ2ZXIgd2hpY2ggcmVxdWlyZXMgYEF1dGhvcml6YXRpb25gIGhlYWRlciBmb3IgcmV2b2tlIHRva2VuIGNhbGxzLlxuICovXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIFRva2VuUmV2b2NhdGlvbkludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGF1dGhTdG9yYWdlU2VydmljZTogQXV0aFN0b3JhZ2VTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBhdXRoQ29uZmlnU2VydmljZTogQXV0aENvbmZpZ1NlcnZpY2VcbiAgKSB7fVxuXG4gIGludGVyY2VwdChcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+LFxuICAgIG5leHQ6IEh0dHBIYW5kbGVyXG4gICk6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICBjb25zdCBpc1Rva2VuUmV2b2NhdGlvblJlcXVlc3QgPSB0aGlzLmlzVG9rZW5SZXZvY2F0aW9uUmVxdWVzdChyZXF1ZXN0KTtcbiAgICByZXR1cm4gdGhpcy5hdXRoU3RvcmFnZVNlcnZpY2UuZ2V0VG9rZW4oKS5waXBlKFxuICAgICAgdGFrZSgxKSxcbiAgICAgIHN3aXRjaE1hcCgodG9rZW4pID0+IHtcbiAgICAgICAgaWYgKGlzVG9rZW5SZXZvY2F0aW9uUmVxdWVzdCkge1xuICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LmNsb25lKHtcbiAgICAgICAgICAgIHNldEhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYCR7dG9rZW4udG9rZW5fdHlwZSB8fCAnQmVhcmVyJ30gJHtcbiAgICAgICAgICAgICAgICB0b2tlbi5hY2Nlc3NfdG9rZW5cbiAgICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXF1ZXN0KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpc1Rva2VuUmV2b2NhdGlvblJlcXVlc3QocmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55Pik6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXF1ZXN0LnVybCA9PT0gdGhpcy5hdXRoQ29uZmlnU2VydmljZS5nZXRSZXZva2VFbmRwb2ludCgpO1xuICB9XG59XG4iXX0=