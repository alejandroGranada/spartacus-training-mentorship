import { isPlatformBrowser } from '@angular/common';
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import { GlobalMessageService } from '../../facade/global-message.service';
import * as i0 from "@angular/core";
import * as i1 from "../../facade/global-message.service";
export class HttpErrorHandler {
    constructor(globalMessageService, platformId) {
        this.globalMessageService = globalMessageService;
        this.platformId = platformId;
    }
    /**
     * Error handlers are matched by the error `responseStatus` (i.e. 404). On top of the matching status
     * a priority can be added to distinguish multiple handles for the same response status.
     */
    hasMatch(errorResponse) {
        return errorResponse.status === this.responseStatus;
    }
    /**
     * Returns true when invoked on the server (SSR).
     *
     * Added in 3.2, depends on the injected `platformId`.
     */
    isSsr() {
        if (this.platformId) {
            return !isPlatformBrowser(this.platformId);
        }
        return false;
    }
}
HttpErrorHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function HttpErrorHandler_Factory() { return new HttpErrorHandler(i0.ɵɵinject(i1.GlobalMessageService), i0.ɵɵinject(i0.PLATFORM_ID)); }, token: HttpErrorHandler, providedIn: "root" });
HttpErrorHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
HttpErrorHandler.ctorParameters = () => [
    { type: GlobalMessageService },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC1lcnJvci5oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL1BhdHJ5ay9EZXNrdG9wL3NwYXJ0YWN1cy9wcm9qZWN0cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL2dsb2JhbC1tZXNzYWdlL2h0dHAtaW50ZXJjZXB0b3JzL2hhbmRsZXJzL2h0dHAtZXJyb3IuaGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUVwRCxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFaEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0scUNBQXFDLENBQUM7OztBQUszRSxNQUFNLE9BQWdCLGdCQUFnQjtJQUNwQyxZQUNZLG9CQUEwQyxFQUNyQixVQUFtQjtRQUR4Qyx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO1FBQ3JCLGVBQVUsR0FBVixVQUFVLENBQVM7SUFDakQsQ0FBQztJQW1CSjs7O09BR0c7SUFDSCxRQUFRLENBQUMsYUFBZ0M7UUFDdkMsT0FBTyxhQUFhLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDdEQsQ0FBQztJQUlEOzs7O09BSUc7SUFDTyxLQUFLO1FBQ2IsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ25CLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDNUM7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7Ozs7WUE5Q0YsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUFKUSxvQkFBb0I7WUFRbUIsTUFBTSx1QkFBakQsTUFBTSxTQUFDLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBIdHRwRXJyb3JSZXNwb25zZSwgSHR0cFJlcXVlc3QgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIFBMQVRGT1JNX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBcHBsaWNhYmxlLCBQcmlvcml0eSB9IGZyb20gJy4uLy4uLy4uL3V0aWwvYXBwbGljYWJsZSc7XG5pbXBvcnQgeyBHbG9iYWxNZXNzYWdlU2VydmljZSB9IGZyb20gJy4uLy4uL2ZhY2FkZS9nbG9iYWwtbWVzc2FnZS5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEh0dHBFcnJvckhhbmRsZXIgaW1wbGVtZW50cyBBcHBsaWNhYmxlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIGdsb2JhbE1lc3NhZ2VTZXJ2aWNlOiBHbG9iYWxNZXNzYWdlU2VydmljZSxcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcm90ZWN0ZWQgcGxhdGZvcm1JZD86IE9iamVjdFxuICApIHt9XG5cbiAgLyoqXG4gICAqIFRoZSBodHRwIHJlc3BvbnNlIHN0YXR1cyBudW1iZXIgd2hpY2ggaXMgaGFuZGxlZCBieSB0aGlzIGhhbmRsZXIuXG4gICAqIEltcGxlbWVudGF0aW9ucyBjYW4gc2V0IHRoZSByZXNwb25zZSBzdGF0dXMgbnVtYmVyLCBpLmUuIDQwNCwgc28gdGhhdFxuICAgKiB0aGUgaGFuZGxlciBjYW4gYmUgZm91bmQgYnkgdGhlIGVycm9yIGludGVyY2VwdG9yLlxuICAgKi9cbiAgcmVzcG9uc2VTdGF0dXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGVycm9yIHJlc3BvbnNlIGZvciB0aGUgcmVzcG9uc2Ugc3RhdHVzIHRoYXQgaXMgcmVnaXN0ZXIgZm9yIHRoZSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7IEh0dHBSZXF1ZXN0PGFueT4gfSByZXF1ZXN0IDogaHR0cCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7IEh0dHBFcnJvclJlc3BvbnNlIH0gZXJyb3JSZXNwb25zZSA6IEh0dHAgZXJyb3IgcmVzcG9uc2VcbiAgICovXG4gIGFic3RyYWN0IGhhbmRsZUVycm9yKFxuICAgIHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PGFueT4sXG4gICAgZXJyb3JSZXNwb25zZTogSHR0cEVycm9yUmVzcG9uc2VcbiAgKTogdm9pZDtcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlcnMgYXJlIG1hdGNoZWQgYnkgdGhlIGVycm9yIGByZXNwb25zZVN0YXR1c2AgKGkuZS4gNDA0KS4gT24gdG9wIG9mIHRoZSBtYXRjaGluZyBzdGF0dXNcbiAgICogYSBwcmlvcml0eSBjYW4gYmUgYWRkZWQgdG8gZGlzdGluZ3Vpc2ggbXVsdGlwbGUgaGFuZGxlcyBmb3IgdGhlIHNhbWUgcmVzcG9uc2Ugc3RhdHVzLlxuICAgKi9cbiAgaGFzTWF0Y2goZXJyb3JSZXNwb25zZTogSHR0cEVycm9yUmVzcG9uc2UpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZXJyb3JSZXNwb25zZS5zdGF0dXMgPT09IHRoaXMucmVzcG9uc2VTdGF0dXM7XG4gIH1cblxuICBhYnN0cmFjdCBnZXRQcmlvcml0eT8oKTogUHJpb3JpdHk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB3aGVuIGludm9rZWQgb24gdGhlIHNlcnZlciAoU1NSKS5cbiAgICpcbiAgICogQWRkZWQgaW4gMy4yLCBkZXBlbmRzIG9uIHRoZSBpbmplY3RlZCBgcGxhdGZvcm1JZGAuXG4gICAqL1xuICBwcm90ZWN0ZWQgaXNTc3IoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMucGxhdGZvcm1JZCkge1xuICAgICAgcmV0dXJuICFpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdfQ==