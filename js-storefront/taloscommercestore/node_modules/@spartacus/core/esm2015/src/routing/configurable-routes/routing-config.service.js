import { Injectable, isDevMode } from '@angular/core';
import { RoutingConfig } from './config/routing-config';
import * as i0 from "@angular/core";
import * as i1 from "./config/routing-config";
export class RoutingConfigService {
    constructor(config) {
        this.config = config;
    }
    /**
     * Returns the route config for the given route name.
     */
    getRouteConfig(routeName) {
        var _a, _b;
        const routeConfig = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.routes;
        const result = routeConfig && routeConfig[routeName];
        if (!routeConfig || result === undefined) {
            this.warn(`No path was configured for the named route '${routeName}'!`);
        }
        return result;
    }
    warn(...args) {
        if (isDevMode()) {
            console.warn(...args);
        }
    }
    /**
     * Returns the configured route loading strategy.
     */
    getLoadStrategy() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.loadStrategy) !== null && _c !== void 0 ? _c : "always" /* ALWAYS */;
    }
    /**
     * Returns the route name of the configured path.
     *
     * For example, when the config is:
     * ```
     * routing: {
     *   routes: {
     *      addressBook: { paths: ['my-account/address-book'] }
     *   }
     * }
     * ```
     *
     * the `getRouteName('my-account/address-book')` returns `'addressBook'`.
     */
    getRouteName(path) {
        if (!this.routeNamesByPath) {
            this.initRouteNamesByPath();
        }
        return this.routeNamesByPath[path];
    }
    /**
     * Initializes the property `routeNamesByPath`.
     *
     * The original config allows for reading configured path by the route name.
     * But this method builds up a structure with a 'reversed config'
     * to read quickly the route name by the path.
     */
    initRouteNamesByPath() {
        var _a, _b, _c;
        this.routeNamesByPath = {};
        for (const [routeName, routeConfig] of Object.entries((_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.routing) === null || _b === void 0 ? void 0 : _b.routes)) {
            (_c = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.paths) === null || _c === void 0 ? void 0 : _c.forEach((path) => {
                if (isDevMode() && this.routeNamesByPath[path]) {
                    console.error(`The same path '${path}' is configured for two different route names: '${this.routeNamesByPath[path]}' and '${routeName}`);
                }
                this.routeNamesByPath[path] = routeName;
            });
        }
    }
}
RoutingConfigService.ɵprov = i0.ɵɵdefineInjectable({ factory: function RoutingConfigService_Factory() { return new RoutingConfigService(i0.ɵɵinject(i1.RoutingConfig)); }, token: RoutingConfigService, providedIn: "root" });
RoutingConfigService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
RoutingConfigService.ctorParameters = () => [
    { type: RoutingConfig }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGluZy1jb25maWcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvY29yZS8iLCJzb3VyY2VzIjpbInNyYy9yb3V0aW5nL2NvbmZpZ3VyYWJsZS1yb3V0ZXMvcm91dGluZy1jb25maWcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQXFCLGFBQWEsRUFBRSxNQUFNLHlCQUF5QixDQUFDOzs7QUFJM0UsTUFBTSxPQUFPLG9CQUFvQjtJQU0vQixZQUFzQixNQUFxQjtRQUFyQixXQUFNLEdBQU4sTUFBTSxDQUFlO0lBQUcsQ0FBQztJQUUvQzs7T0FFRztJQUNILGNBQWMsQ0FBQyxTQUFpQjs7UUFDOUIsTUFBTSxXQUFXLGVBQUcsSUFBSSxDQUFDLE1BQU0sMENBQUUsT0FBTywwQ0FBRSxNQUFNLENBQUM7UUFFakQsTUFBTSxNQUFNLEdBQUcsV0FBVyxJQUFJLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNyRCxJQUFJLENBQUMsV0FBVyxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQywrQ0FBK0MsU0FBUyxJQUFJLENBQUMsQ0FBQztTQUN6RTtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFTyxJQUFJLENBQUMsR0FBRyxJQUFJO1FBQ2xCLElBQUksU0FBUyxFQUFFLEVBQUU7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7U0FDdkI7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxlQUFlOztRQUNiLHlCQUFPLElBQUksQ0FBQyxNQUFNLDBDQUFFLE9BQU8sMENBQUUsWUFBWSx5REFBNkI7SUFDeEUsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSCxZQUFZLENBQUMsSUFBWTtRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQzFCLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1NBQzdCO1FBQ0QsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLG9CQUFvQjs7UUFDNUIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztRQUUzQixLQUFLLE1BQU0sQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sYUFDbkQsSUFBSSxDQUFDLE1BQU0sMENBQUUsT0FBTywwQ0FBRSxNQUFNLENBQzdCLEVBQUU7WUFDRCxNQUFBLFdBQVcsYUFBWCxXQUFXLHVCQUFYLFdBQVcsQ0FBRSxLQUFLLDBDQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUNuQyxJQUFJLFNBQVMsRUFBRSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDOUMsT0FBTyxDQUFDLEtBQUssQ0FDWCxrQkFBa0IsSUFBSSxtREFBbUQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxVQUFVLFNBQVMsRUFBRSxDQUMxSCxDQUFDO2lCQUNIO2dCQUNELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUM7WUFDMUMsQ0FBQyxFQUFFO1NBQ0o7SUFDSCxDQUFDOzs7O1lBOUVGLFVBQVUsU0FBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7OztZQUhOLGFBQWEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlTG9hZFN0cmF0ZWd5LCBSb3V0aW5nQ29uZmlnIH0gZnJvbSAnLi9jb25maWcvcm91dGluZy1jb25maWcnO1xuaW1wb3J0IHsgUm91dGVDb25maWcgfSBmcm9tICcuL3JvdXRlcy1jb25maWcnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIFJvdXRpbmdDb25maWdTZXJ2aWNlIHtcbiAgLyoqXG4gICAqIFJldmVyc2VkIHJvdXRpbmcgY29uZmlnIGZvciBxdWljayBsb29rdXAgb2YgdGhlIHJvdXRlIG5hbWUgYnkgdGhlIGNvbmZpZ3VyZWQgcGF0aC5cbiAgICovXG4gIHByb3RlY3RlZCByb3V0ZU5hbWVzQnlQYXRoOiB7IFtwYXRoOiBzdHJpbmddOiBzdHJpbmcgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgY29uZmlnOiBSb3V0aW5nQ29uZmlnKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb3V0ZSBjb25maWcgZm9yIHRoZSBnaXZlbiByb3V0ZSBuYW1lLlxuICAgKi9cbiAgZ2V0Um91dGVDb25maWcocm91dGVOYW1lOiBzdHJpbmcpOiBSb3V0ZUNvbmZpZyB7XG4gICAgY29uc3Qgcm91dGVDb25maWcgPSB0aGlzLmNvbmZpZz8ucm91dGluZz8ucm91dGVzO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gcm91dGVDb25maWcgJiYgcm91dGVDb25maWdbcm91dGVOYW1lXTtcbiAgICBpZiAoIXJvdXRlQ29uZmlnIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndhcm4oYE5vIHBhdGggd2FzIGNvbmZpZ3VyZWQgZm9yIHRoZSBuYW1lZCByb3V0ZSAnJHtyb3V0ZU5hbWV9JyFgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgd2FybiguLi5hcmdzKSB7XG4gICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICBjb25zb2xlLndhcm4oLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbmZpZ3VyZWQgcm91dGUgbG9hZGluZyBzdHJhdGVneS5cbiAgICovXG4gIGdldExvYWRTdHJhdGVneSgpOiBSb3V0ZUxvYWRTdHJhdGVneSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnPy5yb3V0aW5nPy5sb2FkU3RyYXRlZ3kgPz8gUm91dGVMb2FkU3RyYXRlZ3kuQUxXQVlTO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdXRlIG5hbWUgb2YgdGhlIGNvbmZpZ3VyZWQgcGF0aC5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIHdoZW4gdGhlIGNvbmZpZyBpczpcbiAgICogYGBgXG4gICAqIHJvdXRpbmc6IHtcbiAgICogICByb3V0ZXM6IHtcbiAgICogICAgICBhZGRyZXNzQm9vazogeyBwYXRoczogWydteS1hY2NvdW50L2FkZHJlc3MtYm9vayddIH1cbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIHRoZSBgZ2V0Um91dGVOYW1lKCdteS1hY2NvdW50L2FkZHJlc3MtYm9vaycpYCByZXR1cm5zIGAnYWRkcmVzc0Jvb2snYC5cbiAgICovXG4gIGdldFJvdXRlTmFtZShwYXRoOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMucm91dGVOYW1lc0J5UGF0aCkge1xuICAgICAgdGhpcy5pbml0Um91dGVOYW1lc0J5UGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yb3V0ZU5hbWVzQnlQYXRoW3BhdGhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBwcm9wZXJ0eSBgcm91dGVOYW1lc0J5UGF0aGAuXG4gICAqXG4gICAqIFRoZSBvcmlnaW5hbCBjb25maWcgYWxsb3dzIGZvciByZWFkaW5nIGNvbmZpZ3VyZWQgcGF0aCBieSB0aGUgcm91dGUgbmFtZS5cbiAgICogQnV0IHRoaXMgbWV0aG9kIGJ1aWxkcyB1cCBhIHN0cnVjdHVyZSB3aXRoIGEgJ3JldmVyc2VkIGNvbmZpZydcbiAgICogdG8gcmVhZCBxdWlja2x5IHRoZSByb3V0ZSBuYW1lIGJ5IHRoZSBwYXRoLlxuICAgKi9cbiAgcHJvdGVjdGVkIGluaXRSb3V0ZU5hbWVzQnlQYXRoKCkge1xuICAgIHRoaXMucm91dGVOYW1lc0J5UGF0aCA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBbcm91dGVOYW1lLCByb3V0ZUNvbmZpZ10gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICB0aGlzLmNvbmZpZz8ucm91dGluZz8ucm91dGVzXG4gICAgKSkge1xuICAgICAgcm91dGVDb25maWc/LnBhdGhzPy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgIGlmIChpc0Rldk1vZGUoKSAmJiB0aGlzLnJvdXRlTmFtZXNCeVBhdGhbcGF0aF0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFRoZSBzYW1lIHBhdGggJyR7cGF0aH0nIGlzIGNvbmZpZ3VyZWQgZm9yIHR3byBkaWZmZXJlbnQgcm91dGUgbmFtZXM6ICcke3RoaXMucm91dGVOYW1lc0J5UGF0aFtwYXRoXX0nIGFuZCAnJHtyb3V0ZU5hbWV9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3V0ZU5hbWVzQnlQYXRoW3BhdGhdID0gcm91dGVOYW1lO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iXX0=