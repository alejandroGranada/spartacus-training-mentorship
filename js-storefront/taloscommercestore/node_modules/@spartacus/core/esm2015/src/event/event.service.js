import { Injectable, isDevMode, Optional, } from '@angular/core';
import { Subject } from 'rxjs';
import { tap } from 'rxjs/operators';
import { FeatureConfigService } from '../features-config/services/feature-config.service';
import { createFrom } from '../util/create-from';
import { CxEvent } from './cx-event';
import { MergingSubject } from './utils/merging-subject';
import * as i0 from "@angular/core";
import * as i1 from "../features-config/services/feature-config.service";
/**
 * A service to register and observe event sources. Events are driven by event types, which are class signatures
 * for the given event.
 *
 * It is possible to register multiple sources to a single event, even without
 * knowing as multiple decoupled features can attach sources to the same
 * event type.
 */
export class EventService {
    constructor(
    // TODO: #10896 - remove this
    /** @deprecated @since 3.1 - this will be removed in 4.0 */ featureConfigService) {
        this.featureConfigService = featureConfigService;
        /**
         * The various events meta are collected in a map, stored by the event type class
         */
        this.eventsMeta = new Map();
    }
    /**
     * Register an event source for the given event type.
     *
     * CAUTION: To avoid memory leaks, the returned teardown function should be called
     *  when the event source is no longer maintained by its creator
     * (i.e. in `ngOnDestroy` if the event source was registered in the component).
     *
     * @since 3.1 - registers the given `source$` for the parent classes of the given `eventType`.
     *
     * @param eventType the event type
     * @param source$ an observable that represents the source
     *
     * @returns a teardown function which unregisters the given event source
     */
    // TODO: #10896 - change from `AbstractType` to `Type`.
    register(eventType, source$) {
        const eventMeta = this.getEventMeta(eventType);
        if (eventMeta.mergingSubject.has(source$)) {
            if (isDevMode()) {
                console.warn(`EventService: the event source`, source$, `has been already registered for the type`, eventType);
            }
        }
        else {
            eventMeta.mergingSubject.add(source$);
        }
        return () => eventMeta.mergingSubject.remove(source$);
    }
    /**
     * Returns a stream of events for the given event type
     * @param eventTypes event type
     */
    get(eventType) {
        let output$ = this.getEventMeta(eventType).mergingSubject.output$;
        if (isDevMode()) {
            output$ = this.getValidatedEventStream(output$, eventType);
        }
        return output$;
    }
    /**
     * Dispatches an instance of an individual event.
     * If the eventType is provided a new event will be created for that type and with the event data.
     *
     * @param event an event
     * @param eventType (optional) - type of event
     */
    dispatch(event, eventType) {
        if (!eventType) {
            eventType = event.constructor;
        }
        else if (!(event instanceof eventType)) {
            event = createFrom(eventType, event);
        }
        const inputSubject$ = this.getInputSubject(eventType);
        inputSubject$.next(event);
    }
    /**
     * Returns the input subject used to dispatch a single event.
     * The subject is created on demand, when it's needed for the first time.
     * @param eventType type of event
     */
    getInputSubject(eventType) {
        const eventMeta = this.getEventMeta(eventType);
        if (!eventMeta.inputSubject$) {
            eventMeta.inputSubject$ = new Subject();
            this.register(eventType, eventMeta.inputSubject$);
        }
        return eventMeta.inputSubject$;
    }
    /**
     * Returns the event meta object for the given event type
     */
    getEventMeta(eventType) {
        if (!this.eventsMeta.get(eventType)) {
            if (isDevMode()) {
                this.validateEventType(eventType);
            }
            this.createEventMeta(eventType);
        }
        return this.eventsMeta.get(eventType);
    }
    createEventMeta(eventType) {
        var _a;
        const eventMeta = {
            inputSubject$: null,
            mergingSubject: new MergingSubject(),
        };
        this.eventsMeta.set(eventType, eventMeta);
        // TODO: #10896 - remove this if block, and leave its body
        if ((_a = this.featureConfigService) === null || _a === void 0 ? void 0 : _a.isLevel('3.1')) {
            let parentEvent = Object.getPrototypeOf(eventType);
            while (parentEvent !== null &&
                Object.getPrototypeOf(parentEvent) !== Object.getPrototypeOf({})) {
                this.register(parentEvent, eventMeta.mergingSubject.output$);
                parentEvent = Object.getPrototypeOf(parentEvent);
            }
        }
    }
    /**
     * Checks if the event type is a valid type (is a class with constructor).
     *
     * Should be used only in dev mode.
     */
    validateEventType(eventType) {
        var _a;
        if (!(eventType === null || eventType === void 0 ? void 0 : eventType.constructor)) {
            throw new Error(`EventService:  ${eventType} is not a valid event type. Please provide a class reference.`);
        }
        // TODO: #10896 - remove this if block and leave its body
        if ((_a = this.featureConfigService) === null || _a === void 0 ? void 0 : _a.isLevel('3.1')) {
            this.validateCxEvent(eventType);
        }
    }
    /**
     * Validates if the given type (or its prototype chain) extends from the CxEvent.
     *
     * Should be used only in the dev mode.
     */
    validateCxEvent(eventType) {
        let parentType = eventType;
        while (parentType !== null &&
            Object.getPrototypeOf(parentType) !== Object.getPrototypeOf({})) {
            if (parentType.type === CxEvent.type) {
                return;
            }
            parentType = Object.getPrototypeOf(parentType);
        }
        console.warn(`The ${eventType.name} (or one of its parent classes) does not inherit from the ${CxEvent.type}`);
    }
    /**
     * Returns the given event source with runtime validation whether the emitted values are instances of given event type.
     *
     * Should be used only in dev mode.
     */
    getValidatedEventStream(source$, eventType) {
        return source$.pipe(tap((event) => {
            if (!(event instanceof eventType)) {
                console.warn(`EventService: The stream`, source$, `emitted the event`, event, `that is not an instance of the declared type`, eventType.name);
            }
        }));
    }
}
EventService.ɵprov = i0.ɵɵdefineInjectable({ factory: function EventService_Factory() { return new EventService(i0.ɵɵinject(i1.FeatureConfigService, 8)); }, token: EventService, providedIn: "root" });
EventService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
EventService.ctorParameters = () => [
    { type: FeatureConfigService, decorators: [{ type: Optional }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJDOi9Vc2Vycy9QYXRyeWsvRGVza3RvcC9zcGFydGFjdXMvcHJvamVjdHMvY29yZS8iLCJzb3VyY2VzIjpbInNyYy9ldmVudC9ldmVudC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCxVQUFVLEVBQ1YsU0FBUyxFQUNULFFBQVEsR0FFVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxvREFBb0QsQ0FBQztBQUMxRixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDakQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNyQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0seUJBQXlCLENBQUM7OztBQWlCekQ7Ozs7Ozs7R0FPRztBQUlILE1BQU0sT0FBTyxZQUFZO0lBQ3ZCO0lBQ0UsNkJBQTZCO0lBQzdCLDJEQUEyRCxDQUNqRCxvQkFBMkM7UUFBM0MseUJBQW9CLEdBQXBCLG9CQUFvQixDQUF1QjtRQUd2RDs7V0FFRztRQUNLLGVBQVUsR0FBRyxJQUFJLEdBQUcsRUFBMkMsQ0FBQztJQUxyRSxDQUFDO0lBT0o7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNILHVEQUF1RDtJQUN2RCxRQUFRLENBQUksU0FBMEIsRUFBRSxPQUFzQjtRQUM1RCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQy9DLElBQUksU0FBUyxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDekMsSUFBSSxTQUFTLEVBQUUsRUFBRTtnQkFDZixPQUFPLENBQUMsSUFBSSxDQUNWLGdDQUFnQyxFQUNo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QUEwQixFQUMxQixPQUFPLEVBQ1AsbUJBQW1CLEVBQ25CLEtBQUssRUFDTCw4Q0FBOEMsRUFDOUMsU0FBUyxDQUFDLElBQUksQ0FDZixDQUFDO2FBQ0g7UUFDSCxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQzs7OztZQTdMRixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7OztZQTlCUSxvQkFBb0IsdUJBa0NvQyxRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWJzdHJhY3RUeXBlLFxuICBJbmplY3RhYmxlLFxuICBpc0Rldk1vZGUsXG4gIE9wdGlvbmFsLFxuICBUeXBlLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEZlYXR1cmVDb25maWdTZXJ2aWNlIH0gZnJvbSAnLi4vZmVhdHVyZXMtY29uZmlnL3NlcnZpY2VzL2ZlYXR1cmUtY29uZmlnLnNlcnZpY2UnO1xuaW1wb3J0IHsgY3JlYXRlRnJvbSB9IGZyb20gJy4uL3V0aWwvY3JlYXRlLWZyb20nO1xuaW1wb3J0IHsgQ3hFdmVudCB9IGZyb20gJy4vY3gtZXZlbnQnO1xuaW1wb3J0IHsgTWVyZ2luZ1N1YmplY3QgfSBmcm9tICcuL3V0aWxzL21lcmdpbmctc3ViamVjdCc7XG5cbi8qKlxuICogVGhlIG9iamVjdCBob2xkcyByZWdpc3RlcmVkIHNvdXJjZSBvYnNlcnZhYmxlcyBhcyB3ZWxsIGFzIHRoZSBtZXJnZWQgcmVzdWx0IG9ic2VydmFibGUuXG4gKi9cbmludGVyZmFjZSBFdmVudE1ldGE8VD4ge1xuICAvKipcbiAgICogSW5wdXQgc3ViamVjdCB1c2VkIGZvciBkaXNwYXRjaGluZyBvY2Nhc2lvbmFsIGV2ZW50ICh3aXRob3V0IHJlZ2lzdGVyaW5nIGEgc291cmNlKVxuICAgKi9cbiAgaW5wdXRTdWJqZWN0JDogU3ViamVjdDxUPjtcblxuICAvKipcbiAgICogQSBjdXN0b20gc3ViamVjdCB0aGF0IGFsbG93cyBmb3IgZHluYW1pYyBhZGRpbmcgYW5kIHJlbW92aW5nIHNvdXJjZXMgdG8gYmUgbWVyZ2VkIGFzIGFuIG91dHB1dFxuICAgKi9cbiAgbWVyZ2luZ1N1YmplY3Q6IE1lcmdpbmdTdWJqZWN0PFQ+O1xufVxuXG4vKipcbiAqIEEgc2VydmljZSB0byByZWdpc3RlciBhbmQgb2JzZXJ2ZSBldmVudCBzb3VyY2VzLiBFdmVudHMgYXJlIGRyaXZlbiBieSBldmVudCB0eXBlcywgd2hpY2ggYXJlIGNsYXNzIHNpZ25hdHVyZXNcbiAqIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gcmVnaXN0ZXIgbXVsdGlwbGUgc291cmNlcyB0byBhIHNpbmdsZSBldmVudCwgZXZlbiB3aXRob3V0XG4gKiBrbm93aW5nIGFzIG11bHRpcGxlIGRlY291cGxlZCBmZWF0dXJlcyBjYW4gYXR0YWNoIHNvdXJjZXMgdG8gdGhlIHNhbWVcbiAqIGV2ZW50IHR5cGUuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBFdmVudFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUT0RPOiAjMTA4OTYgLSByZW1vdmUgdGhpc1xuICAgIC8qKiBAZGVwcmVjYXRlZCBAc2luY2UgMy4xIC0gdGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gNC4wICovIEBPcHRpb25hbCgpXG4gICAgcHJvdGVjdGVkIGZlYXR1cmVDb25maWdTZXJ2aWNlPzogRmVhdHVyZUNvbmZpZ1NlcnZpY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaW91cyBldmVudHMgbWV0YSBhcmUgY29sbGVjdGVkIGluIGEgbWFwLCBzdG9yZWQgYnkgdGhlIGV2ZW50IHR5cGUgY2xhc3NcbiAgICovXG4gIHByaXZhdGUgZXZlbnRzTWV0YSA9IG5ldyBNYXA8QWJzdHJhY3RUeXBlPGFueT4gfCBhbnksIEV2ZW50TWV0YTxhbnk+PigpO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBzb3VyY2UgZm9yIHRoZSBnaXZlbiBldmVudCB0eXBlLlxuICAgKlxuICAgKiBDQVVUSU9OOiBUbyBhdm9pZCBtZW1vcnkgbGVha3MsIHRoZSByZXR1cm5lZCB0ZWFyZG93biBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkXG4gICAqICB3aGVuIHRoZSBldmVudCBzb3VyY2UgaXMgbm8gbG9uZ2VyIG1haW50YWluZWQgYnkgaXRzIGNyZWF0b3JcbiAgICogKGkuZS4gaW4gYG5nT25EZXN0cm95YCBpZiB0aGUgZXZlbnQgc291cmNlIHdhcyByZWdpc3RlcmVkIGluIHRoZSBjb21wb25lbnQpLlxuICAgKlxuICAgKiBAc2luY2UgMy4xIC0gcmVnaXN0ZXJzIHRoZSBnaXZlbiBgc291cmNlJGAgZm9yIHRoZSBwYXJlbnQgY2xhc3NlcyBvZiB0aGUgZ2l2ZW4gYGV2ZW50VHlwZWAuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudFR5cGUgdGhlIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIHNvdXJjZSQgYW4gb2JzZXJ2YWJsZSB0aGF0IHJlcHJlc2VudHMgdGhlIHNvdXJjZVxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHdoaWNoIHVucmVnaXN0ZXJzIHRoZSBnaXZlbiBldmVudCBzb3VyY2VcbiAgICovXG4gIC8vIFRPRE86ICMxMDg5NiAtIGNoYW5nZSBmcm9tIGBBYnN0cmFjdFR5cGVgIHRvIGBUeXBlYC5cbiAgcmVnaXN0ZXI8VD4oZXZlbnRUeXBlOiBBYnN0cmFjdFR5cGU8VD4sIHNvdXJjZSQ6IE9ic2VydmFibGU8VD4pOiAoKSA9PiB2b2lkIHtcbiAgICBjb25zdCBldmVudE1ldGEgPSB0aGlzLmdldEV2ZW50TWV0YShldmVudFR5cGUpO1xuICAgIGlmIChldmVudE1ldGEubWVyZ2luZ1N1YmplY3QuaGFzKHNvdXJjZSQpKSB7XG4gICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBFdmVudFNlcnZpY2U6IHRoZSBldmVudCBzb3VyY2VgLFxuICAgICAgICAgIHNvdXJjZSQsXG4gICAgICAgICAgYGhhcyBiZWVuIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgdGhlIHR5cGVgLFxuICAgICAgICAgIGV2ZW50VHlwZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldmVudE1ldGEubWVyZ2luZ1N1YmplY3QuYWRkKHNvdXJjZSQpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiBldmVudE1ldGEubWVyZ2luZ1N1YmplY3QucmVtb3ZlKHNvdXJjZSQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJlYW0gb2YgZXZlbnRzIGZvciB0aGUgZ2l2ZW4gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gZXZlbnRUeXBlcyBldmVudCB0eXBlXG4gICAqL1xuICBnZXQ8VD4oZXZlbnRUeXBlOiBBYnN0cmFjdFR5cGU8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICBsZXQgb3V0cHV0JCA9IHRoaXMuZ2V0RXZlbnRNZXRhKGV2ZW50VHlwZSkubWVyZ2luZ1N1YmplY3Qub3V0cHV0JDtcbiAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgIG91dHB1dCQgPSB0aGlzLmdldFZhbGlkYXRlZEV2ZW50U3RyZWFtKG91dHB1dCQsIGV2ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQkO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gaW5zdGFuY2Ugb2YgYW4gaW5kaXZpZHVhbCBldmVudC5cbiAgICogSWYgdGhlIGV2ZW50VHlwZSBpcyBwcm92aWRlZCBhIG5ldyBldmVudCB3aWxsIGJlIGNyZWF0ZWQgZm9yIHRoYXQgdHlwZSBhbmQgd2l0aCB0aGUgZXZlbnQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IGFuIGV2ZW50XG4gICAqIEBwYXJhbSBldmVudFR5cGUgKG9wdGlvbmFsKSAtIHR5cGUgb2YgZXZlbnRcbiAgICovXG4gIGRpc3BhdGNoPFQ+KGV2ZW50OiBULCBldmVudFR5cGU/OiBUeXBlPFQ+KTogdm9pZCB7XG4gICAgaWYgKCFldmVudFR5cGUpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50LmNvbnN0cnVjdG9yIGFzIFR5cGU8VD47XG4gICAgfSBlbHNlIGlmICghKGV2ZW50IGluc3RhbmNlb2YgZXZlbnRUeXBlKSkge1xuICAgICAgZXZlbnQgPSBjcmVhdGVGcm9tKGV2ZW50VHlwZSwgZXZlbnQpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFN1YmplY3QkID0gdGhpcy5nZXRJbnB1dFN1YmplY3QoZXZlbnRUeXBlKTtcbiAgICBpbnB1dFN1YmplY3QkLm5leHQoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGlucHV0IHN1YmplY3QgdXNlZCB0byBkaXNwYXRjaCBhIHNpbmdsZSBldmVudC5cbiAgICogVGhlIHN1YmplY3QgaXMgY3JlYXRlZCBvbiBkZW1hbmQsIHdoZW4gaXQncyBuZWVkZWQgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIHR5cGUgb2YgZXZlbnRcbiAgICovXG4gIHByaXZhdGUgZ2V0SW5wdXRTdWJqZWN0PFQ+KGV2ZW50VHlwZTogQWJzdHJhY3RUeXBlPFQ+KTogU3ViamVjdDxUPiB7XG4gICAgY29uc3QgZXZlbnRNZXRhID0gdGhpcy5nZXRFdmVudE1ldGEoZXZlbnRUeXBlKTtcblxuICAgIGlmICghZXZlbnRNZXRhLmlucHV0U3ViamVjdCQpIHtcbiAgICAgIGV2ZW50TWV0YS5pbnB1dFN1YmplY3QkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICAgICAgdGhpcy5yZWdpc3RlcihldmVudFR5cGUsIGV2ZW50TWV0YS5pbnB1dFN1YmplY3QkKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50TWV0YS5pbnB1dFN1YmplY3QkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV2ZW50IG1ldGEgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZXZlbnQgdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRFdmVudE1ldGE8VD4oZXZlbnRUeXBlOiBBYnN0cmFjdFR5cGU8VD4pOiBFdmVudE1ldGE8VD4ge1xuICAgIGlmICghdGhpcy5ldmVudHNNZXRhLmdldChldmVudFR5cGUpKSB7XG4gICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUV2ZW50VHlwZShldmVudFR5cGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jcmVhdGVFdmVudE1ldGEoZXZlbnRUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzTWV0YS5nZXQoZXZlbnRUeXBlKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRXZlbnRNZXRhPFQ+KGV2ZW50VHlwZTogQWJzdHJhY3RUeXBlPFQ+KTogdm9pZCB7XG4gICAgY29uc3QgZXZlbnRNZXRhOiBFdmVudE1ldGE8VD4gPSB7XG4gICAgICBpbnB1dFN1YmplY3QkOiBudWxsLCAvLyB3aWxsIGJlIGNyZWF0ZWQgbGF6aWx5IGJ5IHRoZSBgZGlzcGF0Y2hgIG1ldGhvZFxuICAgICAgbWVyZ2luZ1N1YmplY3Q6IG5ldyBNZXJnaW5nU3ViamVjdDxUPigpLFxuICAgIH07XG4gICAgdGhpcy5ldmVudHNNZXRhLnNldChldmVudFR5cGUsIGV2ZW50TWV0YSk7XG5cbiAgICAvLyBUT0RPOiAjMTA4OTYgLSByZW1vdmUgdGhpcyBpZiBibG9jaywgYW5kIGxlYXZlIGl0cyBib2R5XG4gICAgaWYgKHRoaXMuZmVhdHVyZUNvbmZpZ1NlcnZpY2U/LmlzTGV2ZWwoJzMuMScpKSB7XG4gICAgICBsZXQgcGFyZW50RXZlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXZlbnRUeXBlKTtcbiAgICAgIHdoaWxlIChcbiAgICAgICAgcGFyZW50RXZlbnQgIT09IG51bGwgJiZcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudEV2ZW50KSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIocGFyZW50RXZlbnQsIGV2ZW50TWV0YS5tZXJnaW5nU3ViamVjdC5vdXRwdXQkKTtcbiAgICAgICAgcGFyZW50RXZlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50RXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGV2ZW50IHR5cGUgaXMgYSB2YWxpZCB0eXBlIChpcyBhIGNsYXNzIHdpdGggY29uc3RydWN0b3IpLlxuICAgKlxuICAgKiBTaG91bGQgYmUgdXNlZCBvbmx5IGluIGRldiBtb2RlLlxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZUV2ZW50VHlwZTxUPihldmVudFR5cGU6IEFic3RyYWN0VHlwZTxUPik6IHZvaWQge1xuICAgIGlmICghZXZlbnRUeXBlPy5jb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXZlbnRTZXJ2aWNlOiAgJHtldmVudFR5cGV9IGlzIG5vdCBhIHZhbGlkIGV2ZW50IHR5cGUuIFBsZWFzZSBwcm92aWRlIGEgY2xhc3MgcmVmZXJlbmNlLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogIzEwODk2IC0gcmVtb3ZlIHRoaXMgaWYgYmxvY2sgYW5kIGxlYXZlIGl0cyBib2R5XG4gICAgaWYgKHRoaXMuZmVhdHVyZUNvbmZpZ1NlcnZpY2U/LmlzTGV2ZWwoJzMuMScpKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlQ3hFdmVudChldmVudFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgdGhlIGdpdmVuIHR5cGUgKG9yIGl0cyBwcm90b3R5cGUgY2hhaW4pIGV4dGVuZHMgZnJvbSB0aGUgQ3hFdmVudC5cbiAgICpcbiAgICogU2hvdWxkIGJlIHVzZWQgb25seSBpbiB0aGUgZGV2IG1vZGUuXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlQ3hFdmVudDxUPihldmVudFR5cGU6IEFic3RyYWN0VHlwZTxUPik6IHZvaWQge1xuICAgIGxldCBwYXJlbnRUeXBlID0gZXZlbnRUeXBlO1xuICAgIHdoaWxlIChcbiAgICAgIHBhcmVudFR5cGUgIT09IG51bGwgJiZcbiAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnRUeXBlKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KVxuICAgICkge1xuICAgICAgaWYgKChwYXJlbnRUeXBlIGFzIGFueSkudHlwZSA9PT0gQ3hFdmVudC50eXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFyZW50VHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnRUeXBlKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgVGhlICR7ZXZlbnRUeXBlLm5hbWV9IChvciBvbmUgb2YgaXRzIHBhcmVudCBjbGFzc2VzKSBkb2VzIG5vdCBpbmhlcml0IGZyb20gdGhlICR7Q3hFdmVudC50eXBlfWBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdpdmVuIGV2ZW50IHNvdXJjZSB3aXRoIHJ1bnRpbWUgdmFsaWRhdGlvbiB3aGV0aGVyIHRoZSBlbWl0dGVkIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIGdpdmVuIGV2ZW50IHR5cGUuXG4gICAqXG4gICAqIFNob3VsZCBiZSB1c2VkIG9ubHkgaW4gZGV2IG1vZGUuXG4gICAqL1xuICBwcml2YXRlIGdldFZhbGlkYXRlZEV2ZW50U3RyZWFtPFQ+KFxuICAgIHNvdXJjZSQ6IE9ic2VydmFibGU8VD4sXG4gICAgZXZlbnRUeXBlOiBBYnN0cmFjdFR5cGU8VD5cbiAgKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgcmV0dXJuIHNvdXJjZSQucGlwZShcbiAgICAgIHRhcCgoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCEoZXZlbnQgaW5zdGFuY2VvZiBldmVudFR5cGUpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYEV2ZW50U2VydmljZTogVGhlIHN0cmVhbWAsXG4gICAgICAgICAgICBzb3VyY2UkLFxuICAgICAgICAgICAgYGVtaXR0ZWQgdGhlIGV2ZW50YCxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgYHRoYXQgaXMgbm90IGFuIGluc3RhbmNlIG9mIHRoZSBkZWNsYXJlZCB0eXBlYCxcbiAgICAgICAgICAgIGV2ZW50VHlwZS5uYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iXX0=