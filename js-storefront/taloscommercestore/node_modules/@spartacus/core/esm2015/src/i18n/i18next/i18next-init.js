import { Injectable } from '@angular/core';
import i18nextXhrBackend from 'i18next-xhr-backend';
import * as i0 from "@angular/core";
export function i18nextInit(i18next, configInit, languageService, httpClient, serverRequestOrigin, siteContextI18nextSynchronizer) {
    return () => configInit.getStableConfig('i18n').then((config) => {
        let i18nextConfig = {
            ns: [],
            fallbackLng: config.i18n.fallbackLang,
            debug: config.i18n.debug,
            interpolation: {
                escapeValue: false,
            },
        };
        if (config.i18n.backend) {
            i18next.use(i18nextXhrBackend);
            const loadPath = getLoadPath(config.i18n.backend.loadPath, serverRequestOrigin);
            const backend = {
                loadPath,
                ajax: i18nextGetHttpClient(httpClient),
            };
            i18nextConfig = Object.assign(Object.assign({}, i18nextConfig), { backend });
        }
        return i18next.init(i18nextConfig, () => {
            // Don't use i18next's 'resources' config key for adding static translations,
            // because it will disable loading chunks from backend. We add resources here, in the init's callback.
            i18nextAddTranslations(i18next, config.i18n.resources);
            siteContextI18nextSynchronizer.init(i18next, languageService);
        });
    });
}
export function i18nextAddTranslations(i18next, resources = {}) {
    Object.keys(resources).forEach((lang) => {
        Object.keys(resources[lang]).forEach((chunkName) => {
            i18next.addResourceBundle(lang, chunkName, resources[lang][chunkName], true, true);
        });
    });
}
export class SiteContextI18nextSynchronizer {
    init(i18next, language) {
        var _a;
        // always update language of i18next on site context (language) change
        this.sub = (_a = this.sub) !== null && _a !== void 0 ? _a : language.getActive().subscribe((lang) => i18next.changeLanguage(lang));
    }
    ngOnDestroy() {
        var _a;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
}
SiteContextI18nextSynchronizer.ɵprov = i0.ɵɵdefineInjectable({ factory: function SiteContextI18nextSynchronizer_Factory() { return new SiteContextI18nextSynchronizer(); }, token: SiteContextI18nextSynchronizer, providedIn: "root" });
SiteContextI18nextSynchronizer.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/**
 * Returns a function appropriate for i18next to make http calls for JSON files.
 * See docs for `i18next-xhr-backend`: https://github.com/i18next/i18next-xhr-backend#backend-options
 *
 * It uses Angular HttpClient under the hood, so it works in SSR.
 * @param httpClient Angular http client
 */
export function i18nextGetHttpClient(httpClient) {
    return (url, _options, callback, _data) => {
        httpClient.get(url, { responseType: 'text' }).subscribe((data) => callback(data, { status: 200 }), (error) => callback(null, { status: error.status }));
    };
}
/**
 * Resolves the relative path to the absolute one in SSR, using the server request's origin.
 * It's needed, because Angular Universal doesn't support relative URLs in HttpClient. See Angular issues:
 * - https://github.com/angular/angular/issues/19224
 * - https://github.com/angular/universal/issues/858
 */
export function getLoadPath(path, serverRequestOrigin) {
    if (!path) {
        return undefined;
    }
    if (serverRequestOrigin && !path.match(/^http(s)?:\/\//)) {
        if (path.startsWith('/')) {
            path = path.slice(1);
        }
        if (path.startsWith('./')) {
            path = path.slice(2);
        }
        const result = `${serverRequestOrigin}/${path}`;
        return result;
    }
    return path;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaTE4bmV4dC1pbml0LmpzIiwic291cmNlUm9vdCI6IkM6L1VzZXJzL1BhdHJ5ay9EZXNrdG9wL3NwYXJ0YWN1cy9wcm9qZWN0cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL2kxOG4vaTE4bmV4dC9pMThuZXh0LWluaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFVBQVUsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUV0RCxPQUFPLGlCQUFpQixNQUFNLHFCQUFxQixDQUFDOztBQU1wRCxNQUFNLFVBQVUsV0FBVyxDQUN6QixPQUFhLEVBQ2IsVUFBb0MsRUFDcEMsZUFBZ0MsRUFDaEMsVUFBc0IsRUFDdEIsbUJBQTJCLEVBQzNCLDhCQUE4RDtJQUU5RCxPQUFPLEdBQUcsRUFBRSxDQUNWLFVBQVUsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7UUFDakQsSUFBSSxhQUFhLEdBQWdCO1lBQy9CLEVBQUUsRUFBRSxFQUFFO1lBQ04sV0FBVyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWTtZQUNyQyxLQUFLLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLO1lBQ3hCLGFBQWEsRUFBRTtnQkFDYixXQUFXLEVBQUUsS0FBSzthQUNuQjtTQUNGLENBQUM7UUFDRixJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ3ZCLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUMvQixNQUFNLFFBQVEsR0FBRyxXQUFXLENBQzFCLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFDNUIsbUJBQW1CLENBQ3BCLENBQUM7WUFDRixNQUFNLE9BQU8sR0FBRztnQkFDZCxRQUFRO2dCQUNSLElBQUksRUFBRSxvQkFBb0IsQ0FBQyxVQUFVLENBQUM7YUFDdkMsQ0FBQztZQUNGLGFBQWEsbUNBQVEsYUFBYSxLQUFFLE9BQU8sR0FBRSxD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Q0FBQztLQUNmO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaTE4biwgSW5pdE9wdGlvbnMgfSBmcm9tICdpMThuZXh0JztcbmltcG9ydCBpMThuZXh0WGhyQmFja2VuZCBmcm9tICdpMThuZXh0LXhoci1iYWNrZW5kJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQ29uZmlnSW5pdGlhbGl6ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vY29uZmlnL2NvbmZpZy1pbml0aWFsaXplci9jb25maWctaW5pdGlhbGl6ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBMYW5ndWFnZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zaXRlLWNvbnRleHQvZmFjYWRlL2xhbmd1YWdlLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJhbnNsYXRpb25SZXNvdXJjZXMgfSBmcm9tICcuLi90cmFuc2xhdGlvbi1yZXNvdXJjZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaTE4bmV4dEluaXQoXG4gIGkxOG5leHQ6IGkxOG4sXG4gIGNvbmZpZ0luaXQ6IENvbmZpZ0luaXRpYWxpemVyU2VydmljZSxcbiAgbGFuZ3VhZ2VTZXJ2aWNlOiBMYW5ndWFnZVNlcnZpY2UsXG4gIGh0dHBDbGllbnQ6IEh0dHBDbGllbnQsXG4gIHNlcnZlclJlcXVlc3RPcmlnaW46IHN0cmluZyxcbiAgc2l0ZUNvbnRleHRJMThuZXh0U3luY2hyb25pemVyOiBTaXRlQ29udGV4dEkxOG5leHRTeW5jaHJvbml6ZXJcbik6ICgpID0+IFByb21pc2U8YW55PiB7XG4gIHJldHVybiAoKSA9PlxuICAgIGNvbmZpZ0luaXQuZ2V0U3RhYmxlQ29uZmlnKCdpMThuJykudGhlbigoY29uZmlnKSA9PiB7XG4gICAgICBsZXQgaTE4bmV4dENvbmZpZzogSW5pdE9wdGlvbnMgPSB7XG4gICAgICAgIG5zOiBbXSwgLy8gZG9uJ3QgcHJlbG9hZCBhbnkgbmFtZXNwYWNlc1xuICAgICAgICBmYWxsYmFja0xuZzogY29uZmlnLmkxOG4uZmFsbGJhY2tMYW5nLFxuICAgICAgICBkZWJ1ZzogY29uZmlnLmkxOG4uZGVidWcsXG4gICAgICAgIGludGVycG9sYXRpb246IHtcbiAgICAgICAgICBlc2NhcGVWYWx1ZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgaWYgKGNvbmZpZy5pMThuLmJhY2tlbmQpIHtcbiAgICAgICAgaTE4bmV4dC51c2UoaTE4bmV4dFhockJhY2tlbmQpO1xuICAgICAgICBjb25zdCBsb2FkUGF0aCA9IGdldExvYWRQYXRoKFxuICAgICAgICAgIGNvbmZpZy5pMThuLmJhY2tlbmQubG9hZFBhdGgsXG4gICAgICAgICAgc2VydmVyUmVxdWVzdE9yaWdpblxuICAgICAgICApO1xuICAgICAgICBjb25zdCBiYWNrZW5kID0ge1xuICAgICAgICAgIGxvYWRQYXRoLFxuICAgICAgICAgIGFqYXg6IGkxOG5leHRHZXRIdHRwQ2xpZW50KGh0dHBDbGllbnQpLFxuICAgICAgICB9O1xuICAgICAgICBpMThuZXh0Q29uZmlnID0geyAuLi5pMThuZXh0Q29uZmlnLCBiYWNrZW5kIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpMThuZXh0LmluaXQoaTE4bmV4dENvbmZpZywgKCkgPT4ge1xuICAgICAgICAvLyBEb24ndCB1c2UgaTE4bmV4dCdzICdyZXNvdXJjZXMnIGNvbmZpZyBrZXkgZm9yIGFkZGluZyBzdGF0aWMgdHJhbnNsYXRpb25zLFxuICAgICAgICAvLyBiZWNhdXNlIGl0IHdpbGwgZGlzYWJsZSBsb2FkaW5nIGNodW5rcyBmcm9tIGJhY2tlbmQuIFdlIGFkZCByZXNvdXJjZXMgaGVyZSwgaW4gdGhlIGluaXQncyBjYWxsYmFjay5cbiAgICAgICAgaTE4bmV4dEFkZFRyYW5zbGF0aW9ucyhpMThuZXh0LCBjb25maWcuaTE4bi5yZXNvdXJjZXMpO1xuICAgICAgICBzaXRlQ29udGV4dEkxOG5leHRTeW5jaHJvbml6ZXIuaW5pdChpMThuZXh0LCBsYW5ndWFnZVNlcnZpY2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpMThuZXh0QWRkVHJhbnNsYXRpb25zKFxuICBpMThuZXh0OiBpMThuLFxuICByZXNvdXJjZXM6IFRyYW5zbGF0aW9uUmVzb3VyY2VzID0ge31cbikge1xuICBPYmplY3Qua2V5cyhyZXNvdXJjZXMpLmZvckVhY2goKGxhbmcpID0+IHtcbiAgICBPYmplY3Qua2V5cyhyZXNvdXJjZXNbbGFuZ10pLmZvckVhY2goKGNodW5rTmFtZSkgPT4ge1xuICAgICAgaTE4bmV4dC5hZGRSZXNvdXJjZUJ1bmRsZShcbiAgICAgICAgbGFuZyxcbiAgICAgICAgY2h1bmtOYW1lLFxuICAgICAgICByZXNvdXJjZXNbbGFuZ11bY2h1bmtOYW1lXSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgU2l0ZUNvbnRleHRJMThuZXh0U3luY2hyb25pemVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgc3ViOiBTdWJzY3JpcHRpb247XG5cbiAgaW5pdChpMThuZXh0OiBpMThuLCBsYW5ndWFnZTogTGFuZ3VhZ2VTZXJ2aWNlKSB7XG4gICAgLy8gYWx3YXlzIHVwZGF0ZSBsYW5ndWFnZSBvZiBpMThuZXh0IG9uIHNpdGUgY29udGV4dCAobGFuZ3VhZ2UpIGNoYW5nZVxuICAgIHRoaXMuc3ViID1cbiAgICAgIHRoaXMuc3ViID8/XG4gICAgICBsYW5ndWFnZS5nZXRBY3RpdmUoKS5zdWJzY3JpYmUoKGxhbmcpID0+IGkxOG5leHQuY2hhbmdlTGFuZ3VhZ2UobGFuZykpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWI/LnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gYXBwcm9wcmlhdGUgZm9yIGkxOG5leHQgdG8gbWFrZSBodHRwIGNhbGxzIGZvciBKU09OIGZpbGVzLlxuICogU2VlIGRvY3MgZm9yIGBpMThuZXh0LXhoci1iYWNrZW5kYDogaHR0cHM6Ly9naXRodWIuY29tL2kxOG5leHQvaTE4bmV4dC14aHItYmFja2VuZCNiYWNrZW5kLW9wdGlvbnNcbiAqXG4gKiBJdCB1c2VzIEFuZ3VsYXIgSHR0cENsaWVudCB1bmRlciB0aGUgaG9vZCwgc28gaXQgd29ya3MgaW4gU1NSLlxuICogQHBhcmFtIGh0dHBDbGllbnQgQW5ndWxhciBodHRwIGNsaWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaTE4bmV4dEdldEh0dHBDbGllbnQoXG4gIGh0dHBDbGllbnQ6IEh0dHBDbGllbnRcbik6ICh1cmw6IHN0cmluZywgb3B0aW9uczogb2JqZWN0LCBjYWxsYmFjazogRnVuY3Rpb24sIGRhdGE6IG9iamVjdCkgPT4gdm9pZCB7XG4gIHJldHVybiAodXJsOiBzdHJpbmcsIF9vcHRpb25zOiBvYmplY3QsIGNhbGxiYWNrOiBGdW5jdGlvbiwgX2RhdGE6IG9iamVjdCkgPT4ge1xuICAgIGh0dHBDbGllbnQuZ2V0KHVybCwgeyByZXNwb25zZVR5cGU6ICd0ZXh0JyB9KS5zdWJzY3JpYmUoXG4gICAgICAoZGF0YSkgPT4gY2FsbGJhY2soZGF0YSwgeyBzdGF0dXM6IDIwMCB9KSxcbiAgICAgIChlcnJvcikgPT4gY2FsbGJhY2sobnVsbCwgeyBzdGF0dXM6IGVycm9yLnN0YXR1cyB9KVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHJlbGF0aXZlIHBhdGggdG8gdGhlIGFic29sdXRlIG9uZSBpbiBTU1IsIHVzaW5nIHRoZSBzZXJ2ZXIgcmVxdWVzdCdzIG9yaWdpbi5cbiAqIEl0J3MgbmVlZGVkLCBiZWNhdXNlIEFuZ3VsYXIgVW5pdmVyc2FsIGRvZXNuJ3Qgc3VwcG9ydCByZWxhdGl2ZSBVUkxzIGluIEh0dHBDbGllbnQuIFNlZSBBbmd1bGFyIGlzc3VlczpcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTkyMjRcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvdW5pdmVyc2FsL2lzc3Vlcy84NThcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRQYXRoKHBhdGg6IHN0cmluZywgc2VydmVyUmVxdWVzdE9yaWdpbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoc2VydmVyUmVxdWVzdE9yaWdpbiAmJiAhcGF0aC5tYXRjaCgvXmh0dHAocyk/OlxcL1xcLy8pKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICBwYXRoID0gcGF0aC5zbGljZSgxKTtcbiAgICB9XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnLi8nKSkge1xuICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGAke3NlcnZlclJlcXVlc3RPcmlnaW59LyR7cGF0aH1gO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG4iXX0=